<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>计算机网络细节 | AndreKuu</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="TCP和UDP的区别TCP\UDP是传输层的两种不同传输协议。TCP传输控制协议，是一种提供可靠的、端到端的、面向连接的字节流的协议,UDP用户数据报协议，无连接的不可靠数据报服务协议。（1）TCP面向连接，就是通信开始前，需要建立连接，通信过程中需要维护连接，通行结束后需要释放连接，传输数据之前需要确定接收方的存在，并与接收方协议缓冲区大小，和序号起始值；UDP面向无连接，无需维护和断开连接，也">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络细节">
<meta property="og:url" content="https://andrekuu.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/index.html">
<meta property="og:site_name" content="AndreKuu">
<meta property="og:description" content="TCP和UDP的区别TCP\UDP是传输层的两种不同传输协议。TCP传输控制协议，是一种提供可靠的、端到端的、面向连接的字节流的协议,UDP用户数据报协议，无连接的不可靠数据报服务协议。（1）TCP面向连接，就是通信开始前，需要建立连接，通信过程中需要维护连接，通行结束后需要释放连接，传输数据之前需要确定接收方的存在，并与接收方协议缓冲区大小，和序号起始值；UDP面向无连接，无需维护和断开连接，也">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://andrekuu.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/1.png">
<meta property="og:image" content="https://andrekuu.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/2.png">
<meta property="og:image" content="https://andrekuu.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/1.png">
<meta property="og:image" content="https://andrekuu.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/2.png">
<meta property="og:image" content="https://andrekuu.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/3.png">
<meta property="og:image" content="https://andrekuu.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/5.png">
<meta property="og:image" content="https://andrekuu.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/6.png">
<meta property="og:image" content="https://andrekuu.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/8.png">
<meta property="og:image" content="https://andrekuu.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/9.png">
<meta property="og:image" content="https://andrekuu.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/10.png">
<meta property="og:image" content="https://andrekuu.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/11.png">
<meta property="og:image" content="https://andrekuu.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/12.png">
<meta property="og:image" content="https://andrekuu.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/13.png">
<meta property="og:image" content="https://andrekuu.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/14.png">
<meta property="og:image" content="https://andrekuu.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/15.png">
<meta property="og:image" content="https://andrekuu.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/16.png">
<meta property="og:image" content="https://andrekuu.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/17.png">
<meta property="article:published_time" content="2021-04-21T19:43:19.000Z">
<meta property="article:modified_time" content="2021-04-21T19:44:40.550Z">
<meta property="article:author" content="AndreKuu">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://andrekuu.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/1.png">
  
    <link rel="alternate" href="/atom.xml" title="AndreKuu" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">AndreKuu</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://AndreKuu.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-计算机网络细节" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/" class="article-date">
  <time class="dt-published" datetime="2021-04-21T19:43:19.000Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      计算机网络细节
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><p>TCP\UDP是传输层的两种不同传输协议。TCP传输控制协议，是一种提供可靠的、端到端的、面向连接的字节流的协议,UDP用户数据报协议，无连接的不可靠数据报服务协议。<br>（1）TCP面向连接，就是通信开始前，需要建立连接，通信过程中需要维护连接，通行结束后需要释放连接，传输数据之前需要确定接收方的存在，并与接收方协议缓冲区大小，和序号起始值；UDP面向无连接，无需维护和断开连接，也就是在与通信方没有建立连接的的情况下发送出去，网络层如果是IP协议，那发送方根据对方的ip地址就发送数据包，并且也不提供序号服务和流量控制功能。<br>（2）TCP是可靠的传输协议，保证数据送达、正确性、排序正确；UDP可能丢包、错误、乱序；<br>（3）TCP传输速度慢；UDP速度快。因为UDP没有TCP三次握手的建立连接的步骤，省去了这部分时延，同时TCP有流量控制机制，就是当源和目的主机间一条或者多条链路出现极度拥塞的时候，来遏制传输层TCP的发送，所以TCP服务模型传输速度是比不上UDP的。<br>（4）TCP是Unicast的，不支持Multicast和Broadcast，每一条TCP连接只能是端到端的也就是一对一的；UDP支持一对一，一对多，多对一和多对多的交互通信<br>（5）TCP对系统资源要求较多，UDP对系统资源要求较少。因为TCP需要维护连接状态，连接状态包括接受和发送缓存、流量控制参数和序号、确认号的参数。UDP则不跟踪和维护这些参数 所以一般在UDP致上运行的服务器，能支撑更多的活跃用户。<br> (6) 分组首部开销小。每个TCP报文段都有20字节的首部开销，而UDP只有8个字节的开销。   </p>
<p><em>虽然UDP协议不稳定但是在即时通讯（QQ聊天、在线视频、网络语音电话）的场景下，可以允许偶尔的断续，但是这种协议速度快。DNS就是一个应用 UDP 的例子，当我们输入网址访问网站时，DNS 就是通过 UDP 发送域名查询报文的。所以，如果长时间没有得到回复，我们就会看到“连接超时”的错误页面。谷歌的CHrome浏览器就不使用TCP，使用QUIC协议，快速UDP因特网连接，是运输层基于UDP作为其支撑运输的协议，并在UDP之上的应用层协议实现可靠性，在应用层中增加确认和重传机制，这样构建的应用程序可以“左右逢源”，也就是说应用进程可以进行可靠的通信，而无需受制于TCP流量控制协议带来的强加的传输速率限制。但是不加限制的在高流量应用程序上采用UDP，也会导致全网络链路上长时间拥挤，而导致大量分组溢出，高丢包率。网络管理承载、电话会议、DNS通常采用UDP,电子邮件、远程终端访问、文件传输、Web采用TCP。</em>      </p>
<h2 id="什么是TCP三次握手"><a href="#什么是TCP三次握手" class="headerlink" title="什么是TCP三次握手"></a>什么是TCP三次握手</h2><p><img src="1.png"></p>
<p>TCP是运输层中一个面向连接的、可靠的、字节流服务。因为他是面对连接的，所以需要先建立连接然后维护连接最后断开连接释放资源，三次握手说的就是TCP建立连接的这个过程，三次握手的目的是建立可靠的通信信道，确认自己和对方发送与接收正常，并且确认双方的初始序号。    </p>
<p><strong>建立TCP连接协议时，需要在客户端和服务器之间发送三个包，握手过程中传送的包里不包含应用层数据，三次握手完毕后，建立全开连接，客户端与服务器才可以正式开始传送数据。</strong>   </p>
<p><strong>第一次握手：客户端发送第一个包，其中SYN标志位为1，发送序号sequence置为X(随机32位数)，这个随机是为了避免某些安全性攻击的。客户端进入SYN_sent发送状态，等待服务器确认。这个报文段称为SYN报文段</strong><br><strong>第二次握手：服务器收到SYN报文段后，为该TCP连接分配TCP缓存和变量，当然现在为了防御SYN洪流攻击，服务器已经把这个过程挪到第三次握手完成后才开始了。并向客户TCP发送允许连接的报文段，其中包SYN标志位为1，表明服务器想要和客户机建立连接；ACK置为1，表明服务器收到了请求并同意与客户机连接，发送初始序号seq为Y，（当然现在也是也是常用SYN COOKIE，这个Y其实是用源和目的IP地址利用散列函数实现的一个值）接收确认序号X+1，此时服务器进入SYN接收状态。这个服务器发送的允许连接的报文段也被称为SYNACK报文段</strong><br><strong>第三次握手：客户端收到服务器TCP的SYNACK报文段后，客户机也要开始为连接分配缓存和变量，客户机向服务器允许连接的报文段发送一个确认的数据报，接收确认序号置为Y+1,因为已经连接建立了，所以SYN=0，发送序号seq置为X+1。此包发送完毕，客户端和服务器进入建立成功状态，完成三次握手。握手的第三个阶段是允许报文段负载携带客户到服务器的数据的。第三次握手目的是为了防止已经失效的连接请求报文段又传送到了服务端，由于现在主机没有发送新的连接请求，如果没有第三次ACK握手，服务器就会一直等待主机发来数据，而很多资源就被浪费了，TCP 需要 seq 序列号来做可靠重传或接收，因此需要三次握手来约定确定双方的初始序列号</strong> </p>
<p><em>1) A –&gt; B  SYN my sequence number is X 2) A &lt;– B  ACK your sequence number is X 3) A &lt;– B  SYN my sequence number is Y 4) A –&gt; B  ACK your sequence number is Y简单的来说就是需要第三次我说来确认这个数据报是新的，而不是delay的。</em></p>
<p><em>第一个报文段，就是A发送给B的SYN数据报中途丢失，则A会周期性超时重传，直到收到B的确认。<br>第二个报文段，即B发给A的SYNACK报文段（SYN+ACK） 中途被丢，没有到达A，则： B会周期性超时重传，直到收到A的确认<br>第三个报文段，即A发给B的ACK 中途被丢，没有到达B ：则A发完ACK，单方面认为TCP为 Established状态，而B显然认为TCP为Active状态：<br>a. 假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP 连接<br>也为 Established状态，双向可以发包。<br>b. 假定此时A有数据发送，B收到A的 Data + ACK，自然会切换为established 状态，并接受A的Data。<br>c. 假定B有数据发送，数据发送不了，会一直周期性超时重传SYN + ACK，直到收到A的确认才可以发送数据。</em></p>
<h2 id="为什么要三次握手，两次握手行不行"><a href="#为什么要三次握手，两次握手行不行" class="headerlink" title="为什么要三次握手，两次握手行不行"></a>为什么要三次握手，两次握手行不行</h2><p>不行。<br><strong>第三次握手目的是为了防止已经失效的连接请求的报文段又传送到了服务端，比如发生了delay，由于现在主机没有发送新的连接请求，如果没有第三次握手，两次握手容易死锁。服务器就会一直等待主机发来数据，而很多资源就被浪费了。此外，TCP 需要 seq 序列号来做可靠重传或接收的依据，1) A –&gt; B  SYN my sequence number is X 2) A &lt;– B  ACK your sequence number is X 3) A &lt;– B  SYN my sequence number is Y 4) A –&gt; B  ACK your sequence number is Y 在计算机网络里通信里，对于一方的通信完成结果需要另一方的确认，所以对于服务器的序号seq需要一次客户机的确认。因此需要三次握手来约定确定双方的初始序列号</strong><br>此外，如果两次握手就可以完成连接，那么我攻击一个服务器就变得非常简单，只要不断发送大量的连接请求就好了，因为服务器两次握手就完成了连接建立，连接全开，那么就需要分配资源比如缓冲区和变量，那么很容易就耗尽服务器的资源。</p>
<h2 id="什么是四次挥手"><a href="#什么是四次挥手" class="headerlink" title="什么是四次挥手"></a>什么是四次挥手</h2><p>四次挥手是指运输层中TCP协议断开连接，释放资源的步骤。</p>
<ol>
<li><p>数据传输结束后，通信的双方都可以释放连接。此时，客户机和服务器都处于ESTABLISHED（已建立连接）状态。</p>
</li>
<li><p>假设客户机请求完资源了，想要释放连接。首先，客户机的应用进程先向服务器发出连接释放报文段，该报文段中将首部的终止控制位FIN置为１（只有当FIN置为１时，才能表明客户机想要和服务器断开连接），并且序号为ｕ（注意：此时的ｕ不是随机产生的，而是之前客户机传送的数据的最后一个字节的序号加１）。此时客户机进入到FIN_WAIT_１（终止等待１）状态，等待服务器的确认。</p>
</li>
<li><p>服务器收到连接释放报文后发出确认，在发送报文中将首部中的ACK置为１（ACK置为１，表面服务器同意与客户机释放连接），并且产生序号ｖ（注意：此时的v不是随机产生的，而是之前服务器传送的数据的最后一个字节的序号加１），并且发出确认号为u+１（确认号表明服务器渴望收到的下一个报文段的第一个数据字节的序号，因为之前发送了u，所以下一个序号为u+1）。此时服务器就进入CLOSE_WAIT（关闭等待）状态，客户机进入FIN_WAIT_2(终止等待2)状态。</p>
</li>
</ol>
<p>此时，从客户机到服务器这个方向的连接就被释放了，也就是说，客户机已经没有数据要向服务器发送了，但是如果服务器向客户机发送数据，客户机仍要接收数据。也就是说：从客户机到服务器的连接已经被释放了，但是从服务器到客户机的连接还没被释放。此时，TCP连接处于半关闭状态。</p>
<ol start="4">
<li><p>如果服务器向客户机也没有要发送的数据的话，那么服务器的应用进程就可以向客户机发出连接释放报文段，该报文段中将首部的终止控制位FIN置为1，ACK也置为1，并且序号为w（重点注意，此时的w不一定等于v+1。如果在客户机释放了连接之后，服务器向客户机仍旧发送了一部分数据，那么此时w不等于v+1，但是如果期间没有再发送数据，那么w就等于v+1。总而言之，这个w等于服务器上一次发送的数据的最后一个字节加1），并且发送确认号为u+1（确认号表明服务器渴望收到的下一个报文段的第一个数据字节的序号，因为之前发送了u，所以下一个序号为u+1）。此时服务器就进入了LAST_ACK（最后确认）状态。</p>
</li>
<li><p>客户机收到服务器的连接释放报文后，必须对此报文进行确认。在该报文段中将ACK置为1，序号为u+1，确认号为w+1（确认号表明服务器渴望收到的下一个报文段的第一个数据字节的序号，因为之前发送了w，所以下一个序号为w+1）。此时客户机进入到TIME_WAIT（等待时间）状态。但是，此时TCP连接还没有被释放掉。必须经过2MSL后客户机才能进入到CLOSED状态。（MSL:最长报文段寿命，RFC建议为两分钟，也就是说，要经过四分钟才能进入到CLOSED状态）。</p>
</li>
</ol>
<p><img src="2.png"></p>
<h2 id="什么是四次挥手中的2MSL-为什么要等2MSL"><a href="#什么是四次挥手中的2MSL-为什么要等2MSL" class="headerlink" title="什么是四次挥手中的2MSL 为什么要等2MSL"></a>什么是四次挥手中的2MSL 为什么要等2MSL</h2><p>MSL是Maximum Segment Lifetime英文的缩写，中文译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。RFC中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。<br>第一：为了保证客户机最后发送的那个ACK报文段能够到达服务器。这个ACK报文段可能会丢失。因而使处在LAST_ACK状态的服务器收不到对已发送的FIN＋ACK报文段的确认。客户机就能在2MSL时间内收到服务器重传的FIN+ACK报文段。接着客户机重传一次确认，重新启动2MSL计时器，直到最后客户机和服务器都可以进入到CLOSED（关闭）状态。如果没有2MSL等待时间，那么就无法收到重传的FIN+ ACK包，无法进入正常的CLOSED状态。<br>第二，防止“已失效的连接请求报文段”出现在本连接中。客户机在发送完最后一个ACK报文段，再经过时间2MSL，就可以使本连接持续的时间内所产生的报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</p>
<h2 id="为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手？</h2><p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。其实，在进行第二次握手时（即服务器向客户机进行应答时），可以看作时发了两次包，先回答客户机的服务请求（ACK＝１，接受确认序号X+1），然后再向客户机发出连接请求（SYN＝１，ｓｅｑ＝ｙ）</p>
<h2 id="TCP-IP五层模型"><a href="#TCP-IP五层模型" class="headerlink" title="TCP/IP五层模型"></a>TCP/IP五层模型</h2><p>应用层：  提供给客户端访问服务器网络服务的接口 。常用协议：HTTP、SMTP、FTP、ping、telnet、DNS、DHCP等</p>
<p>传输层：数据传输协议TCP 或 UDP</p>
<p>网络层 : 负责对数据包进行路由选择和存储转发，负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段和用户数据报封装成分组（IP数据报）或包进行传送。</p>
<p>IP协议:逐跳发送模式；根据数据包的目的地IP地址决定数据如何发送；如果数据包不能直接发送至目的地，IP协议负责寻找一个合适的下一跳路由器，并将数据包交付给该路由器转发</p>
<p>ICMP协议：因特网控制报文协议，用于检测网络连接</p>
<p>数据链路层： 负责分配MAC地址常用协议：地址解析协议（ARP）和反地址解析协议（RARP）,实现IP地址与机器物理地址（MAC地址）之间的转换两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻的链路上传送帧（frame)。每一帧包括数据和必要的控制信息。网卡接口的网络驱动程序，处理数据在物理媒介上的传输；不同的物理网络具有电气特性，网络驱动程序隐藏实现细节，为上层协议提供一致接口</p>
<p>物理层:所传数据单位是比特（bit)。物理层要考虑用多大的电压代表1 或 0 ，以及接受方如何识别发送方所发送的比特。</p>
<p>各网络层对应的工作设备：<br>物理层：中继器、集线器<br>数据链路层：网桥或交换机<br>网络层中继系统：路由器<br>网络层以上的中继系统：网关</p>
<h2 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h2><p>前端处理机：FEP  网卡就是前段处理器的化身  </p>
<h3 id="分组交换技术："><a href="#分组交换技术：" class="headerlink" title="分组交换技术："></a>分组交换技术：</h3><ol>
<li>存储转发技术 发送方到接收方，中间要经过多个节点的暂时存储，然后各根据接收方的地址，发送给下一个节点。</li>
<li>发送数据之前，要对数据分段处理，通常我们把要发送的整块数据叫一个报文，再把报文划分成更小的一个个数据段，在每段前面再加个首部，就构成了一个分组，分组也可以叫包，首部也可以叫包头，分组交换网的结构主要由主机host和节点交换机（node switch）组成。主机负责信息处理和其他主机通过网络交换信息。节点交换机主要是分组的存储和转发。     </li>
</ol>
<h3 id="分组交换技术的优点："><a href="#分组交换技术的优点：" class="headerlink" title="分组交换技术的优点："></a>分组交换技术的优点：</h3><p>优点：</p>
<ul>
<li>高效：逐段占用通信链路，动态分配传输宽带</li>
<li>灵活：智能节点能够独立处理数据分发</li>
<li>迅速：分组作为传输单位，无需建立连接</li>
<li>可靠：完善的网络协议<br>缺点：</li>
<li>传输时延：各节点进行存储转发的时候需要排队</li>
<li>首部数据存在开销 </li>
</ul>
<h3 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h3><p>范围分：</p>
<ul>
<li>广域网 几十-几千公里</li>
<li>局域网</li>
<li>城域网 5- 50公里<br>使用者：</li>
<li>公用网 通讯公司建造的网络</li>
<li>专用网 公司为了公司建设的内部网络（军队、电力）</li>
</ul>
<h3 id="网络体系工作流程："><a href="#网络体系工作流程：" class="headerlink" title="网络体系工作流程："></a>网络体系工作流程：</h3><ol>
<li>激活：使用信令确保发送的通路，保证数据在这条信道上可以正常的发送和接受。   </li>
<li>进行数据分析，识别接收方</li>
<li>发送方对接收方就绪检测</li>
<li>文件系统的格式转换</li>
<li>差错控制</li>
<li>其他</li>
</ol>
<h3 id="OSI七层模型失败的原因："><a href="#OSI七层模型失败的原因：" class="headerlink" title="OSI七层模型失败的原因："></a>OSI七层模型失败的原因：</h3><ol>
<li>糟糕的时机：推出的时机太晚了，已经有大量的应用开发实现了，厂商们担心新协议的接受程度，保守的延续旧协议。</li>
<li>糟糕的技术：无论是技术还是模型都有缺陷，其中的会话层和表示层基本是空的，链路层和数据层东西又太多。模型中协议非常复杂，实现起来非常困难。</li>
<li>糟糕的实现：OSI复杂而导致实现起来性能也差。</li>
<li>糟糕的策略：政府的产物，所以大家觉得是要把有缺陷的产物强加给开发人员。</li>
</ol>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>确定与传输媒体的接口特征：</p>
<ol>
<li>机械特征（接口形状 排列）</li>
<li>电气特征（承受电压范围）</li>
<li>功能特征（电压代表什么）</li>
<li>规程特征（工程实现各个事件出现的次序）</li>
</ol>
<p>局域网是基于广播技术发展起来的网络，广域网是基于交换技术发展出来的网络</p>
<p>网络体系结构可以定义为建立和使用通信硬件和软件的一套规则和规范</p>
<p>TCP/IP模型由低到高分别为网络接口层 、网络层、传输层、应用层。</p>
<p>按交换方式来分类，计算机网络可以分为电路交换，报文交换和分组交换三种</p>
<h3 id="信道："><a href="#信道：" class="headerlink" title="信道："></a>信道：</h3><p>向某一方向传输信息， 通信信道（发送信道、接收信道）。<br>单工通信（比如耳机）<br>双向通信（需要两个信道）<br>双向同时通信（电话）   </p>
<h3 id="信道容量："><a href="#信道容量：" class="headerlink" title="信道容量："></a>信道容量：</h3><p>单位时间内信道正确传输的比特数  bps（比特每秒）<br>香农定律 </p>
<h3 id="数据和信号的分类："><a href="#数据和信号的分类：" class="headerlink" title="数据和信号的分类："></a>数据和信号的分类：</h3><p>模拟数据用模拟信号发送 - 载波<br>数字数据用数字信号发送 - 编码<br>模拟数据用数字信号发送 - 采样<br>数字信号用模拟信号发送 - 调制</p>
<h3 id="传输媒体分类："><a href="#传输媒体分类：" class="headerlink" title="传输媒体分类："></a>传输媒体分类：</h3><p>导向传输媒体 铜线（同轴电缆，用于有线电视网） 光纤 双绞线（价格便宜性能不错，目前的电话线、网线）<br>非导向传输媒体  无线传输  </p>
<h3 id="光纤特点："><a href="#光纤特点：" class="headerlink" title="光纤特点："></a>光纤特点：</h3><ol>
<li>依靠光波承载信息，衰减少，传输距离远</li>
<li>抗雷电和电磁干扰性能好</li>
<li>无辐射，保密性好</li>
<li>体积小，重量轻</li>
<li>光线断裂的检测和修复都很难</li>
</ol>
<p>单芯光缆、多芯光缆</p>
<h3 id="光纤工作流程："><a href="#光纤工作流程：" class="headerlink" title="光纤工作流程："></a>光纤工作流程：</h3><p>计算机通过T型接头连接光纤，光信号通过接口的光接收机（光电二极管）变成电信号，通过铜线经过信号再生器接到计算机上。   </p>
<h3 id="短波通信："><a href="#短波通信：" class="headerlink" title="短波通信："></a>短波通信：</h3><p>利用电离层反射实现，但是电离层的不稳定产生的衰弱现象，和多径效应导致质量不好。 </p>
<h3 id="地面微波接力通信："><a href="#地面微波接力通信：" class="headerlink" title="地面微波接力通信："></a>地面微波接力通信：</h3><p>地球表面是曲面，所以多个每个基站直接通过微波传输信息，并接收到信息后放大作为中继继续向外传输。 </p>
<h3 id="卫星通信："><a href="#卫星通信：" class="headerlink" title="卫星通信："></a>卫星通信：</h3><p>利用近地轨道的卫星实现卫星通信。 和地面微波接力通信一样缺点是保密性较差，主要用于广播。</p>
<h3 id="DTE数据终端设备："><a href="#DTE数据终端设备：" class="headerlink" title="DTE数据终端设备："></a>DTE数据终端设备：</h3><p>具有一定信息处理能力，收发数据能力的设备，比如计算机</p>
<h3 id="DCE-数据电路端接设备："><a href="#DCE-数据电路端接设备：" class="headerlink" title="DCE 数据电路端接设备："></a>DCE 数据电路端接设备：</h3><p>在DTE和传输线中提供信号变换和编码功能，并负责建立、保持和释放数据链路连接 ，比如MODELM调制解调器。</p>
<h3 id="双绞线："><a href="#双绞线：" class="headerlink" title="双绞线："></a>双绞线：</h3><p>双绞线内有8根线，其中四根备用，一根作为接受高电平数据，一根发送高电平数据，一根接受低电平数据，一根发送低电平数据。网卡的接口要和双绞线相反。 因为这样的特性所以，网线分为直通线（两端都是586B），交叉线是一段568b一端568A，这样就可以连接两台计算机了。所以如果不是同类型的(DTE,DCE)用直通线，同类型用交叉线。</p>
<h3 id="信道复用技术："><a href="#信道复用技术：" class="headerlink" title="信道复用技术："></a>信道复用技术：</h3><ol>
<li>时分复用 ：时间划分为一个个时分复用帧，不同的时间占用同样的带宽资源</li>
<li>频分复用 ：将信号的带宽划分为各个小的频带，每个用户只用某个频带，不同时间占用不一样的带宽资源（光纤中发送不一样波长的光波进行通信叫波分复用，是光的频分复用）</li>
<li>码分复用 ：不同的编码。（CDMA：共享全部时间和带宽，经过计算后将其他站的信息过滤掉，利用内积运算过滤）</li>
<li>多分复用</li>
</ol>
<h2 id="数据链路层："><a href="#数据链路层：" class="headerlink" title="数据链路层："></a>数据链路层：</h2><h3 id="链路："><a href="#链路：" class="headerlink" title="链路："></a>链路：</h3><p>一条无源的、点到点的物理线段、中间没有其他点的交换节点    </p>
<h3 id="数据链路："><a href="#数据链路：" class="headerlink" title="数据链路："></a>数据链路：</h3><p>物理线路+链路控制规程形成的数据管道。数据链路上的通信规则就是数据链路的协议。  </p>
<h3 id="数据链路的三个基本功能"><a href="#数据链路的三个基本功能" class="headerlink" title="数据链路的三个基本功能"></a>数据链路的三个基本功能</h3><ol>
<li>封装成帧：就是在一段数据的前后分别添加首部和尾部。首部和尾部确认了帧的界限和一些控制信息。（MTU就是链路层协议规定 的最大传输帧的数据部分也就是从IP层传下来的IP数据包的最大长度）</li>
<li>透明传输：因为帧的首部和尾部确定了帧的长度，所以帧的数据段含有的首部和尾部字符的需要处理，比如在前面插入转义字符</li>
<li>差错控制：传输过程中可能会出现比特差错，0,1对调，为了保证传输可靠性，使用循环冗余校验CRC。</li>
</ol>
<h3 id="CRC："><a href="#CRC：" class="headerlink" title="CRC："></a>CRC：</h3><p>在发送端，先把数据划分为组。假设每组K个比特。将会与一个N+1位的除数P做除法，得到余数R，这个R就是附加在数据后面就是负责差错检验的冗余码。接收方将接收到的每一帧数据与除数P再次进行模2的除法运算，余数为0则判断这个帧没有差错，就接受。R！=0则将他丢弃。CRC只能检测是否出错，不知道出错的位置，而且也可能出现数据错误了但是余数也是0的漏检情况。所以CRC只能保证无差错接收，但这并不意味这可靠传输，因为除了差错的可能性还可能出现帧丢失、帧乱序的情况。因此必须要加上确认和重传机制才能保证可靠传输。</p>
<h3 id="帧检验序列FCS："><a href="#帧检验序列FCS：" class="headerlink" title="帧检验序列FCS："></a>帧检验序列FCS：</h3><p>在数据后面添加冗余码就叫帧检验序列。可以不是CRC算得的，可以识别的方法算的一个检验冗余码。  </p>
<h3 id="停止等待协议：（链路层）"><a href="#停止等待协议：（链路层）" class="headerlink" title="停止等待协议：（链路层）"></a>停止等待协议：（链路层）</h3><p>接收方收到数据方发送的数据后，将其提交给主机，并向发送方发送一个确认信息ACK(ACknowledge)，数据方才会发送下一帧信息；如果数据帧出错（CRC检验），则会向发送方发送一个否认帧 NAK 发送方会重传这一帧数据；如果数据帧丢失，发送方一直收不到消息，就会一直等待出现死锁，所以发送方每发送一帧就会启动一个超时计时器，如果在限定的时间内没有收到消息，就会自动重传这帧数据，这种被称为超时重传；如果应答帧出现丢失，那么也会出现超时重传，则接收端会面临重复帧的问题，为了解决重复帧的问题，我们给每个帧带上不同的序号，接收方接受到重复帧以后会丢弃这个数据，并再向发送方发送一个确认帧。</p>
<h3 id="ARQ-自动重传请求："><a href="#ARQ-自动重传请求：" class="headerlink" title="ARQ 自动重传请求："></a>ARQ 自动重传请求：</h3><p>这种自动重传请求是自动发生的。</p>
<h3 id="停止等待协议的优缺点："><a href="#停止等待协议的优缺点：" class="headerlink" title="停止等待协议的优缺点："></a>停止等待协议的优缺点：</h3><p>优点是简单，但是缺点是信道利用率太低了。</p>
<h3 id="连续ARQ协议："><a href="#连续ARQ协议：" class="headerlink" title="连续ARQ协议："></a>连续ARQ协议：</h3><p>为了处理停止等待协议的超低信道利用率，采用了流水线发送数据的方式，可以连续发送多个分组。就是发送数据后不用停下来等确认帧，一边发送一遍等待确认帧。由于连续发送数据帧，所以需要对数据帧连续编号，同时确认帧也需要编号。接收方收到出现差错后的后处理，可以选择向发送方发送否认帧，也可以不响应。接收端按序接受数据，而且必须连续，如果有一帧数据丢失，则后面的数据帧也会被接收端丢弃。而发送方等不到某帧数据的确认帧就会把该帧包括以后的每一帧都要重传一遍。（这种称为回退N GO-BACK-N）为了减少开销，接受方只对按序到达的最后一个分组发送确认， 采取累计确认的方式。在等待确认帧的时候，发送方也不能一直发送数据，因为发送数据越多，如果出错，则回退数据量也大，增加了重传开销，而且传送的数据越多，编号需要花更多的比特位来实现，也增加了开销。</p>
<h3 id="连续ARQ协议优缺点："><a href="#连续ARQ协议优缺点：" class="headerlink" title="连续ARQ协议优缺点："></a>连续ARQ协议优缺点：</h3><p>提高了信道利用率，但是回退的操作导致如果信道通信质量很差的时候效率可能还不如停等协议</p>
<h3 id="滑动窗口协议："><a href="#滑动窗口协议：" class="headerlink" title="滑动窗口协议："></a>滑动窗口协议：</h3><p>就是在发送方和接收方分别设置的可以移动的发送窗口，通过对序号的设置，可以对已经确认的帧的序号循环利用，同时加入一定的控制机制，避免二义性。也就是对连续ARQ协议里的连续发送的数据流量进行控制，只有在窗口的帧才可以被发送出去。当发送方收到了一个确认帧以后，发送方的滑动窗口就像右滑动一个，新加入窗口的数据就可以发送出去了。接收方的滑动窗口的作用是确认哪些帧可以接受，哪些帧不可以接收，接收方只有接受了处于滑动窗口内的帧时，才会收下这帧数据，否则一律丢弃，接收完会发送确认帧。在连续ARQ协议中接收方窗口宽度为1。</p>
<h3 id="选择重传ARQ协议："><a href="#选择重传ARQ协议：" class="headerlink" title="选择重传ARQ协议："></a>选择重传ARQ协议：</h3><p>增大接收端滑动窗口宽度，先接收下那些发送序号不连续但在窗口内的数据帧，等所有帧到达窗口后再一起提交。这样可以避免重传已经确认的帧，代价是需要在接收方设置相当容量的缓冲区。</p>
<p>原来因为信道质量低下的问题，普遍选择可靠传输协议，现在通信线路质量的提升，出现传输错误的几率降低。所以现在在链路层，使用最为普遍的是点对点协议PPP。</p>
<h3 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h3><ol>
<li>PPP协议很简单，因为设计网络层次的时候，把最复杂的部分放在了运输层</li>
<li></li>
<li></li>
<li></li>
<li>协议中，网络层的IP协议就非常简单，所以PPP设置非常简单。</li>
<li>封装成帧：PPP协议规定了特殊的字符作为帧定界字符，以便于接收方提取完整的数据帧。</li>
<li>透明性：转义符来实现帧定界出现在数据里。</li>
<li>多种网络层协议：要能在一条物理连路上，实现多挣网络协议的运行。</li>
<li>必须在多种类型链路中运行（穿/并 低/高速）</li>
<li>差错检测</li>
<li>随时自动检测链路连接状态</li>
<li>需要设置最大传送单元MTU</li>
<li>网络层地址协商</li>
<li>数据压缩的协商</li>
</ol>
<h3 id="PPP格式："><a href="#PPP格式：" class="headerlink" title="PPP格式："></a>PPP格式：</h3><p>首部4个字段，尾部两个字段，首部第一个和尾部最后一个都是标志字段，规定值是16进制的7E（2进制0b1111110）为帧的定界符。首部中的地址字段A为16进制的FF，控制字段设置为十六进制03，目前这两个数字没有什么意义。在后面是PPP协议字段，占两个字节。当协议字段为0x0021时，PPP帧的信息字段就是IP数据报。若为0XC021则信息字段是PPP链路控制数据，0X8021时，则表示这是网络控制数据。信息部分通常都是IP层传下来的IP数据报，这部分不超过1500字节。在后面就是真校验序列FCS，占两个字节。  </p>
<p><img src="1.png" alt="PPP格式"></p>
<h3 id="PPP透明传输问题："><a href="#PPP透明传输问题：" class="headerlink" title="PPP透明传输问题："></a>PPP透明传输问题：</h3><ol>
<li>PPP异步传输时，使用一种特殊的字符填充法。</li>
<li>PPP在同步传输链路时，协议规定采用硬件来完成零比特填充。（遇到5个1就自动填充一个0）</li>
</ol>
<h2 id="信道共享技术"><a href="#信道共享技术" class="headerlink" title="信道共享技术"></a>信道共享技术</h2><p>不同用户的信号在信道里叠加和碰撞</p>
<h3 id="信道共享（多点接入技术）的要求："><a href="#信道共享（多点接入技术）的要求：" class="headerlink" title="信道共享（多点接入技术）的要求："></a>信道共享（多点接入技术）的要求：</h3><ol>
<li>要求某一时刻 只有唯一信息有效传递</li>
<li>要求平等的对待用户</li>
</ol>
<ul>
<li>平等发送</li>
<li>平等接收</li>
<li>实时反映</li>
</ul>
<h3 id="受控接入："><a href="#受控接入：" class="headerlink" title="受控接入："></a>受控接入：</h3><p>分为集中式控制（轮询）和分散式控制（令牌环网）</p>
<h3 id="轮询："><a href="#轮询：" class="headerlink" title="轮询："></a>轮询：</h3><p>轮询方式下，网络中接入点分为主机和站两种类型。主机负责接入管理，逐个对站询问是否有信息要发送。站则参与数据传输。</p>
<h3 id="轮叫轮询："><a href="#轮叫轮询：" class="headerlink" title="轮叫轮询："></a>轮叫轮询：</h3><p>这种方式下，每个站只能收到主机发来的信息，也只能向主机发送信息。主机按照顺序从1站开始逐个询问各站是否有数据要发送。（如果1站没有信息要发，就发送一个控制帧给主机）</p>
<p>缺点：轮询帧在线路上轮番往返，增加了帧的等待时延。</p>
<h3 id="传递轮询："><a href="#传递轮询：" class="headerlink" title="传递轮询："></a>传递轮询：</h3><p>每个循环由主机向N站发送轮询帧，然后由N站向N-1站发送轮询帧，知道最后再由1站把发送权交会给主机，完成一个循环。传递轮询的帧时延总是小于同样条件下的轮叫轮询，而且站间距离越大，轮叫轮询的效果越好。</p>
<p>缺点：协议复杂，实现难度和成本高。</p>
<h3 id="令牌环网："><a href="#令牌环网：" class="headerlink" title="令牌环网："></a>令牌环网：</h3><p>这个网络的拓扑结构是一个环。<br>令牌其实是一个帧，在环路中流动。当有站有数据要发送时，必须先截获这个令牌。当发出的数据在环路中流动时经过目的站时，目的站复制这个帧，表示接受了数据，并将这个数据帧发转发给下一站，让他在环路上继续流动，发送站回收数据检查数据是否被成功接收。判断发送成功后，发送站会生成一个新的令牌，放回环路中继续流动。</p>
<h3 id="令牌环网的特点："><a href="#令牌环网的特点：" class="headerlink" title="令牌环网的特点："></a>令牌环网的特点：</h3><ol>
<li>公平原则，适合重载环境</li>
<li>每个站占用信道的等待时间有上限</li>
<li>闭合的环一点断多点瘫痪不易检查断点。</li>
</ol>
<h3 id="令牌总线网"><a href="#令牌总线网" class="headerlink" title="令牌总线网"></a>令牌总线网</h3><p>结构上是一个总线型的网络，但在逻辑上构成了一个环。</p>
<p>特点： 又有总线网络的介入方便和可靠性高的优点，也具有令牌环网不冲突，有时延上限的优点。协议复杂，所以推广应用比较差。</p>
<h2 id="信道共享技术之随机接入技术"><a href="#信道共享技术之随机接入技术" class="headerlink" title="信道共享技术之随机接入技术"></a>信道共享技术之随机接入技术</h2><h3 id="纯ALOHA"><a href="#纯ALOHA" class="headerlink" title="纯ALOHA"></a>纯ALOHA</h3><p>工作原理：想发就发，如果规定时间内收到接受方传来的应答，则表示发送成功，否则重发。<br>重发策略：若立即重发，则显然要再次冲突。等待随机一段时间，然后重发，如果再次冲突，则再等待一段时间。<br>特点：负载越重，冲突概率越大，性能越差。     </p>
<h3 id="时隙ALOHA："><a href="#时隙ALOHA：" class="headerlink" title="时隙ALOHA："></a>时隙ALOHA：</h3><p>把时间划分为一个个时隙长度刚好为发完一个帧的长度，帧无论什么时候产生，只能在每个时隙开始时发送到信道上。<br>特点：提高了一定信道的吞吐量，改善了性能。  </p>
<h3 id="CSMA：载波监听多点接入"><a href="#CSMA：载波监听多点接入" class="headerlink" title="CSMA：载波监听多点接入"></a>CSMA：载波监听多点接入</h3><p>每个站在发送数据之前，都会检测一下信道是否已被其他站点占用“先听后发”。<br>非坚持CSMA：一旦监听到信道忙，就不再监听；延迟一个随机时间后再次监听。<br>坚持CSMA：监听到信道忙时，仍然继续监听，直到信道空闲。1-坚持CSMA：一听到空闲就立即发送数据（以概率1发送）；2-坚持CSMA：听到信道空闲时，以概率P发送数据，即以概率1-p延迟一段时间后再发送。</p>
<h3 id="CSMA缺点："><a href="#CSMA缺点：" class="headerlink" title="CSMA缺点："></a>CSMA缺点：</h3><ol>
<li>传播时延</li>
<li>任然存在冲突可能</li>
<li>在冲突发生时，站不知道是出现冲突，这样发送数据的站将一直把数据发出，但这显然这些数据是错误的，因此这段时间是浪费的。</li>
</ol>
<h3 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h3><p>先听后发， 边发边听。一边发送一边监听，如果监听到冲突，则冲突双方都立即停止发送，（检测到冲突停止发送后会发一个人为干扰信号，强化冲突让所有人听到）信道很快空闲，从而提高效率。</p>
<h3 id="检测冲突的方法："><a href="#检测冲突的方法：" class="headerlink" title="检测冲突的方法："></a>检测冲突的方法：</h3><ol>
<li>比较接收到的信号电压大小，如果冲突，会大一倍</li>
<li>检测曼彻斯特编码过零点。</li>
<li>发送的同时也接受，就可以比较接收到的信号和发送的信号区别。</li>
</ol>
<h3 id="碰撞槽时间："><a href="#碰撞槽时间：" class="headerlink" title="碰撞槽时间："></a>碰撞槽时间：</h3><p><img src="2.png"><br>信道的最大冲突检测时间是2T （T为距离最远的两个站传输时延）<br>如果一个帧的发送时间小于碰撞槽时间的话，则冲突发生也无法检测到。所以我们对信道上的最小传输帧长也做了限制。   </p>
<h2 id="局域网技术"><a href="#局域网技术" class="headerlink" title="局域网技术"></a>局域网技术</h2><p>基于IEEE 802参考模型<br>将数据链路层分为两个自层，一个MAC（media access control）媒体访问控制,负责向下层提供媒体访问方法，一个LLC（Logical link control）逻辑链路控制，向上层提供连接环境。<br><img src="3.png"><br>物理层实现信号编码译码，同步码的产生和去除，比特的传输和接收。<br>MAC：成帧和拆帧  实现和维护MAC协议，比特差错检验（发现错误后交给LLC子层处理）和寻址。<br>LLC子层建立和释放逻辑电路，与高层的接口，差错控制和帧加减序号。局域网的传输介质访问细节对于LL子层是透明的。<br>高层数据+LLC首部 形成LLCPDU。然后交给MAC，MAC子层会把LLCPDU当做MAC数据部分加上首部和尾部封装成帧。</p>
<h3 id="局域网当中地址表示采用二进制，48bit的MAC地址。因为太长了，所以实际记录的时候转成6组16进制数来表示。（比如00-00-0C-01-23-45，有时候也可以用冒号来分割）他在记录地址信息的时候，需要保证全球唯一性。（全世界没有两个设备MAC地址是一样的）"><a href="#局域网当中地址表示采用二进制，48bit的MAC地址。因为太长了，所以实际记录的时候转成6组16进制数来表示。（比如00-00-0C-01-23-45，有时候也可以用冒号来分割）他在记录地址信息的时候，需要保证全球唯一性。（全世界没有两个设备MAC地址是一样的）" class="headerlink" title="局域网当中地址表示采用二进制，48bit的MAC地址。因为太长了，所以实际记录的时候转成6组16进制数来表示。（比如00.00.0C.01.23.45，有时候也可以用冒号来分割）他在记录地址信息的时候，需要保证全球唯一性。（全世界没有两个设备MAC地址是一样的）"></a>局域网当中地址表示采用二进制，48bit的MAC地址。因为太长了，所以实际记录的时候转成6组16进制数来表示。（比如00.00.0C.01.23.45，有时候也可以用冒号来分割）他在记录地址信息的时候，需要保证全球唯一性。（全世界没有两个设备MAC地址是一样的）</h3><p>生产网卡和网络接口的前24bit是制造商ID，后24位企业分配保证不重复<br><img src="5.png"></p>
<h3 id="以太网-Ethernet"><a href="#以太网-Ethernet" class="headerlink" title="以太网 Ethernet"></a>以太网 Ethernet</h3><p>以太网采用CSMA/CD，重载下性能差。我们使用的局域网也称为以太网（一般使用CSMA/CD都叫以太网）</p>
<p>10 BASE 5,10 BASE 2,10 BASE T,10 BASE F (A BASE B,A是带宽，比如10兆带宽，10Mbp s)</p>
<p><img src="6.png"></p>
<p>为了比特同步，所以实际传输的要比MAC帧还要多8个字节    </p>
<h3 id="标准以太网（10-BASE-5）"><a href="#标准以太网（10-BASE-5）" class="headerlink" title="标准以太网（10 BASE 5）"></a>标准以太网（10 BASE 5）</h3><p>传输媒体10mm铜轴粗缆，特性阻抗50欧姆，曼彻斯特编码，总线拓扑，10Mbps，单段最长500m。（信号衰减变形极限500米）当然可以通过中继器REPEATER来实现对信号的放大和整形，中继器是物理层上实现局域网互联的设备，负责连接各个电缆，从而延长500米。不过中继器也不是万能的，最多有5端500米的电缆通过4个中继器连接在一起，而且其中只能有三段电缆能够连接计算机，即543规则。</p>
<h3 id="细缆以太网（10-BASE-2）"><a href="#细缆以太网（10-BASE-2）" class="headerlink" title="细缆以太网（10 BASE 2）"></a>细缆以太网（10 BASE 2）</h3><p>传输媒体是细缆，阻抗特性500欧姆，曼彻斯特编码，总线拓扑，10Mbps，单段最长185m。 5X185 =925m 网络跨栏。</p>
<h3 id="10-base-T："><a href="#10-base-T：" class="headerlink" title="10 base T："></a>10 base T：</h3><p>使用双绞线 和星型拓扑接口 单段最长100m，使用HUB（集线器）来互联。主机用线缆连接（网线）带RJ-45连接器连接主机和HUB，一个HUB可以连多个主机，并可以用hub之间级联的方式来实现。但是也得遵守543规则，也就是级联中任意两个HUB的距离不能超过5个（包括这两个）</p>
<p>RJ-45连接器 水晶头~~</p>
<h3 id="HUB："><a href="#HUB：" class="headerlink" title="HUB："></a>HUB：</h3><p>HUB是一个多端口的转发器，对信号进行整形和放大，然后对所有端口转发出去。在以HUB为中心设备时，即使网络中某条线路产生了故障，并不影响其它线路的工作。所以HUB在局域网中得到了广泛的应用。集线器（HUB）属于数据通信系统中的基础设备，它和双绞线等传输介质一样，是一种不需任何软件支持或只需很少管理软件管理的硬件设备。它被广泛应用到各种场合。集线器工作在局域网(LAN)环境，应用于OSI参考模型第一层，因此又被称为物理层设备。集线器内部采用了电器互联，当维护LAN的环境是逻辑总线或环型结构时，完全可以用集线器建立一个物理上的星型或树型网络结构。在这方面，集线器所起的作用相当于多端口的中继器。其实，集线器实际上就是中继器的一种，其区别仅在于集线器能够提供更多的端口服务，所以集线器又叫多口中继器。</p>
<h3 id="快速以太网"><a href="#快速以太网" class="headerlink" title="快速以太网"></a>快速以太网</h3><p>100Mb/s CSMA/CD 传输介质5类UTP 双绞线就是  单段线路100m 使用HUB连接这些和10 BASE差不多 可以实现向下兼容。<br>不过百兆以太网，系统最多两个集线器，且两个集线器距离不大于5m。所以最大的距离是205米。</p>
<h3 id="100BASEFX"><a href="#100BASEFX" class="headerlink" title="100BASEFX"></a>100BASEFX</h3><p>光纤作为传输截止。CSMA/CD，使用一对光纤作为传输截止，因为光纤只能单向传输。</p>
<h3 id="局域网的拓展："><a href="#局域网的拓展：" class="headerlink" title="局域网的拓展："></a>局域网的拓展：</h3><h3 id="网桥："><a href="#网桥：" class="headerlink" title="网桥："></a>网桥：</h3><p><img src="8.png"><br>网桥内部有一个地址表MAC地址表，记录了端口和主机对应的关系。<br>网桥的作用就是</p>
<ol>
<li>过滤通信量，隔离冲突域，在不同冲突域内的主机，数据通信任然可以同时进行。</li>
<li>扩大物理范围</li>
<li>可以互联不同的物理层</li>
<li>提高了可靠性<br>缺点：</li>
<li>帧的处理导致更高的传输延迟</li>
<li>没有流量控制功能，可能产生溢出</li>
<li>只适合小规模局域网，大规模局域网可能会产生传播风暴   </li>
</ol>
<p>透明网桥的帧转发策略，是查看帧的地址，如果是相同网络的数据交换（同一个集线器连着的）就丢弃帧，不需要向别的端口传输该数据；不同网络的数据交换请求，则会接收帧转发它。帧的转发规则：网桥会查看内部MAC地址表，如果接受方在mac地址表内，则会按照表的指定端口转发帧。如果不在表内，用扩散flooding方式转发帧（就是往每个端口转发帧）。</p>
<p>网桥是比较早期的扩展局域网的手段，目前是采用局域网交换机来实现拓展。局域网交换机与网桥的关系比较类似于HUB与中继器。</p>
<h3 id="局域网交换机"><a href="#局域网交换机" class="headerlink" title="局域网交换机"></a>局域网交换机</h3><p><img src="9.png"></p>
<ul>
<li>各端口平时都不连通</li>
<li>当接入交换机的设备之间需要通信时，交换器能够同时连通许多对端口</li>
<li>每一对相互通信的设备都能像独占通信介质那样进行无冲突的数据传输</li>
<li>在双方通信完成，将断开连接</li>
</ul>
<p>局域网交换机的策略是</p>
<ol>
<li>STORE&amp;forword，完全缓存后，再根据字段里的地址判断是否需要转发。可以进行CRC校验。缓存所花的的延时较长。</li>
<li>Cut through 仅仅缓存前6个字节的MAC地址，转发所花费的时延就降低了，但是无法进行CRC校验，可能转发报文碎片。</li>
<li>fragment free 缓存前64字节的数据，这样减少报文碎片出现的概率。在局域网中，小于64字节的数据一定是报文碎片。 </li>
</ol>
<h3 id="1000BASECX"><a href="#1000BASECX" class="headerlink" title="1000BASECX"></a>1000BASECX</h3><p>短距离屏蔽铜缆，最长距离25米。<br>1000baselx 光纤，长波激光光源LWL，1000basesx 光纤 短波SWL。<br>1000baseT 双绞线</p>
<p>千兆以太网需要帧拓展，将帧拓展成512字节（如果帧不足512字节的话），但是如果发送一堆短帧，都填充扩展，实际上降低了数据传输效率，所以，帧开发技术，就是第一个短帧扩充后成功发送后，后续短帧们以一定帧间隙组成组发送，这就是帧突发。  </p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="互联网："><a href="#互联网：" class="headerlink" title="互联网："></a>互联网：</h3><p>Internet和 internet 。Internet是全球最大的，开放的，有众多网络相互连接而成的特定的计算机网络，采用TCP/IP协议，前身为ARPANTET<br>internet泛指多个网络互联形成的网络<br><img src="10.png"></p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>ip地址是ip协议的地址 网络层提供两种服务，可靠的面向连接的服务，一种是不可靠的无连接服务。ip是不可靠的无连接服务。  </p>
<p>IP 的核心思想是：尽力传递的设计思想，因为IP无法保证数据传输正确、成功和顺序。</p>
<h3 id="面向连接"><a href="#面向连接" class="headerlink" title="面向连接"></a>面向连接</h3><p>就是通信开始前，需要建立连接，通信过程中需要维护连接，通行结束后需要释放连接。（比如打电话）</p>
<h3 id="无连接："><a href="#无连接：" class="headerlink" title="无连接："></a>无连接：</h3><p>无需维护和断开连接（发送短信） 但是这种方式无法保证传输的可靠性，可能出现数据丢失，但是IP不管这些，把纠错重传交给传输层解决。快速、简单、效率高。</p>
<h3 id="IP层主要协议"><a href="#IP层主要协议" class="headerlink" title="IP层主要协议"></a>IP层主要协议</h3><p>IP协议和几个偏辅助的协议两个偏上层的 ICMP , IGMP<br>和两个偏下层的 ARP。RARP 协议。     </p>
<h3 id="IP地址-1"><a href="#IP地址-1" class="headerlink" title="IP地址"></a>IP地址</h3><p>32位2进制，4个点分的十进制数来表示 （202.118.110.196）<br>所以每个点分的十进制数 对应一个8位2进制数，所以0-255之前。<br>IP地址可以分为网络号和主机号<br>因为IP寻址的时候是先根据网络号寻找网络，在根据主机号寻找主机。</p>
<h3 id="IP地址的分类："><a href="#IP地址的分类：" class="headerlink" title="IP地址的分类："></a>IP地址的分类：</h3><p>IP地址一般分为A\B\C\D\E类5类，主要常用的是A\B\C类<br>A类前8个为网络号，后24位 主机号，A类第一比特位0。 1.0.0.0 - –127.255.255.255<br>B类前16位为网络号，后16位为主机号，B类前两位比特位10 128.0.0.0 —191.255.255.255<br>C类前24位为网络号，后8位为主机号，C类前三位比特位为110  192.0.0.0 — 223.255.255.255<br>D类1110开头 224.0.0.0 — 239.255.255.255<br>E类11110开头 240.0.0.0—- 247.255.255.255 </p>
<h3 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h3><p>IP32位全0表示自己this host，全1表示所有，表示广播（本网络内的广播）<br>网络号为全0接主机号则表示this network里的一个主机号<br>主机号为全0表示这个网络的网络号。<br>主机号全为1表示某网络的广播地址。<br>这些特殊含义的地址是不可以分配给主机的。<br>127开头的+anything， loopback address 表示本机<br>三个IP地址都指向本机，0.0.0.0，127.0.0.1 还有就是主机的地址。0.0.0.0是不能参与通信的，127.0.0.1是可以发数据的，但是不会经过物理层和链路层的封装，直接进入IP层的转发直接发给接收模块。<br>所以一个网络最多容纳2**n - 2台主机。</p>
<h3 id="子网掩码："><a href="#子网掩码：" class="headerlink" title="子网掩码："></a>子网掩码：</h3><p>比如C类的子网掩码 255.255.255.0<br>子网掩码和IP做与操作，就可以得到IP地址对应的网络号。子网掩码是由连续的若干个二进制“1”组成的代码<br>确定网络ID和主机ID的方法：子网掩码 AND IP地址 = 网络地址(ID)<br>子网掩码是主机判断目的IP地址是否与主机出在同一个网络的唯一依据。主机在发送数据之前，需要用目的IP地址与子网掩码进行与运算。再把本机的IP地址与子网掩码与运算然后看看是否相同，结果相同则意味着数据传输在本网络进行。如果不同则意味着要把数据发送到所在网络的出口，发送到其他网络中去。</p>
<h2 id="ARP协议：Address-resolution-Protocol"><a href="#ARP协议：Address-resolution-Protocol" class="headerlink" title="ARP协议：Address resolution Protocol"></a>ARP协议：Address resolution Protocol</h2><p>地址解析协议 MAC地址和IP地址之间的转换协议。数据链路层有自己的MAC地址，TCP/IP有自己的IP地址。（IP地址相当于一个人的人名，MAC地址相当于这个人本身）<br>ARP协议的基本原理： 发送方会向该网络里发送一个ARP请求的广播（相当于叫这个人的名字），然后对应接收主机会发送一个ARP应答。以后再和这个接收方通信就不需要再次广播了，而是有记忆的。以后可以直接发送数据。</p>
<p>局域网中要尽量避免广播和广播通信。</p>
<p>ARP协议的改进，上来就给每个主机分配了一个ARP Cache，相当于MAC地址和IP地址的映射表。当发送方主机发送广播的时候，也会顺带把自己的MAC与IP地址发送出去，接收方会接受了并存在自己的ARP CACHE里。应答ARP以后也会捎带发送自己的IP和MAC地址。  </p>
<p><img src="11.png"></p>
<h3 id="ARP协议漏洞："><a href="#ARP协议漏洞：" class="headerlink" title="ARP协议漏洞："></a>ARP协议漏洞：</h3><p>ARP协议默认相信发送来的MAC和IP地址真实有效。这样就产生了一个协议漏洞，可以利用欺骗ARP协议入侵方式。</p>
<p>ARP协议漏洞的根本是ARP协议支持MAC IP之间动态地址映射。所以一种解决办法是使用静态地址映射。</p>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>IP数据报datagram 是IP协议的PDU，是Internet上数据传输的最基本单元。路由器在不同网络将转发IP分组，实现IP数据报的寻路功能。</p>
<p><img src="12.png"></p>
<p>Version:版本号 目前是IPV4和IPV6两种。<br>首部长度：要把首部字节数/4字节数 得到的数记录在这里，单位是4字节<br>TOS:服务类型，选取这个数据报服务的优先级。对应DTRC比特位，D比特位表示低时延，T表示高吞吐率 R表示高可靠性  C比特被置1表示低费用。这四个比特不可能同时被置为1。只能将其中一个置为1.<br>Total Length：总长度，以字节为单位<br>TTL：初始值为255，当减为0是被路由丢弃。<br>协议：指高层的协议类型<br>checksum：首部检验和<br>一般IP协议头部长度20字节       </p>
<h3 id="IP报文的分片："><a href="#IP报文的分片：" class="headerlink" title="IP报文的分片："></a>IP报文的分片：</h3><p>IP数据报被帧封装，所以受限于帧的长度，帧的最大传输单元是MTU，只局域网中最长的帧，这里限制了封装的IP报文的长度<br>当传输数据报的MTU大于传输过程中比如路由器将最大MTU的限制，也就是较大报文经过MTU小的局域网前，这时候就需要对报文进行分片。<br>路由器会把IP数据报数据部分成若干份，并在前面加上分片的首部，来记录这个分片在原始IP数据报当中的位置等相关信息。<br>接收方主机需要有一个缓冲区，然后缓冲区接收完分片后重组成原来的IP数据报。这样就需要在报文的开头一个区域记录分片的位置，也就是记录分片的偏移量。第一个分片的offset 为0，后一个的偏移量就是前一个长度。<br>标识（重组时同一数据报的标识相同）、标志（就是后面还有没有分片了）、偏移量（就是在原来数据报里的偏移量位置，偏移量单位是 8字节 所以要偏移字节除以8 = offset）</p>
<h2 id="IP路由器："><a href="#IP路由器：" class="headerlink" title="IP路由器："></a>IP路由器：</h2><p>网络中有很多路由器负责分发，组成一个分发网，数据从发送方到接收方，选择一条IP路由就像是寻路。 </p>
<p>路由系统要解决的问题：</p>
<ol>
<li>如何依据路标寻路</li>
<li>如何维护路标</li>
</ol>
<p>路由器转发数据的时候以路由表为依据。</p>
<h3 id="IP路由的寻址："><a href="#IP路由的寻址：" class="headerlink" title="IP路由的寻址："></a>IP路由的寻址：</h3><ol>
<li>直接寻址（源与宿在相同网络）物理网络内部确定主机 –主机的数据传输路径    </li>
<li>间接寻址：经过路由器的转发就叫间接寻址 </li>
</ol>
<p>下一站转发的网络地址就是网关。这个设备在网络上的默认出口。</p>
<h3 id="网关："><a href="#网关：" class="headerlink" title="网关："></a>网关：</h3><p>网关就是一个网络通向另一个网络的出口。<br>网关(Gateway)网间连接器、协议转换器。</p>
<h3 id="默认路由："><a href="#默认路由：" class="headerlink" title="默认路由："></a>默认路由：</h3><p>路由器在转发过程中，会挨个子网掩码与操作和目的网络得到的网络地址和目的IP地址的网络地址比较，如果都不相同，最后会有一条全0.0.0.0的目的网络，就完成了往默认路由方向转发的过程。 </p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><ol>
<li>因为主机一般有多个进程在使用网络通信，所以只是把数据报交付给主机还没完成全部工作。</li>
<li>IP提供两种服务一种可靠的蓄电路服务，一种不可靠的数据报服务，和不可靠的数据报服务。<br>总结来说 <strong>传输层作用</strong>：进程寻址和网络层上的服务保证</li>
</ol>
<h3 id="传输层作用："><a href="#传输层作用：" class="headerlink" title="传输层作用："></a>传输层作用：</h3><ul>
<li>为应用进程提供端到端的服务</li>
<li>增强网络层提供的服务质量QoS</li>
</ul>
<h3 id="传输实体"><a href="#传输实体" class="headerlink" title="传输实体"></a>传输实体</h3><p>传输实体之间传输，传输协议称为TPDU 。传输实体就是收/发两端的传输层实现对等实体通信的硬件或软件。利用网络层提供点到点的分组传输服务，向高层提供端到端的TPDU（传输协议数据单元）传输服务。</p>
<h3 id="点到点、端到端"><a href="#点到点、端到端" class="headerlink" title="点到点、端到端"></a>点到点、端到端</h3><p>主机A TO 主机B 就是端到端，点到点是A to 路由器R1，点到点是 R1 TO 路由器R2，这些是点到点的。链路层保证的是点到点的可靠性。</p>
<h3 id="TCP协议-Transmission-Control-Protocol"><a href="#TCP协议-Transmission-Control-Protocol" class="headerlink" title="TCP协议 Transmission Control Protocol"></a>TCP协议 Transmission Control Protocol</h3><p>为应用进程提供可靠的、端到端的、面向连接的字节流通性，解决分组的重传和排序问题。利用网络层的IP协议提供的不可靠的分组传输服务，解决分组的重传和排序问题。<br>面向连接意味着，传输数据之前需要确定接收方的存在，并与接收方协议缓冲区大小，和序号起始值。<br>TCP连接是全双工的，支持同时双向传输<br>Unicast 只支持两端点之间的通信，不支持多播和广播Multicast和Broadcast。<br>面向字节流。     </p>
<p>TCP协议的传输实体 软件实现，用户进程，操作系统核心的一部分， 管理TCP字节流实现与IP层的接口。</p>
<p>在主机中，有多个进程，会给进程编号，就叫PORT端口。TCP协议用16比特来给端口编号。   </p>
<pre><code>clientSocket.connect((serverName, serverPort))
</code></pre>
<p><strong>固定端口号</strong>：全局分配<br>优点是知道与当前应用通信的端口号；缺点就是没有在国际组织注册的进程没有端口号，新的进程的端口号获得就变得非常复杂了。固定端口号小于1024的已经全部被分光了。     </p>
<p><strong>临时端口</strong>：<br>主机建立连接时为用户进程动态的分配端口（大于等于1024的端口号）    </p>
<p>对于标准服务进程，为他分配固定端口号，对于临时启动的user应用，临时分配端口号。</p>
<h3 id="Socket通信（套接口）："><a href="#Socket通信（套接口）：" class="headerlink" title="Socket通信（套接口）："></a>Socket通信（套接口）：</h3><p>一个进程有一个或多个套接字，套接字是网络和应用程序之间数据传递的门户。<br>接受主机的运输层是吧数据报中的数据缴费给正确的套接字，这个过程就叫做多路分解。主机上每个套接字有一个端口，传输层检查报头的目的端口号，找到对应port端口，并将应用层数据报定向给对应的套接字。     当我们开发一个新的应用程序的时候，必须分配一个端口号。<br>两步走，第一步先根据IP地址找到响应主机，然后再通过找到对应的端口号，找到通信对手方的应用。是由UNIX系统提出来的，用套接口来标识用户进程通信的端点。</p>
<p><img src="13.png"></p>
<p>端口号是传输层的进程的寻址依据。</p>
<p>应用层–TCP加TCP头部形成TCP报文–再加IP头部 形成分组 — 再被链路层封装成帧<br><img src="14.png"><br>源端口号码和目的端口号 各15位。偏移单位是4字节，存储的是TCP首部长度/4的值<br>标志  URG紧急指针域 CK确认域有效即确认号有效  psh字段为1则不比缓冲区满即可上传  RST 复位用于崩溃或错误连接  SYN用于建立连接时使用的同步序号   FIN表示发送方到大数据结尾 请求断开连接</p>
<h3 id="TCP的差错控制："><a href="#TCP的差错控制：" class="headerlink" title="TCP的差错控制："></a>TCP的差错控制：</h3><p>是一种回退N GBN和选择重传SR协议的混合体，TCP接收方有选择的确认失序报文，而不是累计的确认最后一个正确接收的有序报文段。当该机制与选择重传机制结合起来的时候，也就是跳过重传哪些已经被接收方选择性确认过的报文段。 </p>
<h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>使用选择重传ARQ 选择滑动窗口。TCP协议是面向字节流的，所以他的序列号是上一个序列号加上上一个报文中有多少字节数。 TCP头部里的窗口是接收方向发送方发送的用于控制发送方发送的报文段的尺寸的。防止接收端缓冲溢出。</p>
<h3 id="传输层的UDP协议"><a href="#传输层的UDP协议" class="headerlink" title="传输层的UDP协议"></a>传输层的UDP协议</h3><p>用户数据报服务。无连接的数据报服务协议，也就是在与通信方没有建立连接的的情况下发送出去，并且也不提供序号服务和流量控制功能。</p>
<p>使用场合： 实时数据传输，节省了建立/释放连接和重传的开销。 有应用层自己解决和纠错问题。   </p>
<p>流程：发送端：分配源端口、指定宿端口，构造UDP数据报，交个IP<br>    接收端： 匹配UDP头部宿端口的硬应用程序，匹配成功后，数据报排入相应的队列，若端口队列满<br>    了，则丢弃数据报。匹配不成功 就丢弃数据报，回送“宿端口不可达”的ICMP报文<br>UDP头部：<br><img src="15.png"></p>
<p>传输层在不保证可靠性的情况下可以考虑使用UDP 因为其简单高效容易实现。</p>
<h2 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h2><h3 id="EMAIL工作模型："><a href="#EMAIL工作模型：" class="headerlink" title="EMAIL工作模型："></a>EMAIL工作模型：</h3><p>Email由源主机向原邮件服务器发送，再向目的邮件服务器，再向目的主机发送。</p>
<p><img src="16.png"></p>
<p>Email 由两部分组成 header+body 刚开始发送Email有诸多限制，之后，出台了MIME，修订了原来的很多限制和要求，使得可以发送非标准ACSII和对邮件长度不限制，还可以传输图片 声音等一些文件。<br><img src="17.png"></p>
<h3 id="SMTP-简单邮件协议："><a href="#SMTP-简单邮件协议：" class="headerlink" title="SMTP 简单邮件协议："></a>SMTP 简单邮件协议：</h3><p>server服务器在25号端口上监听，有连接请求时，接受连接，然后传输邮件，传输完毕后再将连接断开。这是个纯ASCII字符的协议。<br>个人计算机没有固定域名和IP地址，因此不可以做为SMTP的服务器。</p>
<h3 id="POP3协议（一个邮件代理协议）："><a href="#POP3协议（一个邮件代理协议）：" class="headerlink" title="POP3协议（一个邮件代理协议）："></a>POP3协议（一个邮件代理协议）：</h3><p>server服务器监听110号端口上监听，有连接请求时，接受并与之建立，TCP连接，然后用户就需要提供用户名 密码和需要取出的邮件序号，然后serve会把这个邮件按照用户名提供的地址找到，然后传输邮件，传输完毕后再将连接断开。这个就是用户取邮件的时候的一个简单邮件协议。因为取邮件的时候无法使用SMTP协议。</p>
<h3 id="文件传输协议FTP协议：FILE-Transform"><a href="#文件传输协议FTP协议：FILE-Transform" class="headerlink" title="文件传输协议FTP协议：FILE Transform"></a>文件传输协议FTP协议：FILE Transform</h3><p>一个实例： QQ的离线文件传输<br>用户接口–发送需求和命令—-用户协议的解析器解析用户的指令和需求—与文件服务器建立连接====文件服务器的21号端口（这个端口用于命令的传输）—-在本地系统找到该文件 —然后20号端口用于数据的传输–</p>
<h3 id="WWW应用"><a href="#WWW应用" class="headerlink" title="WWW应用"></a>WWW应用</h3><p>超文本标记语言(HTML)把信息组织成为图文并茂的超文本<br>超链接，起于1989年。在Internet上，标识唯一的主机我们用IP地址，标识唯一的进程我们使用端口号POrt号，二者结合就可以标识唯一的在Internet上的一个进程     </p>
<p>异构计算机上展示的内容是相同的，这是通过运行同一种解析器，使得能够运行解析器的解析出来的文档风格是相同的。  </p>
<p>当代高性能服Web服务器，通常只是用一个进程，但是为了每个新的客户连接创造一个具有新连接套接字的新线程，对于一台这样的服务器，他可能同时拥有多个连接套接字连接到相同的进程。</p>
<h3 id="标识WWW网页："><a href="#标识WWW网页：" class="headerlink" title="标识WWW网页："></a>标识WWW网页：</h3><p>URL uniform resource locator 是对能从Internet上得到的资源的位置和访问方法的一种简洁表示。    </p>
<pre><code>格式是   &lt;访问方式&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt; 
</code></pre>
<p>WWW 服务器server 会打开80端口，与客户机实现TCP连接，客户机将自己要访问的WWW地址发给服务器，这个服务器会在自己的HTML文档中找到对应文档，然后返回给客户端。</p>
<p>我们平时用HTML方式下的 http://主机（www..com）  平时浏览器会自动设置默认端口80 所以端口后面不用写了，如果有些服务器不是打开这个端口的，比如8080端口 就可以写 ：8080</p>
<h3 id="HTML语言"><a href="#HTML语言" class="headerlink" title="HTML语言"></a>HTML语言</h3><p>超文本的标记语言  是一种标记语言，HTML文档使用标签Tag + body组成<br>采用HTML语言，可以让异构的计算机客户端，使用解析和解释器就能得到相同风格的网页文本</p>
<h3 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h3><p>超文本传输协议  用户和服务器之间传输文档的时候用HTTP协议，也是一个纯文本协议。基于TCP连接。<br>由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。     </p>
<p>HTTP使用TCP而不是UDP的原因在于（打开）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。</p>
<h2 id="DNS-域名系统"><a href="#DNS-域名系统" class="headerlink" title="DNS 域名系统"></a>DNS 域名系统</h2><p>Internet上每台主机的标识是他的唯一的IP地址。但是我们不一定都知道主机地址，因为在Internet上有一个将主机名和IP地址互相转换的应用层协议 DNS协议。 DNS的作用就是将主机名字转换为二进制IP地址。</p>
<p>Internet里的域名系统被设计成一个联机分布数据库系统，DNS采用客户服务器模式。客户提出请求，服务器返回对应的IP地址。DNS服务器由若干个域名服务器组成，大多数域名的转换都是在本地映射，少数域名在Internet上网上通信映射。</p>
<h3 id="Internet的域名结构"><a href="#Internet的域名结构" class="headerlink" title="Internet的域名结构"></a>Internet的域名结构</h3><p>域名结构 采用层次树状结构的命名方法<br>域名的结构由若干个分量组成，各分量之间用点隔开<br>每一级域名由英文字母和数字组成  不分大小写 《63个字符   最低级的域名在最左边  最顶级在右边</p>
<p>顶级域名分为：国际顶级域名 （国际组织） 国家顶级域名 CN  US  ton共顶级域名  </p>
<p>绝对域名就是一直写到顶级域名    </p>
<h3 id="DNS服务查询流程"><a href="#DNS服务查询流程" class="headerlink" title="DNS服务查询流程"></a>DNS服务查询流程</h3><p>客户机发出某查询域名IP地址请求，本地DNS服务器如果查不到就会询问上一级服务器，然后上一级服务器找到对应的DNS服务器，把这个地址返回给本地的DNS服务器，本地的DNS服务器会去向这个DNS服务器发送IP地址查询请求。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://andrekuu.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/" data-id="cknrvilr00007dgvefsxe2fn4" data-title="计算机网络细节" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/04/22/Mysql%E5%9F%BA%E7%A1%80/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Mysql基础
        
      </div>
    </a>
  
  
    <a href="/2021/04/22/LeetCode-%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">LeetCode 周赛总结</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/22/Mysql%E5%9F%BA%E7%A1%80/">Mysql基础</a>
          </li>
        
          <li>
            <a href="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/">计算机网络细节</a>
          </li>
        
          <li>
            <a href="/2021/04/22/LeetCode-%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/">LeetCode 周赛总结</a>
          </li>
        
          <li>
            <a href="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
          </li>
        
          <li>
            <a href="/2021/04/22/%E7%AE%97%E6%B3%95%E7%BB%8F%E9%AA%8C/">算法经验</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 AndreKuu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>