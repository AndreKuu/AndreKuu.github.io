<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>AndreKuu</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="AndreKuu">
<meta property="og:url" content="https://andrekuu.github.io/index.html">
<meta property="og:site_name" content="AndreKuu">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="AndreKuu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="AndreKuu" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">AndreKuu</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://AndreKuu.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Linux" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/22/Linux/" class="article-date">
  <time class="dt-published" datetime="2021-04-22T03:48:53.000Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/22/Linux/">Linux</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="linux-后端大门"><a href="#linux-后端大门" class="headerlink" title="linux 后端大门"></a>linux 后端大门</h1><h2 id="部署虚拟环境和安装Linux"><a href="#部署虚拟环境和安装Linux" class="headerlink" title="部署虚拟环境和安装Linux"></a>部署虚拟环境和安装Linux</h2><h3 id="安装VM虚拟机"><a href="#安装VM虚拟机" class="headerlink" title="安装VM虚拟机"></a>安装VM虚拟机</h3><p>VMware WorkStation 我在安装过程中遇到过点击安装包就秒退的情况，这可能和版本有关系，反正官网上我下了几个都不好使，最后在baidu网盘上找了个靠谱的最终实现了下载安装。<br>记得选择增强型键盘驱动程序。安装完虚拟机，不能立即安装linux系统，还需要先对虚拟机内设置操作系统的硬件标准。下载好系统的光盘映像，创建新的虚拟机，最大磁盘可以设置默认的20GB，内存1GB,2GB都可，安装RHEL 7，设置root管理员密码一定要尽量复杂，否则对于系统来说面临很大的安全隐患。  </p>
<h3 id="重置root管理员密码"><a href="#重置root管理员密码" class="headerlink" title="重置root管理员密码"></a>重置root管理员密码</h3><pre><code>ctrl + alt   # 返回自己的计算机
</code></pre>
<p>重启系统，在进入界面中，按e进入内核编辑模式，在UTF-8后面 加上</p>
<pre><code>rd.break
</code></pre>
<p>ctrl + X组合键运行修改后的内核程序<br>30s后进入经济求援模式，输入以下命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mount -o remount,rw &#x2F;sysroot</span><br><span class="line">chroot &#x2F;sysroot</span><br><span class="line">passwd</span><br><span class="line">&#x2F;&#x2F;这里输入新密码 但是注意要不低于8位否则 被遮住了你也不知道</span><br><span class="line">&#x2F;&#x2F;再输入一遍新密码</span><br><span class="line">touch &#x2F;.autorelabel</span><br><span class="line">exit</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h3 id="RPM红帽软件包管理器"><a href="#RPM红帽软件包管理器" class="headerlink" title="RPM红帽软件包管理器"></a>RPM红帽软件包管理器</h3><p>Linux系统中安装文件原来只能采取源码包的方式安装，早期安装程序非常困难，而且大多数的服务程序仅仅提供源代码，需要运维人员自行编译代码并解决很多软件依赖关系。<br>RPM有点像windows里的控制面板，建立了一个统一的数据库文件，详细的记录软件信息，并能够自动分析依赖关系。RPM已经被广泛接受在众多linux系统采用。</p>
<h3 id="Yum软件仓库"><a href="#Yum软件仓库" class="headerlink" title="Yum软件仓库"></a>Yum软件仓库</h3><p>RPM可以帮助用户查询软件相关的依赖关系，Yum软件仓库进一步降低软件安装的难度和复杂度，可以根据用户的要求分析出所需要的软件包以及相关的依赖关系，然后自动从服务器下载软件包并安装到系统。</p>
<h3 id="Linux初始化进程"><a href="#Linux初始化进程" class="headerlink" title="Linux初始化进程"></a>Linux初始化进程</h3><p>Linux操作系统的开机的过程：</p>
<ol>
<li>从BIOS开始进入Boot loader，在加载系统内核，然后内核进行初始化</li>
<li>最终启动初始化进程。<br>初始化进程作为Linux系统的第一个进程，他需要完成Linux系统中相关的初始化工作，为用户提供合适的工作环境。RHEL 7 已经采用sysstemd初始化进程服务。systemd初始化进程服务采用了并发启动机制，开机速度得到小的提升，虽然systemd初始化进程服务有很多特性，但还是有缺点：</li>
<li>systemd初始化进程服务仅可在Linux系统下进行，抛弃了UNIX系统用户。</li>
<li>systemd接管了很多其他服务比如cgroup等</li>
</ol>
<p>RHEL 7系统是使用systemctl命令来管理服务的。比如查询某个服务的运行状态，可以用</p>
<pre><code>systemctl status 服务名.service
</code></pre>
<p>查看服务的运行状态 其中.service可以省略</p>
<h2 id="必须掌握的Linux命令"><a href="#必须掌握的Linux命令" class="headerlink" title="必须掌握的Linux命令"></a>必须掌握的Linux命令</h2><p>让系统各种硬件设备各司其职又能协同运行的就是系统内核。<br>Linux系统的内核完成 硬件资源的分配、调度等管理任务。</p>
<h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><p>Linux系统中有些图形化工具  比如逻辑卷管理器LVM 确实很好用，极大的降低了运维惹人员操作出错的概率。但是图形化工具其实是调用了脚本来完成相应的工作，往往只是为了完成某种工作而设计的，缺乏Linux命令原有的灵活性和可控性。而且图形化工具相较于Linux命令行界面会更加消耗系统资源。<br>shell 就是这样的一个命令行工具。shell成为终端或者壳，充当的是人和内核、硬件之间的翻译官。用户把命令输入键入shell，他就回去调用相应的程序服务去完成某些工作。现在红帽系统在内的主流Linux系统磨人的是使用终端Bash解释器。<br>Bash有四个特点：</p>
<ol>
<li>通过按上下方向键调用过去执行过的Linux命令。</li>
<li>命令或参数只是需要输入前几位就行了，后面用Tab补齐。</li>
<li>具有强大的批处理脚本。</li>
<li>具有使用环境变量功能。</li>
</ol>
<h3 id="常见的Linux执行格式是："><a href="#常见的Linux执行格式是：" class="headerlink" title="常见的Linux执行格式是："></a>常见的Linux执行格式是：</h3><pre><code>命令名称 [命令参数] [命令对象]
</code></pre>
<p>注意空格分开<br>命令对象一般是指要处理的文件、目录、用户等资源。<br>命令参数可以用长格式（完整选项名称），也可以用短格式（单个字母的缩写），两者分别用 – 与 - 作为前缀。<br>参数值需要根据不同的命令和需求情况而发生改变。  </p>
<pre><code>man --help
man -h
</code></pre>
<p>单机not listed切换至root管理员身份  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">空格键      向下翻一页</span><br><span class="line">page down  向下翻一页</span><br><span class="line">home       回到首页</span><br><span class="line">end        前往尾页</span><br><span class="line">&#x2F;          从上向下搜索关键词 如 &#x2F;Linux</span><br><span class="line">? 		   同 &#x2F;</span><br><span class="line">n          定位下一个搜索到的关键词</span><br><span class="line">N          定位上一个搜索到的关键词</span><br><span class="line">q          退出帮助程序</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="常用系统工作命令"><a href="#常用系统工作命令" class="headerlink" title="常用系统工作命令"></a>常用系统工作命令</h3><h4 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h4><p>用于在终端输出字符串或变量提取后的值  格式为</p>
<pre><code>echo [字符串|$变量]
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo hello world！</span><br><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hello world&quot;&gt;&gt; hanwen_stuff</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>格式  </p>
<pre><code>echo 写入文件 &quot;内容&quot; &gt;&gt; 文件名
</code></pre>
<p>注意提取变量的时候区分大小写     </p>
<h4 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h4><p>用于设置系统的时间、日期    格式为</p>
<pre><code>date [选项][+指定的格式]
</code></pre>
<p>%t 跳格<br>%H 小时<br>%I 小时<br>%M 分钟<br>%S 秒钟<br>%j 今年中第几天<br>%m 月<br>%d 日<br>%Y 年  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">date</span><br><span class="line">date &quot;+%Y-%m-%d %H:%M:%S&quot;</span><br><span class="line">date -s &quot;20210101 9:30:00&quot;</span><br><span class="line">date &quot;+%j&quot;</span><br></pre></td></tr></table></figure>

<h4 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h4><p>重启</p>
<pre><code>reboot
</code></pre>
<p>只有root才可以执行，因为这种涉及硬件资源的管理权限  </p>
<h4 id="poweroff"><a href="#poweroff" class="headerlink" title="poweroff"></a>poweroff</h4><p>关闭系统</p>
<pre><code>poweroff
</code></pre>
<p>只有root才可以执行，因为这种涉及硬件资源的管理权限 </p>
<h4 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h4><p>用于在终端中下载网络文件 格式为：</p>
<pre><code>wget[参数]下载地址
</code></pre>
<p>-b 后台下载模式<br>-p 下载到指定目录<br>-t 最大尝试次数<br>-c 断点续传<br>-p 下载页面中所有资源 包括图片、视频等<br>-r 递归下载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;www.xxxxxxx.com&#x2F;docs&#x2F;xxxxxx.pdf</span><br><span class="line">wget -r -p http:&#x2F;&#x2F;...............</span><br></pre></td></tr></table></figure>

<h4 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h4><p>查看系统中的进程状态</p>
<pre><code>ps[参数]
</code></pre>
<p>-a 显示所有进程<br>-u 用户以及其他详细信息<br>-x 显示没有控制终端的进程<br>Linux系统中时刻运行着很多进程，常见的5种进程状态分别为，运行，中断，不可中断，僵死 和停止。</p>
<ul>
<li>运行：R 进程正在运行或在运行队列中等待</li>
<li>中断:S 进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该状态。  </li>
<li>不可中断:D 进程不响应系统异步信号，即使Kill命令额不能将其终止。  </li>
<li>僵死：Z 进程已经终止，但是进程描述符依然存在，知道父进程调用wait4（）系统函数后将进程释放  </li>
<li>停止：T 进程收到停止信号后停止运行<br>PID 进程的ID号<br>start 是进程启动的时间  command命令名称和参数<br>Linux系统的命令参数有长短格式之分，长格式和长格式、短格式之间不能合并，但是短格式之间可以合并，合并后仅保留一个 - 减号 即可。另外ps命令可以允许参数不加减号 - ，因此可直接写成ps aux的样子。   <h4 id="TOP命令"><a href="#TOP命令" class="headerlink" title="TOP命令"></a>TOP命令</h4>top命令用于动态的监视进程活动。前五行为系统整体的统计信息，第一行<br>系统时间、运行时间、登录终端数、系统负载（三个数值一次为1分钟、5分钟、15分钟内的平均值，数值越小负载越低）<br>第二行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数</li>
</ul>
<h4 id="pidof命令"><a href="#pidof命令" class="headerlink" title="pidof命令"></a>pidof命令</h4><p>pidof用于查询某个指定服务进程的PID值</p>
<pre><code>pidof[参数][服务名称]
</code></pre>
<p>每个进程的进程号码值PID是唯一的，可以通过PID来区分不同的进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidof sshdq</span><br></pre></td></tr></table></figure>

<h4 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h4><p>用来终止某个指定PID的服务进程</p>
<pre><code>kill[参数]【进程PID】
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill 2156</span><br></pre></td></tr></table></figure>

<h4 id="killall命令"><a href="#killall命令" class="headerlink" title="killall命令"></a>killall命令</h4><p>killall命令用于终止某个指定的服务所对应的全部进程</p>
<pre><code>killall[参数][进程名称]
</code></pre>
<p>复杂的软件服务程序会有多个进程协同为用户提供服务，可以pidof 服务名称，可以得到所有PID 。killall 可以终止齐下的所有进程。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall httpd</span><br></pre></td></tr></table></figure>

<h4 id="ctrl-c组合键-可以在终端执行一个命令后，立即停止它。"><a href="#ctrl-c组合键-可以在终端执行一个命令后，立即停止它。" class="headerlink" title="ctrl + c组合键  可以在终端执行一个命令后，立即停止它。"></a>ctrl + c组合键  可以在终端执行一个命令后，立即停止它。</h4><h4 id="如果有些命令在执行时不断地在屏幕上输出信息，影响到后续输入，则可以在执行命令时末尾加上一个-amp-符号，这样命令将进入系统后台执行。"><a href="#如果有些命令在执行时不断地在屏幕上输出信息，影响到后续输入，则可以在执行命令时末尾加上一个-amp-符号，这样命令将进入系统后台执行。" class="headerlink" title="如果有些命令在执行时不断地在屏幕上输出信息，影响到后续输入，则可以在执行命令时末尾加上一个 &amp;符号，这样命令将进入系统后台执行。"></a>如果有些命令在执行时不断地在屏幕上输出信息，影响到后续输入，则可以在执行命令时末尾加上一个 &amp;符号，这样命令将进入系统后台执行。</h4><h3 id="系统状态检测命令"><a href="#系统状态检测命令" class="headerlink" title="系统状态检测命令"></a>系统状态检测命令</h3><h4 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h4><p>ifconfig命令用于获取网卡配置和网络状态</p>
<pre><code>ifconfig [网络设备][参数]
</code></pre>
<p>可以查看网卡名称、inet参数后面的IP地址、eher参数后面的网卡物理地址MAC地址，以及RX\TX的接收数据包和发送数据包的累计流量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>

<h4 id="uname命令"><a href="#uname命令" class="headerlink" title="uname命令"></a>uname命令</h4><p>uname命令用于查看系统内核系统版本的信息</p>
<pre><code>uname[-a]
</code></pre>
<p>一般会固定搭配-a查看当前系统的内核名称、主机名、内核发行版本、硬件名称等等</p>
<h4 id="uptime命令"><a href="#uptime命令" class="headerlink" title="uptime命令"></a>uptime命令</h4><p>查看系统负载信息</p>
<pre><code>uptime
</code></pre>
<p>显示系统时间、已经运行的时间、启用终端数量以及平均负载值(1min.5min.15min)<br>负载值越低越好，尽量不要长期超过1，生产环境下不要超过5。</p>
<h4 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h4><p>显示系统内存使用量信息 </p>
<pre><code>free[-h]
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure>
<p>内存总量、已用量、可用量（free）、进程共享的内存量、磁盘缓存的内存量、缓存的内存量 </p>
<h4 id="who命令"><a href="#who命令" class="headerlink" title="who命令"></a>who命令</h4><p>用于查看登入主机的用户终端的信息  </p>
<pre><code>who[参数]
</code></pre>
<h4 id="last命令"><a href="#last命令" class="headerlink" title="last命令"></a>last命令</h4><p>用于查看所有登录系统的登录记录</p>
<pre><code>last[参数]
</code></pre>
<p>这些信息都是以日志的形势保存在系统里，所以还是很容易对其内容篡改的。</p>
<h4 id="history-命令"><a href="#history-命令" class="headerlink" title="history 命令"></a>history 命令</h4><p>用于显示历史执行过的命令。（1000条），不够用还可以设置。</p>
<pre><code>history[-c]
</code></pre>
<p>-c参数会清空所有的命令历史记录。历史命令会被保存到用户目录中的.bash_history里 Linux系统中以.开头的文件都是隐藏文件，这些文件大部分都是系统服务文件。可以用cat命令查看文件内容。</p>
<pre><code>！[编码数字]
</code></pre>
<p>来重复执行某一次命令 这个数字对应history里的第几次命令</p>
<pre><code>！14
</code></pre>
<h4 id="sosreport命令"><a href="#sosreport命令" class="headerlink" title="sosreport命令"></a>sosreport命令</h4><p>用于收集系统配置 框架信息并输出诊断文档</p>
<pre><code>sosreport
</code></pre>
<h3 id="工作目录切换命令"><a href="#工作目录切换命令" class="headerlink" title="工作目录切换命令"></a>工作目录切换命令</h3><h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><p>用于显示目前中断所处的工作目录 </p>
<pre><code>pwd[选项]
</code></pre>
<h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><p>cd命令切换工作路径 </p>
<pre><code>cd[目录名称]
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;etc   # 切换到指定目录</span><br><span class="line">cd -      # 返回上一次的目录</span><br><span class="line">cd ~  	  # 返回当前用户的家目录</span><br><span class="line">cd ..     # 返回上一级目录</span><br><span class="line">cd ~username  # 返回指定用户的家目录</span><br></pre></td></tr></table></figure>

<h4 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h4><p>用于显示目录中的文件信息</p>
<pre><code>ls[选项][文件]
</code></pre>
<p>ls -a参数看到全部文件 包括隐藏文件 使用“-l”参数可以查看文件大小、属性的详细信息。-d是查看目录属性信息 </p>
<pre><code>ls -al
</code></pre>
<h3 id="文本文件编辑命令"><a href="#文本文件编辑命令" class="headerlink" title="文本文件编辑命令"></a>文本文件编辑命令</h3><p>Linux系统中一切皆文件 对服务程序进行配置就是对程序配置文件编辑  </p>
<h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p>用于查看较小规模的纯文本文件 </p>
<pre><code>cat[选项][文件]
</code></pre>
<p>-n参数可以显示行号  cat查看大文本文件会让信息一直在屏幕上快速翻滚。</p>
<pre><code>cat -n initial-setup-ks.cfg
</code></pre>
<h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><p>用于查看大文本文件 </p>
<pre><code>more[选项][文件]  
</code></pre>
<p>最下方有百分比提示看了多少了，其次空格键和回车键支持翻页   </p>
<pre><code>more initial-setup-ks.cfg
</code></pre>
<h4 id="head"><a href="#head" class="headerlink" title="head"></a>head</h4><p>用于查看纯文本文件的前N行，格式为 </p>
<pre><code>head[选项][文件]
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n 20 initial-setup-ks.cfg</span><br></pre></td></tr></table></figure>

<h4 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h4><p>用于查看纯文本文件的后N行 或持续刷新内容  </p>
<pre><code>tail[选项][文件]
</code></pre>
<p>和head方法参数都一样<br>当要实时查看最新的日志文件时候，此时的命令格式为</p>
<pre><code>tail -f 文件名
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f &#x2F;var&#x2F;log&#x2F;messages</span><br></pre></td></tr></table></figure>

<h4 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h4><p>用于替换文本文件中的字符</p>
<pre><code>tr[原始字符][目标字符]
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat anaconda-ks.cfg | tr [:lower:]  [:upper:]</span><br></pre></td></tr></table></figure>
<p>两个正则表达式记得分开 不然就算一个字符串所以报错缺少   </p>
<h4 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h4><p>wc命令用于统计制定文本的行数、字数、字节数</p>
<pre><code>wc[参数]文本
</code></pre>
<p>-l 只显示行数<br>-w 只显示单词数<br>-c 只显示字节数</p>
<h4 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h4><p>用于按列提取文本字符  </p>
<pre><code>cut[参数]文本
</code></pre>
<p>-f参数用来设置需要看的列数 -d参数用来设置间隔符号</p>
<pre><code>cut -d: -f 1 /etc/passwd
</code></pre>
<h4 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h4><p>diff命令用于比较多个文本文件的差异 </p>
<pre><code>diff [参数] 文件
</code></pre>
<p>–brief参数来确定两个文件是否不同<br>-c 比较多个文件差异<br>可以用于文件判断是否被篡改  </p>
<pre><code>diff --brief diff_A.txt diff_B.txt
</code></pre>
<h3 id="文件目录管理命令"><a href="#文件目录管理命令" class="headerlink" title="文件目录管理命令"></a>文件目录管理命令</h3><h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><p>用于创建空白文件后者设置文件的时间 </p>
<pre><code>touch [选项][文件名]
</code></pre>
<p>创建一个空白的文本文件<br>-a 参数 仅仅修改读取时间atime<br>-m 参数 仅仅修改修改时间mtime<br>-d 同时修改mtime atime</p>
<pre><code>touch -d &quot;2020-12-12 14:22&quot; hanwen_stuff
</code></pre>
<h4 id="wq"><a href="#wq" class="headerlink" title=":wq"></a>:wq</h4><p>mkdir创建空白的目录 </p>
<pre><code>mkdir[选项]【目录】
</code></pre>
<p>-p参数可以递归嵌套生成嵌套目录  </p>
<pre><code>mkdir hanwentrain
cd hanwentrain
mkdir -p a/b/c/d/e
</code></pre>
<h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p>cp复制文件或目录 格式为</p>
<pre><code>cp [选项] 源文件 目标文件
</code></pre>
<p>如果目标文件是目录 则会吧源文件复制到该目录中<br>如果目标文件是文件 则会询问是否要覆盖它<br>如果目标文件不存在，则会执行正常的复制操作<br>-p 保留原始文件属性<br>-d 如果对象为链接文件  保留该链接文件的属性<br>-r 持续递归复制 用于目录<br>-i 若目标文件存在询问是否覆盖<br>-a 相当于-pdr</p>
<h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><p>用于剪切文件或者文件重命名  </p>
<pre><code>mv [选项]源文件[目标路径|目标文件名]
</code></pre>
<p>mv和cp不同 他会默认把源文件删除   所以在同一个目录使用mv操作实际上就是重命名   </p>
<h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p>删除文件或目录  (remove)</p>
<pre><code>rm [文件名]
</code></pre>
<p>系统默认询问你是否确定执行删除操作 如果你不想总是看到这种反复提醒的确认信息，需要输入y 再enter ，直接enter则是否认的意思 。<br>默认 -f参数可以强制删除   此外如果要删除目录 必须要跟一个-r，系统会逐层嵌套询问是否进入目录xxx ，以及是否确认删除xxx    </p>
<pre><code>rm install.log
rm -f linux.log
rm -fa 文件夹名 
</code></pre>
<h4 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h4><p>用于指定大小和个数的数据块来复制文件或转换文件  格式为dd[参数]<br>能够让用户按照指定大小和个数的数据块来复制文件内容，如果愿意的话，还可以在复制过程中转换其中的数据。<br>Linux系统中有过一个/dev/zero的设备文件，他不会占用系统存储空间，却可以提供无穷尽的数据，可以用它作为dd 命令的输入文件 。<br>if=  输入文件名称<br>of=  输出文件名称<br>bs=  设置每一个块的大小<br>count=  设置要复制的块的个数  </p>
<pre><code>dd if=/dev/zero of=560_file count=1 bs=560M
</code></pre>
<p>等于号左右不能加空格  dd可以复制文件 也可以吧比如印文件做成iso格式的镜像文件，dd可以直接压制出来。</p>
<pre><code>dd if=/dev/cdrom of=RHEL-server-7.0-x86_64-Linuxprobe.co.iso 
</code></pre>
<h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><p>用于查看文件的类型 </p>
<pre><code>file 文件名  
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file anaconda-ks.cfg</span><br></pre></td></tr></table></figure>

<h3 id="打包压缩与搜索命令"><a href="#打包压缩与搜索命令" class="headerlink" title="打包压缩与搜索命令"></a>打包压缩与搜索命令</h3><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><p>对文件进行压缩或解压  </p>
<pre><code>tar [选项][文件]
</code></pre>
<p>-c 创建压缩文件<br>-x 解开压缩文件<br>-t 查看压缩包内有哪些文件<br>-z 用Gzip压缩或解压<br>-j 用zip2压缩或解压<br>-v 显示压缩解压过程<br>-f 目标文件名<br>-P 保留原始权限和属性<br>-p 使用绝对路径来压缩<br>-C 解压到指定目录<br>注意 -f参数特别重要 他必须放到参数的最后一位  代表压缩或者解压的软件包名称<br>可以常用 -czvf 压缩 -xzvf解压</p>
<pre><code>tar -czvf etc.tar.gz /etc
tar -czvf 压缩包名称.tar.gz 要打包的目录或文件

tar -czvf 压缩包名称.tar.gz tar [-C 指定位置 不指定就解压在原地]
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xzvf hanwentartrain.tar.gz -C hanwentar</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><p>在文本执行关键词搜索 并显示匹配的结果 </p>
<pre><code>grep[选项][文件]
</code></pre>
<p>-n 显示显示搜索到的信息的行号<br>-v 参数用于反选信息（即是没有包含关键词的所有信息行）  </p>
<p>/etc/passwd 文件是保存所有用户信息的  </p>
<pre><code>grep hello hanwentrain
</code></pre>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>按照指定条件来查找文件   </p>
<pre><code>find[查找路径] 寻找条件 操作 
</code></pre>
<p>-name 匹配名称<br>-perm 匹配权限<br>-user 匹配所有者<br>-group 匹配所有组<br>-mtime -n +n 匹配修改内容时间 -n为多少天内，+n为多少天前<br>-atime -n +n 匹配访问文件时间 -n为多少天内，+n为多少天前<br>-ctime -n +n 匹配修改文件权限时间 -n为多少天内，+n为多少天前<br>-newer f1 !f2匹配比f1新但是比f2旧的文档<br>-size 匹配文件大小<br>-prune 忽律某个目录<br>–type b/d/c/p/l/f 匹配文件类型<br>-etec…. {}\； 后面可以跟用于金已处理搜索结果的命令   </p>
<pre><code>find /etc -name &quot;host*&quot; -print

find / -name &quot;hanwen*&quot;
</code></pre>
<p>/ 空格 不加任何地址是全局搜索 </p>
<h3 id="tab键补齐简直太好用了"><a href="#tab键补齐简直太好用了" class="headerlink" title="tab键补齐简直太好用了"></a>tab键补齐简直太好用了</h3><h4 id="！是Linux-shell里的关键字，如果字符串输入，记得是单引号，双引号会报错"><a href="#！是Linux-shell里的关键字，如果字符串输入，记得是单引号，双引号会报错" class="headerlink" title="！是Linux shell里的关键字，如果字符串输入，记得是单引号，双引号会报错"></a>！是Linux shell里的关键字，如果字符串输入，记得是单引号，双引号会报错</h4><h2 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h2><p>输入重定向是指把文件导入命令中， 而输出重定向是指把原来要输出到屏幕的数据信息，写入指定文件中。相较于输入重定向，我们用输出重定向频率更高。<br>输出重定向有两种，一种是标准输出重定向，一个是错误输出重定向，以及清空写入与追加写入两种。  </p>
<ul>
<li>标准输入重定向 STDIN 文件描述符 0， 默认从键盘输入，也可以从其他文件或命令中输入。  </li>
<li>标准输出重定向 STDOUT 文件描述符 1， 默认输出到屏幕  </li>
<li>错误输出重定向 STDERR 文件描述符 2， 默认输出到屏幕   </li>
</ul>
<p>简单来说，当我们标准输出没问题的时候，不用加文件描述符1，如果是要catch错误信息，需要加入2，虽然都会创建文件，但是如果没有错误则不会写入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">命令 &lt; 文件</span><br><span class="line">命令 &lt;&lt; 分界符</span><br><span class="line">命令 &lt; 文件1 &gt;文件2 将文件1作为命令的标准输入并将标准输出到文件2中去</span><br><span class="line">命令 &gt; 文件 将标准输出重定向到一个文件（清空原有文件数据）</span><br><span class="line">命令 2&gt; 文件 将错误输出重定向到一个文件（清空原有文件数据）</span><br><span class="line">命令 &gt;&gt; 文件 将标准输出重定向到一个文件（追加到原有内容后面）</span><br><span class="line">命令 2&gt;&gt; 文件 将错误输出重定向到一个文件（追加到原有内容后面）</span><br><span class="line">命令 &amp;&gt;&gt; 文件 将标准输出和错误输出都到一个文件中 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">man bash &gt; readme.txt</span><br><span class="line">echo &#39;welcome to Linux world!!!&#39; &gt; readme.txt</span><br><span class="line">echo &#39;fighting ! hanwen&#39; &gt;&gt; readme.txt</span><br><span class="line">ls -l xxxxxx 2&gt;&gt; errorlog.txt </span><br></pre></td></tr></table></figure>

<p>如果想把命令的报错信息写入到文件，用户执行一个自动化的shell脚本的时候，这个操作会特别有用特别实用，因为它可以吧整个脚本执行过程中的报错信息都记录到文件中，便于安装后的排错工作。    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc -l &lt; readme.txt</span><br></pre></td></tr></table></figure>

<h2 id="管道命令符"><a href="#管道命令符" class="headerlink" title="管道命令符"></a>管道命令符</h2><p>同时按下键盘上的shift+\键 即可进入输入管道符 其执行格式为“命令A|命令B”<br>把前一个原本要输出到屏幕的标准正常数据当做是后一个命令的标准输入   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;&#x2F;sbin&#x2F;nologin&quot; &#x2F;etc&#x2F;passwd | wc -l</span><br><span class="line">ls -l &#x2F;etc&#x2F;|more</span><br></pre></td></tr></table></figure>
<p>用户修改密码的时，通常都需要输入两次密码进行确认。在编写自动化脚本的时候将成为非常致命的缺陷，通过把管道符和passwd命令的 –stdin参数结合，我们可以用一条命令来完成密码重置操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hanwen&quot;|passwd --stdin root</span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line">mail -s &quot;readme&quot; root@linuxprobe.com &lt;&lt; over</span><br><span class="line">&gt; context</span><br><span class="line">&gt; context</span><br><span class="line">&gt; over</span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line">命令A|命令B|命令C 可以一直嵌套管道符</span><br><span class="line"></span><br><span class="line">### su</span><br><span class="line"></span><br><span class="line">	su - username</span><br><span class="line">登录用户</span><br><span class="line"></span><br><span class="line">	exit</span><br><span class="line">退出登录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 命令行的通配符</span><br><span class="line">通配符就是通用匹配信息的符号  </span><br><span class="line">*代表匹配0-无穷个字符  </span><br><span class="line">？代表单个字符   </span><br><span class="line">[0-9]代表0-9的单个数字字符    </span><br><span class="line">[a-z]代表a-z的单个字母字符   </span><br><span class="line">[123]代表1,2,3中任意一个字符    </span><br><span class="line"></span><br><span class="line">	ls -l &#x2F;dev&#x2F;sda*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 四个常用的转义符  </span><br><span class="line">反斜杠 \  使反斜杠后面的变量变成单纯的字符串   </span><br><span class="line">单引号 &#39;  &#39; 转移其中所有的变量变成单纯的字符串   </span><br><span class="line">双引号 &quot;  &quot; 保留其中的变量属性，不进行转义处理</span><br><span class="line">反引号 &#96;  &#96; 把其中的命令执行返回一个结果  </span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;Linux</span><br><span class="line">price&#x3D;5</span><br><span class="line">echo &quot;price is $price&quot;</span><br><span class="line">echo &quot;price is \$$price&quot;</span><br><span class="line">echo &#96;uname -a&#96;</span><br></pre></td></tr></table></figure>

<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>在Linux中变量一般都大写，我们可以直接通过变量名称提取到对应的变量值。<br>Linux系统中环境变量是用来定义一些系统运行环境的一些参数，比如每个用户不同的家目录，邮件存放地址。</p>
<h3 id="命令在Linux系统里的四个步骤"><a href="#命令在Linux系统里的四个步骤" class="headerlink" title="命令在Linux系统里的四个步骤"></a>命令在Linux系统里的四个步骤</h3><ol>
<li><p>判断用户是否以及绝对路径或者相对路径的方式输入命令，如果是的话直接执行。</p>
</li>
<li><p>Linux系统检查用户的输入命令是否为别名命令，即是用户自顶一个的一个命令名称替换原来的命令名称。可以用alias命令来创建一个 </p>
<p> alias 别名=命令<br> unalias 别名  </p>
</li>
<li><p>bash解释器判断用户输入的是内部之灵还是外部指令。如果是内部指令，就是解释器内部的指令，则会直接执行。  </p>
</li>
<li><p>系统在多个路径中查找用户输入的命令文件，定义这些路径的变量叫PATH，可以简单的理解为解释器小助手。PATH变量是一个用各个路径间冒号相连的环境变量。这些路径的增加或删除会影响到Bash解释器对命令的查找</p>
<p> echo $PATH<br> path=$path:/root/bin</p>
</li>
</ol>
<p>在接手一台LINUX系统后 执行命令前要检查PATH变量中是否有可疑的目录。</p>
<p>常用的环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HOME 用户的主目录（家目录）</span><br><span class="line">SHELL 用户在使用的shell解释器名称</span><br><span class="line">HISTSIZE 输出历史命令记录条数</span><br><span class="line">MAIL 右键保存路径</span><br><span class="line">LANG 系统语言</span><br><span class="line">RANDOM 生成一个随机的数字</span><br><span class="line">PATH 解释器搜索用户执行命令的路径</span><br></pre></td></tr></table></figure>
<p>一个相同的变量在不同的用户是不同的，也是不通的，除非用export 命令提升为全局变量。</p>
<pre><code>export 变量名
</code></pre>
<h2 id="Vim文本编辑器"><a href="#Vim文本编辑器" class="headerlink" title="Vim文本编辑器"></a>Vim文本编辑器</h2><p>日常工作中免不了需要编写文档，这些工作都是通过文本编辑器完成的。<br>Vim文本编辑器默认安装在当前所有Linux操作系统上<br>Vim文本编辑器有三种模式,命令模式、末行模式、编辑模式。<br>命令模式：控制光标移动 ，可以对文本进行复制、粘贴、删除、查找功能<br>输入模式：正常文本录入<br>末行模式：保存或退出文档 以及设置编辑环境<br>每次运行Vim编辑器会默认进入命令模式，先切换到输入模式在进行文档编辑工作。<br>在编辑完文档后需要先返回命令模式，在进入末行模式，执行文档的保存或退出。Vim中无法直接从输入模式切换到末行模式。  </p>
<p>命令模式：<br>dd 删除（剪贴）光标所在整行<br>yy 复制光标缩在整行<br>n 显示搜索命令定位的下一个字符串<br>N 显示搜索命令定位的上一个字符串<br>u 撤销上一条命令<br>p 将之前删除dd或复制yy的粘贴到光标后面<br>yG 从光标位置复制到文件尾<br>ggyG  全部复制<br>yy 复制游标所在行整行<br>选中文本进行复制 在命令模式下按 v 进入 Visual Mode，然后用 方向键 或 hjkl 选择文本，再按 y 进行复制<br>p    粘贴至游标后（下）<br>P    粘贴至游标前（上）  </p>
<p>末行模式主要用于保存或者退出。在命令模式中输入一个冒号进入末行模式<br>:w 保存<br>:wq! 强制保存后退出<br>:q  退出<br>:q!  强制退出不保存<br>:set nu  显示行数<br>:命令  执行命令<br>:整数  跳转到这一行<br>？字符串 从文本从下向上搜索该字符串<br>/字符串  从文本从上向下搜索该字符串    </p>
<p>创建一个可以直接</p>
<pre><code>vim 文件名 
</code></pre>
<p>命令模式下a、i、o三个键都可以切换到输入模式<br>a键与i键分别是光标后面一位和光标当前位置切换到输入模式<br>而 o键是光标下面创建一个空行 然后等待输入   </p>
<p>记住一点就是输入模式还是末行模式 都是esc退回命令模式   </p>
<h2 id="配置主机名称"><a href="#配置主机名称" class="headerlink" title="配置主机名称"></a>配置主机名称</h2><p>为了方便局域网中查找某台特定的主机，或者对主机进行区分，除了要有IP地址外，还要为主机配置一个主机名，主机之间可以用类似于域名的名称来互相访问。在Linux系统中，主机名大多保存在 /etc/hostname 文件中  </p>
<ol>
<li><p>使用VIM编辑器 </p>
</li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
<li><p>“/etc/hostname”主机名称文件  </p>
</li>
<li><p>把原始主机名称删除后 追加新的名称  记得保存 wq!</p>
</li>
<li><p>退出文档 使用hostname检查是否修改成功</p>
<p> vim /etc/hostname</p>
</li>
</ol>
<h2 id="配置网卡信息"><a href="#配置网卡信息" class="headerlink" title="配置网卡信息"></a>配置网卡信息</h2><p>网卡IP地址配置是否正确是两台服务器是否可以通信的前提。<br>配置网络服务的工作其实就是编辑网卡配置文件。<br>而在RHEL7中，网卡配置文件的前缀，则以ifcfg开始加上网卡名称共同组成了网卡配置文件的名字，例如 ifcfg-eno16777736   </p>
<p>第一步： 首先切换到网卡配置文件地址   /etc/sysconfig/network-scripts<br>第二步： 使用vim编辑器修改网卡文件  ifcfg-eno16777736  逐项写入配置参数保存退出。<br>第三步： 重启网络服务并测试网络是否联通  </p>
<p>执行重启网卡设备的命令（在正常情况下不会有提示信息）然后通过ping命令测试网络能否联通<br>Linux系统中ping命令不会自动终止，因此需要手动按下ctrl+c 来强行结束进程    </p>
<h2 id="配置Yum软件仓库"><a href="#配置Yum软件仓库" class="headerlink" title="配置Yum软件仓库"></a>配置Yum软件仓库</h2><p>Yum软件仓库的作用是为了进一步简化RPM管理软件的难度以及自动分析所需要软件包以及其依赖关系的技术，可以想象成一个硕大的软件仓库，里面保存了几乎所有常用的工具，而且只需要说出所需的软件包名称，系统就会自动为您搞定一切。   </p>
<ol>
<li>进入/etc/ym.repos.d/目录中，这个目录存放着Yum软件仓库的配置文件  </li>
<li>使用Vim编辑器创建一个名为rhel7.repo的新配置文件（后缀必须是repo文件名随意） 逐项写入配置参数并保存</li>
</ol>
<ul>
<li>[rhel-media]</li>
<li>name=hostname</li>
<li>baseurl=file:///media/cdrom</li>
<li>enabled=1</li>
<li>gpgcheck=1</li>
<li>gpgky</li>
</ul>
<ol start="3">
<li>按照配置参数路径挂载光盘，并把光在挂载信息写入到/etc/fstab文件中</li>
<li>使用 yum install httpd -y  命令检查Yum软件仓库是否可用了  </li>
<li>创建挂载点后进行挂载操作，尝试使用Yum软件仓库来安装软件。  </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;etc&#x2F;yum.respos.d&#x2F;</span><br><span class="line">vim rehl7.zepo</span><br><span class="line">[rhel7]</span><br><span class="line">name&#x3D;rhel7</span><br><span class="line">baseurl&#x3D;file:&#x2F;&#x2F;&#x2F;media&#x2F;cdrom</span><br><span class="line">enable&#x3D;1</span><br><span class="line">gpgcheck&#x3D;0</span><br></pre></td></tr></table></figure>

<h2 id="编写Shell脚本"><a href="#编写Shell脚本" class="headerlink" title="编写Shell脚本"></a>编写Shell脚本</h2><p>shell终端是人和计算机硬件之间的翻译官，shell脚本命令的工作方式通常有两种：一种是交互式，用户没输入一条就执行一条；一种是批处理，有用户事先编写好一个完整的shell脚本，shell会一次性执行完诸多命令。<br>系统默认Bash作为命令行的解释器<br>shell 脚本文件的名称可以任意名单为了避免误以为是普通文件，建议将.sh后缀加上 以表示一个脚本文件。  #！/bin/bash 声明系统使用那种shell解释器来执行脚本。同时可以用 # 作为注释  。可以直接用</p>
<pre><code>bash 文件名
</code></pre>
<p>来运行shell脚本文件，也可以输入完整路径来执行，但默认会因为权限不足而报错  只需要为文本文件增加执行权限即可。   </p>
<pre><code>vim test.sh
#!/bin/bash
#for example:this is a note
pwd
ls =al
</code></pre>
<h3 id="shell脚本接受用户输入的参数"><a href="#shell脚本接受用户输入的参数" class="headerlink" title="shell脚本接受用户输入的参数"></a>shell脚本接受用户输入的参数</h3><p>shell已经内设了用于接受参数的变量，变量之间可以用空格隔开。例如，$0 对应当前shell脚本程序的名称，$#对应是有几个参数  $*对应是所有参数 $?对应是显示上一个命令执行的返回值</p>
<pre><code>#!/bin/bash
echo &quot;this bash name is $0&quot;
echo &quot;there are $# vars,they are $*&quot;
echo &quot;the 1st var is $1,the fifth var is $5&quot;

sh test.sh one two three four &quot;hello world&quot;
</code></pre>
<h3 id="判断用户的参数"><a href="#判断用户的参数" class="headerlink" title="判断用户的参数"></a>判断用户的参数</h3><p>shell脚本中的条件测试语法可以判断表达式是否成立，若条件成立，则返回数字0，否则便返回其他随机数值。<br>测试语法格式：</p>
<pre><code>[ 条件表达式 ]   注意两边均要有个空格
</code></pre>
<p>条件测试语句常见的有四种：</p>
<ol>
<li>文件测试语句</li>
<li>逻辑测试语句</li>
<li>整数值比较语句</li>
<li>字符串比较语句</li>
</ol>
<p>文件测试就是用来指定条件判断文件是否存在或权限是否满足情况的运算符。  </p>
<p>-e 判断文件是否存在<br>-d 测试文件是否为目录类型<br>-r 测试当前用户是否有权限读取<br>-w 测试当前用户是否有权限写入<br>-x 测试当前用户是否有权限执行<br>-f 判断是否为一般文件  </p>
<pre><code>[ - f /etc/fastab]
</code></pre>
<h2 id="shell逻辑判断符号"><a href="#shell逻辑判断符号" class="headerlink" title="shell逻辑判断符号"></a>shell逻辑判断符号</h2><p>与  &amp;&amp;<br>或  ||<br>否  !</p>
<pre><code>[ -e /dev/cdrom ] &amp;&amp; echo &quot;Exist&quot;
</code></pre>
<p>可以利用与的特性 判断正确才执行后面的命令来判断显示一体化   </p>
<pre><code>[ $USER = root ] || echo &quot;user&quot;
</code></pre>
<p>利用或的特性 判断失败后才会执行 or后面的语句  </p>
<pre><code>[ ! $USER = root ]
</code></pre>
<p>可以用组合语句来实现判断什么输出什么 ：</p>
<pre><code>[ ! $USER = root ] &amp;&amp; echo &quot;user&quot; || echo &quot;root&quot;
</code></pre>
<p>整数比较符只能对数字操作，不能将数字和文件、字符串等内容一起操作。因为等号与赋值命令符冲突，大小号和输入输出重定向冲突。   </p>
<p>-eq 是否等于<br>-ne 是否不等<br>-gt 是否大于<br>-lt 是否小于<br>-le 是否等于或小于<br>-ge 是否大于或等于  </p>
<pre><code>[ 10 -gt 10 ] 

free -m | grep Mem:
free -m | grep Mem | awk &#39;&#123;print $4&#125;&#39;
FreeMem=`free -m | grep Mem: | awk &#39;&#123;print $4&#125;&#39;`

[ $FreeMem -lt 1024 ] &amp;&amp; echo &quot;Insufficient Memory&quot;
</code></pre>
<p>字符串比较语句 用于判断测试字符串是否为空值  或两个字符串是否相同<br>=  字符串内容是否相同<br>！=  字符串内容不同<br>-z   判断字符串内容是否为空    </p>
<pre><code>[ -z $string ]
</code></pre>
<p>变量不是英文时：</p>
<pre><code>[ $LANG != &quot;en.US&quot;] &amp;&amp; echo &quot;Not en.US&quot;
</code></pre>
<h2 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h2><h3 id="if条件语句"><a href="#if条件语句" class="headerlink" title="if条件语句"></a>if条件语句</h3><p>句型：   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if 条件语句</span><br><span class="line">then 命令语句</span><br><span class="line">elif 条件语句  </span><br><span class="line">then 命令语句  </span><br><span class="line">else</span><br><span class="line">命令语句 </span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<pre><code>#! /bin/bash
DIR=&#39;/media/cdrom&#39;
if [ ! -e $DIR ]
then
mkdir -p $DIR
fi
</code></pre>
<p>Linux系统里的ping命令不像Windows一样尝试四次就结束，因此为了避免用户等待市场过长，需要通过 -c 参数来规定尝试次数， 并使用 -i参数定义每个数据报发送间隔 ，以及用 -W参数定义等待超时时间   </p>
<pre><code>#! /bin/bash
ping -c 3-i 0.2 -W 3 $1 &amp;&gt; /dev/null
if [ $? -eq 0 ]
then
echo &quot;Host $1 is ON-line&quot;
else
echo &quot;Host $1 is OFF-line&quot;
fi



#! /bin/bash
read -p &quot;Input your score(0-100):&quot; GRADE
if [ $GRADE -ge 85 ] &amp;&amp; [ $GRADE -le 100 ]
then  
echo &quot;$GRADE is excellent&quot;  
elif [ $GRADE -ge 70 ] &amp;&amp; [ $GRADE -le 84 ]
then
echo &quot;$GRADE is pass&quot;
else
echo &quot;$GRADE is fail!&quot;
fi
</code></pre>
<h3 id="for条件循环"><a href="#for条件循环" class="headerlink" title="for条件循环"></a>for条件循环</h3><p>for循环允许脚本一次性读取多个信息，然后逐个对信息进行操作处理，党要处理的数据有范围时候，使用for循环语句在适合不过了。    </p>
<pre><code>for 变量名这里注意不要加$ in 取值列表
do
命令序列
done
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#! &#x2F;bin&#x2F;bash</span><br><span class="line">read -p &quot;Enter password:&quot; PASSWD</span><br><span class="line">for UNAME in &#96;cat users.txt&#96;</span><br><span class="line">do</span><br><span class="line">id $UNAME &amp;&gt; &#x2F;dev&#x2F;null</span><br><span class="line">if [ $? -eq 0 ]</span><br><span class="line">then </span><br><span class="line">echo &quot;Already exists&quot;</span><br><span class="line">else</span><br><span class="line">useradd $UNAME &amp;&gt; &#x2F;dev&#x2F;null</span><br><span class="line">echo &quot;$PASSWD&quot; | passwd --stdin $UNAME &amp;&gt; &#x2F;dev&#x2F;null</span><br><span class="line">if [ $? -eq 0 ]</span><br><span class="line">then </span><br><span class="line">echo &quot;$UNAME, Create success&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;$UNAME, Create failure&quot;</span><br><span class="line">fi</span><br><span class="line">fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>告诉用户正在输入的内容即将作为账户密码，在执行改脚本后，会自动使用从列表文件users.txt中获取所有用户名称。然后逐一使用 id用户名命令查看用户信息，并使用 $?来判断这条命令是否执行成功，也就是判断该用户是否存在。<br>/dev/null 是一个特殊的设备文件，它丢弃一切写入其中的数据 可以将它 视为一个黑洞, 它等效于只写文件, 写入其中的所有内容都会消失, 尝试从中读取或输出不会有任何结果，同样，/dev/null 在命令行和脚本中都非常有用</p>
<p>在Linux系统中 /etc/passwd是用来保存用户信息的文件。   </p>
<p>$(cat ~/ipadds.txt) 等价于 <code>cat ~/ipadds.txt</code></p>
<h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><p>while条件循环语句是一种让脚本根据某种条件来来重复执行命令的语句，它的循环结构往往可以执行不知道最终执行次数的循环，通过判断条件真假来决定是否执行命令。</p>
<pre><code>while 条件测试语句
do
命令序列
done
</code></pre>
<p>exit 0 可以命令 终止脚本执行exit命令用于退出当前shell，在shell脚本中可以终止当前脚本执行。  </p>
<pre><code>#!/bin/bash
PRICE=$(expr $RANDOM % 1000)
TIMES=0
echo &quot;The price is between 0-999,guess&quot;
while true
do
read -p &quot;guess a num between 0-999&quot; INT
let TIMES++
if [ $INT -eq $PRICE ]
then
echo &quot;niubi! correct~the price is $PRICE&quot;
echo &quot;you have guessed $TIMES times&quot;
exit 0
elif [ $INT -gt $PRICE ]
then
echo &quot;too high&quot;
else
echo &quot;too low&quot;
fi
done
</code></pre>
<h2 id="case条件测试语句"><a href="#case条件测试语句" class="headerlink" title="case条件测试语句"></a>case条件测试语句</h2><p>case语句是多个范围内匹配数据，若匹配成功，则执行相关命令，并结束整个条件测试。如果数据不再列出的范围内，则会去执行星号（*）中所定义的默认命令。    </p>
<pre><code>#!/bin/bash
read -p &quot;print anything you like:&quot; KEY
case $KEY in
[0-9])
echo &quot;this is digits&quot;
;;
[a-z] | [A-Z])
echo &quot;this is alpha&quot;
;;
*)
echo &quot;sha dou bu shi&quot;
esac
</code></pre>
<h2 id="计划任务服务程序"><a href="#计划任务服务程序" class="headerlink" title="计划任务服务程序"></a>计划任务服务程序</h2><p>Linux可以实现无需人为介入的情况下，未指定的时间段自动启动或停止某些服务或者命令，从而实现运维自动化。<br>设置服务器的计划任务服务，把周期性，规律性的工作交给系统自动完成。<br>一次性计划任务只执行一次，可以用at命令实现。只需要写成at时间即可。如果要查看已经设置好但还没有执行的一次性计划任务，可以使用at -l命令。如果要删除可以用atrm 任务序号删除。at命令来设置一次性任务时，默认是采用交互式的方法。</p>
<pre><code>at 23:30
at &gt; systemct1 restart httpd
at &gt; 同时按下ctrl + d实现结束编写计划任务  
</code></pre>
<p>删除其中一个任务可以用</p>
<pre><code>atrm 2
</code></pre>
<p>删除第序列号为2的一次性任务<br>    at -l<br>展示还未执行的一次性任务<br>如果希望Linux系统能周期性的，有规律的执行某些具体的任务，那么Linux系统中默认启动的crond服务在适合不过了。创建和编辑计划任务的命令为 </p>
<pre><code>crontab -e
</code></pre>
<p>查看当前计划任务的命令为：</p>
<pre><code>crontab -l 
</code></pre>
<p>删除某条计划任务为：</p>
<pre><code>crontab -r
</code></pre>
<p>还可以在crontab命令中加上 -u参数来编辑他人的计划任务<br>分、时、日、月、星期几命令。如果那个没有设置需要用 * 号占位   </p>
<p>可以用逗号来表示多个时间段， 比如8,9,12 如果是在月份那一位置，就可以标识8,9，12月。 可以用减号 - 来表示一段连续的时间周期。以及用除号表示 执行任务的间隔时间  “*/2” 在分钟的位置就表示每两分钟执行一次任务    </p>
<p>crond服务中如果要包含多个计划任务的命令语句，则需要每行只写一个。<br>在crond服务里参数所有命令，一定要用绝对路径来写。</p>
<h2 id="用户身份与文件权限"><a href="#用户身份与文件权限" class="headerlink" title="用户身份与文件权限"></a>用户身份与文件权限</h2><p>root管理员是存在于所有类UNIX系统中的超级用户，他拥有最高的系统所有权，可以管理系统的各种功能，比如添加删除用户，启动和关闭服务进程，开启和禁用硬件设备。<br>Linux系统的管理员之所以是root，是因为他的UID user Identification的数值是0，在Linux系统中，UID就相当于身份证号码一样具有唯一性，可以通过用户UID来判断用户身份。<br>系统用户UID 为1-999，Linux系统为了避免某个服务程序出现漏洞而被黑客提权到整台服务器，默认服务程序会有独立的系统用户负责运行，从而有效控制被破坏范围。<br>普通用户UID从1000开始，是由管理员创建的用于日常工作的用户。<br>为了方便管理同一组的用户，使用用户组号码GUD group Identification,把多个用户加入到一个组中，从而方便为组中的用户同一个规划权限或指派任务。<br>Linux系统中创建每个用户时，将创建一个与其同名的基本用户组，而且这个基本用户组，只有该用户一个人。<br>如果这个用户以后被归纳为其他用户组，则被称为拓展用户组。一个用户只有个一个基本用户组，但是可以有多个拓展用户组。    </p>
<h2 id="增加一个用户"><a href="#增加一个用户" class="headerlink" title="增加一个用户"></a>增加一个用户</h2><pre><code>useradd [选项] 用户名
</code></pre>
<p>创建用户，创建用户的默认目录是放在/home下面的看，默认Shell解释器是/bin/bash,而且默认创建一个与该用户同名的基本用户组。<br>-d 指定用户的家目录<br>-e 账户的到期时间 格式是 YYY-MM-DD<br>-u 指定该用户的默认UID<br>-g 指定一个初始的用户基本组<br>-G 指定一个或多个拓展基本组<br>-N 不创建同名的基本用户组<br>-s 指定用户的默认shell管理器   </p>
<p>/sbin/nologin是解释终端器的一员，和bash解释其不同，一旦用户的解释器是nlogin，则代表这个用户是不能登录到系统中的。   </p>
<h2 id="增加组"><a href="#增加组" class="headerlink" title="增加组"></a>增加组</h2><p>groupadd增加一个用户组 </p>
<pre><code>groupadd [选项] 群组名 
</code></pre>
<h2 id="修改用户属性"><a href="#修改用户属性" class="headerlink" title="修改用户属性"></a>修改用户属性</h2><pre><code>usermod [选项] 用户名
</code></pre>
<p>用户的信息保存在/etc/passwd<br>可以直接通过文本编辑器来修改用户参数选项。也可以通过usermod来改。<br>-e 账户的到期时间<br>-g 变更所属用户组<br>-G 变更拓展用户组<br>-L 锁定用户禁止其登录系统<br>-U 解锁用户 允许其登录系统<br>-s 变更默认终端<br>-u 修改用户的UID</p>
<pre><code>usermod -G root qhwno1
id qhwno1

usermod -u 8888 qhwno1
id qhwno1
</code></pre>
<h2 id="修改用户密码、过期时间、认证信息"><a href="#修改用户密码、过期时间、认证信息" class="headerlink" title="修改用户密码、过期时间、认证信息"></a>修改用户密码、过期时间、认证信息</h2><p>passwd命令来修改这些</p>
<pre><code>password [选项] 用户名
</code></pre>
<p>普通用户只能通过passwd来修改自身的系统密码， 而root管理员可以有权修改其他所有人的密码  root管理员在linux系统中修改自己或他人的密码不需要验证旧密码<br>-l 锁定用户禁止其登录<br>-u 解除锁定，允许用户登录<br>–stdin 允许通过标准输入修改用户密码<br>-d 使用户可以用空密码登录系统</p>
<pre><code>echo “andreiguo”|passwd --stdin Username


passwd qhwno1
</code></pre>
<h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><p>userdel </p>
<pre><code>userdel [选项] 用户名
</code></pre>
<p>在执行删除操作的时候，用户的家目录会默认保留下来，此时可以用 -r参数删除用户家目录<br>-f 强制删除用户<br>-r 删除用户和其家目录   </p>
<pre><code>userdel -r qhwno1  
</code></pre>
<h2 id="文件权限与归属"><a href="#文件权限与归属" class="headerlink" title="文件权限与归属"></a>文件权限与归属</h2><p>每个文件的类型不尽相同，因此Linux系统使用了不同的字符来加以区分，这个用ls命令展示全部的时候可以 第一个字符就是文件类型  </p>
<p>-：普通文件<br>d:目录文件<br>l：链接文件<br>b：块设备文件<br>c:字符设备文件<br>p：管道文件  </p>
<p>每个文件都有所属的所有者和所属组 ，并规定文件的所有者、所有组以及其他人对文件所拥有的可读（r）、可写（w）、可执行（x）等权限。<br>对于一般文件而言，可写表示能够编辑、新增、修改、删除文件的实际内容<br>可执行 表示能够运行一个脚本程序<br>对于目录文件而言，可读表示能够读取目录中的文件列表；可写表示能够在目录中新增、删除、重命名文件，而可执行则表示能够进入该目录。<br>读写执行的权限可以简写为 rwx，也可以用数字4、2、1来表示，文件权限的数字法表示基于字符表示rwx的权限计算而得来的数字。<br>比如一个文件权限是 7 意思是 4+2+1也就是有rwx权限  6 –&gt;  4+2 。一个文件的权限是764的意思就是文件所属者、文件所属组、其他用户的权限。也就是其他用户只有r的权力。6：的表示就是 rw-,4的表示： r–<br>，2的表示 -w-</p>
<h2 id="文件的特殊权限"><a href="#文件的特殊权限" class="headerlink" title="文件的特殊权限"></a>文件的特殊权限</h2><p>SUID、SGID、SBIT 特殊权限位 这是一种对文件权限进行设置的特殊功能。</p>
<h2 id="SUID"><a href="#SUID" class="headerlink" title="SUID"></a>SUID</h2><p>对二进制程序进行设置的特殊权限，可以让二进制程序的执行者临时拥有属主的权限。passwd命令就加入了默认的SUID的特殊权限为，因为所有用户都可以执行passwd来修改自己的密码，而密码保存在/etc/shadow文件里，查看这个文件的权限是 000，也就是只有root，这是一种，有条件的、零时的特殊权限授权方法。rwx变成了rws，x改变成s就意味这个文件被赋予了SUID权限。</p>
<h2 id="SGID"><a href="#SGID" class="headerlink" title="SGID"></a>SGID</h2><p>SGID两个主要功能：   </p>
<ol>
<li>让执行者临时拥有所属组的权限 </li>
<li>在某个目录上创建的文件自动继承该目录的用户组（只可以对目录操作）也就是不管什么用户在里面创建的文件自动继承该目录的用户组<br>ps命令里就含有SGID特殊权限位<br>主要是用chmod 和 chown<br>chmod命令是一个非常实用的命令，能够设置文件或者目录的权限 </li>
</ol>
<pre><code>chmod [参数] 权限 文件名或目录
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 760 test.txt</span><br></pre></td></tr></table></figure>
<p>chown设置文件或目录的所有者和所属组</p>
<pre><code>chown [参数] 所有者：所属组 文件或目录名称 
</code></pre>
<p>chmod和chown在修改目录的时候，如果要递归实现所有目录内的所有文件和嵌套目录的修改，需要使用参数 -R</p>
<pre><code>chown root：bin test.txt
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://andrekuu.github.io/2021/04/22/Linux/" data-id="cknscjo0p0003egve104fgidx" data-title="Linux" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Mysql基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/22/Mysql%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2021-04-21T19:45:49.000Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/22/Mysql%E5%9F%BA%E7%A1%80/">Mysql基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h2><p>数据库定义：<br>某种有组织的方式存储的数据集合，保存有组织的数据的容器<br>（区分QBMS 数据库管理系统）  </p>
<p>表的定义 ： 表是一种结构化文件，是某种特定类型数据的结构化清单。由行和列组成。<br>（不同类的数据类型不要放在同一个表中）<br>表名：具有唯一性（在同一个库里只能有一个表名的表即数据库.表名唯一）</p>
<p>模式： 关于数据库和表的分布以及特性的信息。  </p>
<p>列（column）：表中的一个字段。所有的表都是由一个或多个列组成的。每一列存储特定信息。  </p>
<p>数据类型（datatype）：所容许的数据的类型。  </p>
<p>行（row）：表中的一条记录。表的数据是按照行存储的。  </p>
<p>主键（primary key）： 一列（或一组列）其只能够唯一区分表中每一行。</p>
<p>【应该总是定义主键】<br>【主键有且不重复，不允许出现NULL值】<br>【主键的好习惯：1.不更新主键里的值；2.不在主键中使用未来可能会改变的值】</p>
<p>SQL定义：[ˈsiːkwəl] 结构化查询语句（structured query language）的缩写。是一种专门和数据库通行的语言。SQL语句部分通用，但是并不是完全可以移植的。  </p>
<h2 id="MYSQL简介"><a href="#MYSQL简介" class="headerlink" title="MYSQL简介"></a>MYSQL简介</h2><p>MYSQL定义： 一种数据库管理系统、数据库软件，DBMS。现在是甲骨文齐下的产品。<br>MYSQL优势：  </p>
<pre><code>1. 成本：Mysql是免费的，Mysql开放源代码
2. 性能：Mysql执行很快
3. 可信赖：是最受欢迎的关系型数据库
4. 简单：MySQL容易安装和使用  
</code></pre>
<p>DMBS分为两类：一种是基于共享文件系统的DBMS，另一种是客户机-服务器的DMBS（Mysql\oracle\sql server都是基于后者）。后者服务器部分是负责所有数据访问和处理的一个软件。这个软件运行在是成为数据库服务器的计算机上，与数据文件打交道的只有服务器。客户机和服务器可以装在一台计算机或者多台上，不管在不在同一台，都需要通过服务器软件和客户机软件通信。<br>MYSQL 在4版本引入InnoDB引擎，增加了事务处理这个功能。</p>
<p>MYSQL 工具：mysql命令行实用程序、mysql administrator、mysql navicat、mysql workbench</p>
<h2 id="使用MySQL"><a href="#使用MySQL" class="headerlink" title="使用MySQL"></a>使用MySQL</h2><p>客户机软件连接到MYSQL需要：  </p>
<pre><code>1. 主机名（计算机名）----- 如果连接到本地MySQL服务器 则为localhost  默认端口3306
2. 端口 port
3. 一个合法的用户名
4. 用户口令
</code></pre>
<p>选择数据库： use关键字  必须先use数据库，打开数据库，才能使用数据库</p>
<pre><code>USE database_name；
</code></pre>
<p>显示数据库/表: show关键字</p>
<pre><code>show databases;
show tables;
</code></pre>
<p>显示表内信息：show、describe关键字</p>
<pre><code>show columns from table_name;
describe table_name;
</code></pre>
<p>显示服务器状态：</p>
<pre><code>show status;
</code></pre>
<p>其他show语句：</p>
<pre><code>show create database database_name；
show create table table_name；
show grants;
show errors;
show warnings;
</code></pre>
<p>help 语句大大的棒棒~，可以显示show的用法和语法</p>
<pre><code>help 关键字；
help show;
</code></pre>
<h2 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h2><p>SQL语句不区分大小写。<br>SQL语句处理时，其中的空格被忽略。<br>检索行和列：</p>
<pre><code>select column_name1 as new_name,column_name2... from table_name;
select *from table_name;
</code></pre>
<p>去重distinct关键字，应用于select查询里的所有列</p>
<pre><code>select distinct column_name1,column_name2 from table_name;
</code></pre>
<p>[distinct 指定后面所有列必须都相同的数据才被去重]</p>
<p>limit (number) 指不多于 number行。 行数不够就显示能返回的那么多行。 limit n1, n2 == limit n2 offset n1  n1为起始行数，mysql里表从0行开始。  </p>
<p>完全限定的列名字：  </p>
<pre><code>table_name.column_name 
</code></pre>
<h2 id="检索排序"><a href="#检索排序" class="headerlink" title="检索排序"></a>检索排序</h2><p>允许使用非检索的列排序</p>
<p>检索默认升序 ASC，也可以改成 DESC降序 后面添加即可</p>
<pre><code>select * from table_name order by column_name DESC/ASC;
</code></pre>
<p>DESC/ASC只对直接位于其前面的列名起作用。对多个列依次排序应该按照排列优先级的顺序来排列order by后面的列，并用逗号隔开。至于大小写比较这些设计 字符集和校对顺序。</p>
<h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h2><p>SQL过滤和应用过滤：数据也可以在应用层过滤，但是缺点是：让用户机应用（或开发语言）处理数据库的工作将会极大的影响应用的性能，并且所创建的应用不具备可伸缩性。如果是客户机上过滤数据，服务器不得不通过网络发送多余数据，也将导致网络带宽的浪费。</p>
<p>order by group by 都得在where 字句后面。就是先过滤，在按要求整理数据排序和按组。</p>
<p>where子句操作符  不等于 &lt;&gt; ,!=两种都可<br>两只之间用between(包含两个端点）<br>where 执行匹配的时候，不区分大小写。<br>数值相比不需要单引号，字符串需要。<br>NULL 比较要 IS/IS NOT</p>
<pre><code>select  column_name from table_name where column_name is NULL;
</code></pre>
<p>逻辑操作符 AND OR ，和其他语言一样，在处理OR操作符之前优先处理AND</p>
<p>IN操作符 其实实现了or功能，而且比OR执行清单更快 ;IN最大特点是可以包含其他SELECT语句。</p>
<pre><code>select * from table_name where column_name in (value_1,value_2...)
</code></pre>
<p>关键字NOT</p>
<h2 id="用通配符进行过滤"><a href="#用通配符进行过滤" class="headerlink" title="用通配符进行过滤"></a>用通配符进行过滤</h2><p>通配符定义 ：用来匹配值的一部分的特殊字符<br>LIKE操作符<br>通配符% 表示任何字符出现任意次数(包括0次)（当然不能匹配NULL，like’%’也不行）</p>
<pre><code>like ‘q%’
</code></pre>
<p>注意提防尾部空格的字符，因为‘%character’如果他尾部跟了空格，则搜索不到。</p>
<p>下划线 _ 通配符：只匹配单个字符。不能不多也不能少。</p>
<p>通配符挺有用的，但是这种功能有很大的代价，就是处理要比别的搜索慢很多，所以推荐使用全文本搜索。</p>
<p>关于通配符的几个建议：</p>
<pre><code>1.不要过度使用通配符。其他操作符和语句能实现的功能，不用通配符。
2.如果必须要使用通配符，记得把他放在搜索模式的末尾处，让别的搜索先实现。
</code></pre>
<h2 id="用正则表达式进行搜索"><a href="#用正则表达式进行搜索" class="headerlink" title="用正则表达式进行搜索"></a>用正则表达式进行搜索</h2><p>正则表达式 是用来匹配文本的特殊的字符串。</p>
<p>regexp 取代like</p>
<p>‘.’是正则表达式里匹配人一个字符的</p>
<pre><code>SELECT column_name from table_name where column_name regexp &#39;.000haha&#39;;
</code></pre>
<p>此外注意：如果匹配字符串在列值内部，则like无法匹配（除非’%character%’），regexp可以实现(不需要通配符)。</p>
<p>regexp 正则表达式匹配默认不区分大小写 ，如果区分需要关键字BINARY</p>
<pre><code>SELECT column_name from table_name where column_name regexp BINARY &#39;JETPaCK .000&#39;;
</code></pre>
<p>regexp 里的OR 就是逻辑里的‘|’</p>
<pre><code>SELECT column_name from table_name where column_name regexp &#39;1000|2000&#39;;
</code></pre>
<p>regexp 里的IN 就是‘[]’</p>
<pre><code>SELECT column_name from table_name where column_name regexp &#39;[123]ton&#39;;
</code></pre>
<p>匹配含有’1ton’,’2ton’,’3ton’的<br>同时可以用 ‘-’来继续简化范围</p>
<pre><code>SELECT column_name from table_name where column_name regexp &#39;[1-9]ton&#39;;
</code></pre>
<p>同理[a-z]也可以实现</p>
<p>匹配特殊字符比如上面提到的‘.’’|’’[]’’-‘ 都需要转义符 \</p>
<pre><code>SELECT column_name from table_name where column_name regexp &#39;\\.&#39;;
SELECT column_name from table_name where column_name regexp &#39;\\\&#39;;
</code></pre>
<h3 id="重复元字符"><a href="#重复元字符" class="headerlink" title="重复元字符"></a>重复元字符</h3><pre><code>* 匹配0或多个 +  ？0或1个  &#123;n&#125; n个  &#123;n,&#125; &gt;=n个  &#123;n,m&#125; 
[:alnum:] 任意字母和数字

SELECT column_name from table_name where column_name regexp &#39;[0-9][0-9][0-9]&#39;;
SELECT column_name from table_name where column_name regexp &#39;[:alnum:]&#123;3&#125;&#39;;
</code></pre>
<h3 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h3><p>^ 文本的开始<br>$ 文本的结束</p>
<pre><code>SELECT column_name from table_name where column_name regexp &#39;^[0-9\\.]&#39;;
</code></pre>
<p>regexp检查总是返回 0（无匹配）或者 1（匹配）</p>
<h2 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h2><p>计算字段并不实际存在数据库表中，计算字段是运行select内产生的。<br>拼接字段<br>concat（）函数</p>
<pre><code>select concat(vend_name,&#39;(&#39;,vend_country,&#39;)&#39;) as total from vendors;
</code></pre>
<p>rtrim()函数去掉右边空格  Ltrim()去除左边空格   trim（）去除两边空格</p>
<pre><code>select concat(rtrim(vend_name),&#39;(&#39;,rtrim(vend_country),&#39;)&#39;) as total from vendors;
</code></pre>
<p>AS 关键字 跟别名，别名在客户机应用都可以按照别名来引用这个列，就想实际一个列一样，也可以省略as 直接跟别名。别名又是也称为导出列。</p>
<p>Now（）函数返回当前日期和时间</p>
<h2 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h2><p>MYSQL支持利用函数来处理数据。  </p>
<h3 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h3><p>Upper(column_name) lower() length()</p>
<h3 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h3><p>Date() 返回日期的日期那部分<br>Time() 返回日期的时间那部分<br>day()  返回日期的天数<br>Now()返回当前时期和时间<br>Year()<br>month()<br>adddate()增加一个日期<br>addtime()增加一个时间(时、分)<br>datediff() 计算两个日期的差 datediff(a-b) </p>
<pre><code>select adddate(date,interval 1 day) from test;
</code></pre>
<p>MYSQL日期格式：yyyy-mm-dd 2025-09-01</p>
<pre><code>select cust_id,cust_num from orders where date(order_date) = &#39;2009-01-01&#39;;
</code></pre>
<h3 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h3><p>Abs() 一个数的绝对值<br>Mod() 取模的余数<br>rand() 随机函数<br>sqrt() 平方根</p>
<h2 id="汇总函数"><a href="#汇总函数" class="headerlink" title="汇总函数"></a>汇总函数</h2><h3 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h3><p>AVG() COUNT() MAX() MIN() SUM()</p>
<p>AVG为了获得多个列的值需要使用多个AVG函数  AVG函数忽略NULL的列</p>
<pre><code>select (avg(column_name1)+avg(column_name2))/2 as avg_twocols from test 
</code></pre>
<p>count(*)不忽略NULL 但是count(column_name)忽略NULL</p>
<p>max、min、sum都自动忽略NULL值</p>
<p>sum（）可以计算多个列的值</p>
<pre><code>select sum(nums_col1 + nums_col2 + nums_col3*2) from test;
</code></pre>
<p>distinct 关键字的使用</p>
<pre><code>select avg(distinct column_name) from test;
</code></pre>
<h2 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h2><p>分组允许把数据分为多个逻辑组，并对每个组能实现聚集计算。</p>
<pre><code>select vend_id, count(*) as num_prods from product group by vend_id;
</code></pre>
<p>group by子句中重要规则：</p>
<pre><code>1.group by 子句可以包含任意数目的列。
2.如果再group by中嵌套了分组，数据在最后规定的分组内汇总。
3.group by 列出来的列 只能是有效列，不能是聚集函数。如果再select中使用表达式，则必须在group by 后面子句中指定相同的表达式，不能使用别名。
4.select 中除了聚合函数以外，各列必须在group by里给出。
5.NULL的行会被分到一组。
6.跟在where后面，order前面
</code></pre>
<p>使用with rullup 汇总:</p>
<pre><code>select vend_id,count(*) as num_prods from products group by vend_id with rollup;
</code></pre>
<h3 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h3><p>having过滤分组 where过滤行，基于分组实现的过滤条件，where实现不了。</p>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>查询 query  子查询 subquery定义：就是嵌套在其他查询里的查询。<br>SELECT 里的查询总是子查询总是从内向外处理。 格式化subquery，适当的缩进方便阅读和调试。<br>子查询的效率不高，最好避免，尤其避免多层嵌套子查询。<br>写子查询的查询语句的时候最好建立和测试最内层的查询，然后确认后嵌入子查询一层一层的给它穿衣服，同时检测和测试。</p>
<h2 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h2><p>SQL最强大的功能之一就是能在数据检索查询的执行中连联结 JOIN 表。  </p>
<p>关系表定义：关系表就是通过一些常用的值，也就是各个数据关系，来把信息分解成多个表，一类数据一个表。<br>外键foreign key 外键为某个表中的一列，包含另一个表的主键值，定义了两个表之间的关系。<br>关系型的数据可以有效和高效的处理和存储，是关系型数据库的可伸缩性要比非关系型数据库要好。<br>可伸缩性scale定义：能够适应不断增加的数据量而不失败。  </p>
<p>联结的定义： 联结是一种机制，用来在一条select 语句中关联不同表中的数据。联结由MYSQL根据需要存在，它存在于查询的执行之中。</p>
<p>创建联结：     </p>
<pre><code>select a.col1,b.col1
from a,b
where a.colx = b.coly;
</code></pre>
<p>或者通过内连接的表达形式实现：</p>
<pre><code>select a.col1,b.col1
from a INNER join b on (a.colx = b.coly);
</code></pre>
<p>推荐第二种形势 INNER JOIN 形势 因为更规范 而且<br>where子句在联结时是很重要的，因为Mysql不知道如何对这多张表进行联结，必须要人为确定各个表联结条件实现找到每个表的不同行正确联结起来。<br>如果不设定where条件，得到的则是笛卡尔积。检索出来的行数是第一个表的行数 m 和第二表的行数 n 的乘积 m*n。</p>
<p>多个表内连接 INNER JOIN 之间不需要加逗号,用where来联结多个表的时候，用and来实现。</p>
<pre><code>select a.col1,b.col1
from a INNER join b on (a.colx = b.coly)
        INNER JOIN c on (a.colx = c.colz);
</code></pre>
<p>也可以笛卡尔积联结就是 cross join   </p>
<p>MYSQL在运行关联指定的每个表处理联结是非常耗费资源的，所以不要连接不必要的表，越少越好。联结的越多，性能掉得越快。<br>查询的新能收到操作类型、表中数据量、是否存在索引或者键以及其他一些条件的影响。因此，有必要对不同选择机制进行实验来确定最适合具体情况的方法。联结是关系型数据库最有效最强大的特性。一般情况下，非关系型数据库的扩展性很强，选择关系型数据库一般对数据的一致性要求非常高的时候。   </p>
<h2 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h2><h3 id="使用表的别名"><a href="#使用表的别名" class="headerlink" title="使用表的别名"></a>使用表的别名</h3><p>注意：表别名只在查询执行中使用，和列别名可以返回客户机不同，表别名不返回客户机。  </p>
<h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>self join  </p>
<pre><code>select a.col1,a.col2
from table_name a ,table_name b
where a.colx = b.colx
</code></pre>
<p>或者自连接表达形式：</p>
<pre><code>select a.col1,a.col2
from table_name a join table_name b on (a.colx = b.colx);
</code></pre>
<p>优先考虑使用自联结而不是子查询，联结通常比子查询快得多。</p>
<h3 id="自然联结"><a href="#自然联结" class="headerlink" title="自然联结"></a>自然联结</h3><p>自然联结排除多次出现的结果，使得相同联结的列只返回一次。通过我们自己选择select 列的时候自己删掉就好了。   </p>
<pre><code>select c.* ,o.order_num,o.order_data,oi.prod_id,op.item_price
from customers c,orders o, orderitems oi
where c.cust_id = o.cust.id and oi.order_num = o.order_num and prod_id = &#39;FB&#39;;
</code></pre>
<h3 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h3><p>联结包含了哪些相关表中没有的行，这种类型的联结称为外部联结。 也就是会产生悬浮行。<br>OUTER JOIN  mysql没有外全连接。 LEFT JOIN ,RIGHT JOIN 。左外部联结可以通过颠倒FROM 或者where 子句中的数据表顺序转换为由外部联结。</p>
<h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><p>MYSQL允许多个select语句用union连接起来一并返回。这些组合查询通常称为 并（union）或者复合查询。<br>有两种情况我们经常用到union  </p>
<pre><code>1. 在单个查询中从不同表返回类似的结构的数据
2. 对单个表执行多个查询，按单个查询返回结果
</code></pre>
<p>记住大部分时候OR都不如union </p>
<pre><code>SELECT vend_id,prod_id,prod_price
from products
where prod_price &lt;=5
union
select vend_id,prod_id,prod_price
form products
where prod_id in (1001,1002);
</code></pre>
<p>union的规则：</p>
<pre><code>1. union中每个查询必须含有相同的列、表达式或聚合函数，不过各个列不需要相同顺序次序排列。 
2. 各个列数据类型必须兼容，类型不必完全相同，但必须是DBMS可以隐含转换类型。
</code></pre>
<p>union的特性：  会自动从结果集中去除重复行，和where子句一样。这是默认行为，也可以通过union all 来取代union实现匹配所有行，union all不去重。<br>union结果排序的时候只能用一条order by 子句，必须在最后一个select 语句之后。</p>
<h2 id="全文本搜索"><a href="#全文本搜索" class="headerlink" title="全文本搜索"></a>全文本搜索</h2><p>全文本搜索是一种高级的数据查询和选择方式。</p>
<p>并非所有引擎都支持全文本搜索。MYISAM支持，INNODB不支持。<br>基于like关键字和基于文本搜索的regexp正则表达式的搜索机制非常有用 但是：</p>
<pre><code>1. 性能： 通配符和正则表达式通常要求MYSQL尝试匹配表中的所有行，而且这些搜索极少使用表索引。
2. 明确控制：使用通配符和正则表达式匹配很难明确控制匹配什么不匹配什么。
3. 智能化的结果：他们无法提供智能化的选择结果的方法。
</code></pre>
<p>优势：在使用全文本搜索时，mysql不需要分别查看每个行，不需要分别分析和处理每个词，mysql创建指定列中各词的一个索引，搜索可以针对这些词进行。mysql可以快速有效的决定那些词匹配那些词不匹配以及他们匹配的频率。 </p>
<h3 id="使用全文本搜索"><a href="#使用全文本搜索" class="headerlink" title="使用全文本搜索"></a>使用全文本搜索</h3><p>为了进行全文搜素，必须对被搜索的列进行索引，而且要随着数据的改变不断地重新索引。在索引以后，可以用MATCH()、Against()执行搜索。</p>
<h4 id="启用全文本搜索"><a href="#启用全文本搜索" class="headerlink" title="启用全文本搜索"></a>启用全文本搜索</h4><p>创建表时启用全文本搜索，CREATE TABLE语句，接受FULLTEXT子句，他给出一个被索引列的一个逗号分隔的列表。  </p>
<pre><code>CREATE TABLE TEST
( note_id int not NULL AUTO_INCREMENT,
  prod_id char(10) NOT NULL ,
  note_text text NULL,
  primary key(note_id),
  FUllTEXT(note_text)
)ENGINE = MYISAM;
</code></pre>
<p>MYSQL会根据子句FULLTEXT(note_text)来对它进行索引。在定义以后，MYSQL会自动维护该索引。在增加更新或删除行时，索引随之自动更新。</p>
<p>TIPS: 不要在导入数据时使用FULLTEXT，更新索引需要花一定的时间，虽然不多，如果再导入数据到一个新表，此时不应该启用FULLTEXT索引。应该先导入所有输入，然后再修改表，定义FULLTEXT。这样有助于更快的导入数据，而且索引数据的总时间小于导入每行分别进行索引的总时间。  </p>
<h4 id="进行全文本搜索"><a href="#进行全文本搜索" class="headerlink" title="进行全文本搜索"></a>进行全文本搜索</h4><p>在索引之后，使用两个函数MATCH()和Against()执行全文本搜索牟其中MATCH()指定被搜索的列，Against()指定要使用的搜索表达式。</p>
<pre><code>select note_text
from table_name
where MATCH(note_text) Against(&#39;rabbit&#39;);
</code></pre>
<p>MATCH()的值必须和FULLTEXT定义中的相同，如果指定多个列，则必须列出他们，并且要求次序正确。<br>这里的检索和正则表达式一样，除非关键字 BINARY 否则不区分大小写。  </p>
<p>全文本搜索返回的结果还是按照文本匹配良好程度顺序返回的。具有更高等级的行先返回。  </p>
<p>MATCH(col_name) AGAINST(‘str’) 其实是一个计算列，如果匹配会算出一个大于0的匹配度级别，不匹配时就是0，所以where其实就是判断真伪。这个等级值根据词的数目、唯一词的数目、整个索引中词的总数以及包含该词的行的数目计算出来。</p>
<p>由于数据是索引的，所以全文本搜索是相当快。</p>
<h4 id="使用查询扩展"><a href="#使用查询扩展" class="headerlink" title="使用查询扩展"></a>使用查询扩展</h4><p>查询扩展用来设法放宽所返回的全文本搜索结果的范围。使用查询扩展时，MYSQL对数据和索引进行了两边扫描来完成搜索：</p>
<pre><code>1. 先是一个基本的全文本搜索与搜索条件匹配的行。
2. 其次MYSQL检查这些匹配行并进行选择所有有用词。
3. 再其次MYSQL会再次进行全文本搜索，扩大原来的条件，包含这些筛选出来的有用词。 
</code></pre>
<p>查询扩展只适用于 4.1 以上版本  </p>
<h3 id="布尔文本搜索"><a href="#布尔文本搜索" class="headerlink" title="布尔文本搜索"></a>布尔文本搜索</h3><p>MYSQL支持全文本搜索的另外一种方式：布尔方式 BOOLEAN mode，在即使没有FULLTEXT索引也可以使用  但是这是一种非常缓慢地操作。 </p>
<pre><code>select note_text
from table_name
where MATCH(note_text) Against(&#39;rabbit&#39; in BOOLEAN MODE);


select note_text
from table_name
where MATCH(note_text) Against(&#39;rabbit - rope*&#39; in BOOLEAN MODE);
</code></pre>
<p>全文本boolean mode 操作符：</p>
<pre><code>+  包含 词必须存在
-  排除 词必须不出现
&gt;  包含 而且增加等级值
&lt;  包含 而且减少等级值
~  取消一个词的排序值
*  词尾的通配符
&quot;&quot; 定义一个短语整体

select note_text
from table_name
where MATCH(note_text) Against(&#39;+rabbit + bait&#39; in BOOLEAN MODE); -- 包含两者才算匹配

select note_text
from table_name
where MATCH(note_text) Against(&#39;rabbit  bait&#39; in BOOLEAN MODE); -- 包含其中一个词就可

select note_text
from table_name
where MATCH(note_text) Against(&#39;“rabbit bait&quot;&#39; in BOOLEAN MODE); -- 包含这个不可分割的短语

select note_text
from table_name
where MATCH(note_text) Against(&#39;+rabbit  +（&lt;bait)&#39; in BOOLEAN MODE); -- 必须包含两个而且降低bait的等级
</code></pre>
<p>布尔方式中，只排列结果，不排序。</p>
<h3 id="全文本搜索的注意事项"><a href="#全文本搜索的注意事项" class="headerlink" title="全文本搜索的注意事项"></a>全文本搜索的注意事项</h3><pre><code>1. 短词被忽略且从索引中排除。短词定义为哪些具有3个或者3个一下字符的词。
2. MYSQL内建的非用词 stopword 这些词在索引全文本搜索时总是被忽略。
3. MYSQL规定50%规则，一个词出现频率超过50% 也被视作非用词。但BOOLEAN MODE不这样。
4. 表中行数少于3行，则全文本搜索不反悔结果。
5. 忽略词中的单引号。don&#39;t的索引 dont
6. 尽在MYISAM中引擎支持全文本搜索。
7. 不具备词分隔符的语言（日语、汉语），不能恰当返回全文本搜索结果。
</code></pre>
<h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>插入数据设计系统安全，可对每个表和用户设置插入权限。  </p>
<pre><code>INSERT INTO table_name values(val1,val2,...);--数值不用‘’ 字符串需要 同时需要对应列排序不然会插入出错。
INSERT INTO table_name(col1,col2,...) values(val1,val2,...);
</code></pre>
<p>插入自动增加的列时只需要插入NULL就行了 不需要插入就是。但是要写！！！ </p>
<p>第二种方式比第一种方式安全，因为表变化也不影响插入安全。一般不要使用没有给出明确列的插入语句。</p>
<p>‘’’<br>提高整体性能：数据库经常被多个客户访问，对处理什么请求以及什么次序处理，是管理MYSQL的重要任务，INSERT操作可能很耗时，特别是有很多索引要更新的时候骂他可能会降低等待处理的select语句的性能，如果数据检索是最重要的，可以通过insert into中间插入关键字，LOW_PRIORITY 来降低insert插入优先级。 </p>
<pre><code>INSERT LOW_PRIORITY INTO 
</code></pre>
<p>这个思考也适用于DELETE 和 UPDATE<br>‘’’</p>
<h3 id="插入多行"><a href="#插入多行" class="headerlink" title="插入多行"></a>插入多行</h3><p>就像python的元组一样 给个括号就完事了</p>
<pre><code>INSERT INTO customers(cust_name,cust_city) values(&#39;andre&#39;,&#39;nanjing&#39;),(&#39;andrew&#39;,&#39;shenzhen&#39;);
</code></pre>
<p>建议多使用这种复合插入语句实现多条插入，这样可以提高INSERT性能。</p>
<h3 id="插入检索出的数据"><a href="#插入检索出的数据" class="headerlink" title="插入检索出的数据"></a>插入检索出的数据</h3><p>说白了就是子查询</p>
<pre><code>INSERT INTO table_name(col1,col2,...) select colx,coly,... from table_name2;
</code></pre>
<p>插入检索出的数据主要和位置一一对应实现。</p>
<h2 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h2><p>update和delete一定要仔细和细心，where子句一定要好好写，千万别省略了不然更新表中所有行。</p>
<h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><pre><code>update table_name set col1 = val1 , col2 = val2 where condition1 and/or condition2;
</code></pre>
<p>IGNORE关键字： 使用UPDATE语句更新多行的时候，出现一个错误则整个UPDATE操作会被取消，IGNORE可以使得发生错误也可以继续进行更新。IGNORE 跟在update后面就好了</p>
<pre><code>update IGNORE table_name...
</code></pre>
<p>= NULL ：update set 利用 =NULL 实现单元格删除</p>
<pre><code>update table_name set column1 = NULL where colx = val1;
</code></pre>
<h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><pre><code>DELETE FROM table_name where condition1;
</code></pre>
<p>如果想更快的葱表中删除所用行，可以用TRUNCATE table_name；本质是删除原来这张表然后重建一个同名表。</p>
<p>一些关于更新、删除的TIPS:</p>
<pre><code>1. 主键在更新删除中非常重要；
2. 在更、删之前 应该用select语句先测试过滤条件，保证where正确性。
3. 在强制实施应用完整性的数据库，MYSQL不允许删除具有与其他表相关关联的数据的行。
</code></pre>
<h2 id="创建和操作表"><a href="#创建和操作表" class="headerlink" title="创建和操作表"></a>创建和操作表</h2><pre><code>create table table_name(
cust_id int NOT NULL AUTO_INCREMENT,
cust_city char(50) NOT NULL,
cust_email char(50) NULL,
primary key (cust_id)
)engine = INNODB;
</code></pre>
<p>创建的表名在同一个库里不得重复 否则报错。如果你想创建一个在它不存在时候才创建，则是在表名后面加上IF NOT EXISTS：</p>
<pre><code>create table table_name IF NOT EXISTS(
cust_id int NOT NULL AUTO_INCREMENT,
cust_city char(50) NOT NULL,
cust_email char(50) NULL,
primary key (cust_id)
)engine = INNODB;
</code></pre>
<p>default 是NOT NULL的是不接受插入和更新行时没有值的，必须得有，除非AUTO_INCREMENT。</p>
<p>！！！记住 NULL是空值 和空串是不等价的，’’（在python里空串里面没有空格 是等价NONE的 这里和NULL是不等价的）<br>主键是必须NOT NULL的。</p>
<p>AUTO_INCREMENT指本列每增加一行时，比如每次insert 自动对该列增量。每个表必须最多只有一个AUTO_INCREMENT，而且他必须被索引，比如通过使他成为主键。</p>
<p>AUTO_INCREMENT 可以被覆盖，当insert插入的时候这一列有值插入进来，而且没有被用过，那么这个值覆盖自动增量值，而且后续从这个值开始急需增量。 </p>
<p>如何确定最后AUTO_INCREMENT的列的值呢，可以用last_insert——id()来实现</p>
<p>插入的时候如果没有给定值，则使用default 默认值，但是MYSQL只支持敞亮，不支持函数作为默认值。</p>
<h3 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h3><p>MYSQL有一个具体管理和处理数据内部的内部引擎，该引擎具体创建表，支持你的各种从数据库处理操作和请求。</p>
<pre><code>1. InnoDB是个可靠地事务处理引擎，但是不支持全文本搜索；
2. MEMORY 在功能上等同于MYISAM但是由于数据存储在内存（不是磁盘），所以速度非常快，适用于临时表。
3. MYISAM是一个性能极高的引擎，支持全文本搜索，但是不支持事务处理。
</code></pre>
<p>引擎类型可以混用。但是外键不能跨引擎，外键是用来强制应用完整性的，不能跨引擎，就是使用一个引擎的表不能引用两一个具有使用不同引擎的表的外键。</p>
<h3 id="更新表"><a href="#更新表" class="headerlink" title="更新表"></a>更新表</h3><pre><code>alter table table_name change col_name col_newname newtype newdefault;
</code></pre>
<p>增加列/删除咧：</p>
<pre><code>alter table table_name add col_name type default;
alter table table_name drop col_name;
</code></pre>
<p>定义外键：</p>
<pre><code>alter table orderitems
add constraint fk_orders 
foreign key (ord_num) references orders(ord_num);
</code></pre>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><pre><code>drop table table_name;
</code></pre>
<h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><pre><code>rename table table_name to table_newname;
alter table table_name rename table_newname;
</code></pre>
<h2 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h2><p>视图： 是虚拟的表，与包含数据的表不同，视图只包含使用时动态检索数据的查询。<br>作为视图，他不包含表中应该有的任何列和数据, 它包含的是一个SQL查询。</p>
<p>为什么使用视图：</p>
<ul>
<li>重用SQL语句</li>
<li>简化复杂的SQL操作。在编写查询后，可以方便的重用它们，而不需要知道它的查询细节。</li>
<li>使用表的组成部分而不是整个表</li>
<li>保护数据。可以赋予用户标的特定部分的访问权限而不是整个表的访问权限。</li>
<li>更改数据格式和表示。视图可以返回与底层表的表示和格式不同的数据。</li>
</ul>
<p>视图创建完成后，可以用与表基本相同的方式利用他们，甚至能添加和更新数据。<br>视图仅仅用来查看存储在别处的数据的一种设施，视图本身不包含数据，他们返回数据是从别的表中检索出来的，在添加和更改这些表中数据时，视图将返回改变过的数据。<br>因为视图本身不包含数据，所以每次使用视图的时候，都要处理查询执行时所需的任一个检索，如果用多个联结和过滤条件创建了复杂的视图或者嵌套了视图，可能会发现性能下降的很厉害。    </p>
<h3 id="视图规则："><a href="#视图规则：" class="headerlink" title="视图规则："></a>视图规则：</h3><ul>
<li>视图也需要唯一命名</li>
<li>对于可以创建的视图数目没有限制</li>
<li>创建视图也需要创建视图的访问权限</li>
<li>视图可以嵌套</li>
<li>视图里也可以使用order by</li>
<li>视图不能索引，也没有触发器和默认值</li>
<li>视图可以与表一起使用</li>
</ul>
<h3 id="使用视图-1"><a href="#使用视图-1" class="headerlink" title="使用视图"></a>使用视图</h3><p>创建视图create view view_name as select 语句删除视图DROP view view_name，更新视图是先用drop删除，在CREATE一个，或者直接用create or replace view view_name。如果要更新的视图不存在，这个语句会创建一个视图。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW productcustomers AS</span><br><span class="line">select cust_name,cust_contact,prod_id</span><br><span class="line">from customers,orders,orderitems</span><br><span class="line">where customers.cust_id &#x3D; orders.cust_id</span><br><span class="line">and orderitems.order_num &#x3D; orders.order_num</span><br></pre></td></tr></table></figure>

<p>MYSQL实际处理次查询的时候，会把指定的WHERE子句添加到试图查询中已有的WHERE子句中，以便正确过滤数据。</p>
<h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>视图本身是没有数据的，所以每次对视图增加或者删除行，实际上是对其基表增加或删除行。但并非是所有视图都是可以更新的。如果视图定义中有一下操作，则不能对视图进行更新：</p>
<ul>
<li>分组 使用GROUP BY 和 HAVING</li>
<li>联结</li>
<li>子查询</li>
<li>并</li>
<li>聚集函数（MAX\MIN\COUNT\SUM）</li>
<li>DISTINCT</li>
<li>导出（计算列）</li>
</ul>
<p>因为视图主要功能是检索数据的。</p>
<h2 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h2><p>大多数SQL语句都是针对一个或者多个表的单条操作，但是并非所有操作都是这么简单，经常有一个完整的操作需要多条语句才能完成。</p>
<p>存储过程简单的说 就是为了以后使用而保存的一条或者多条SQL语句的集合。可以将其视为批文件，虽然他们不仅限于批处理。   </p>
<h3 id="使用存储过程的优点："><a href="#使用存储过程的优点：" class="headerlink" title="使用存储过程的优点："></a>使用存储过程的优点：</h3><ul>
<li>通过把处理封装在容易使用的单元中，简化了复杂的操作</li>
<li>保护数据的完整性，防止犯错。</li>
<li>简化对变动的管理。如果表名、列名或者业务逻辑发生改变，只需要更改存储过程的代码。</li>
<li>提高安全性，通过存储过程的限制对基础数据的访问。</li>
<li>提高性能，使用存储过程比单独使用SQL语句要快。</li>
</ul>
<p>简单说就是 简单、安全、高性能。创建存储过程也需要权限。</p>
<h3 id="存储过程的使用"><a href="#存储过程的使用" class="headerlink" title="存储过程的使用"></a>存储过程的使用</h3><p>MySQL存储过程的执行为调用，用CALL </p>
<pre><code>CALL PROCEDURE_NAME();
CALL PROCEDURE_NAME(@variable_name,@variable_name2)
</code></pre>
<p>用create procedure procedure_name() begin SQL语句 ； end;实现    如果存储过程中接收参数，他们将在（）里列举出来。<br>MYSQL命令行中创建需要先，DELIMITER 来更改分隔符，如果命令行实用程序要解释存储过程自身内的；字符，则他不会最终成为存储过程的成分，这会使得报错语法错误。</p>
<pre><code>DELIMITER //
CREATE PROCEDURE productpricing()
BEGIN
    select AVG(PRO_PRICE) as priceaverage
    FROM products;
END //
DELIMITER ;
</code></pre>
<p>delimiter 告诉命令行是用实用程序用// 做为新的分割符号。也可以用别的。<br>存储过程实际上是一种函数，所以存储过程名需要有()符号，即使不传递参数也需要。<br>删除存储过程用DROP     </p>
<pre><code>DROP PROCEDURE procedure_name；
DROP PROCEDUER IF EXISTS procedure_name;
</code></pre>
<h3 id="变量-variable"><a href="#变量-variable" class="headerlink" title="变量 variable"></a>变量 variable</h3><p>变量定义：变量是内存中的一个特定位置，用来临时存储数据。<br>可以用</p>
<pre><code>SET @variable_name = value;
</code></pre>
<p>来实现赋值</p>
<pre><code>select value into @variable_name;
</code></pre>
<p>这样也可  </p>
<p>创建时用out指出响应的参数用来从存储过程中传出的值，返回。用IN传递给存储过程。用INOUT类型的参数来传入传出。<br>返回集是不被允许的，不能够通过一个参数返回多个行和列。只能有多个参数来返回一个行。</p>
<pre><code>CREATE procedure productingpricing(
out p1 decimal(8,2),
out ph decimal(8,2))
begin
    select MIN(prod_price) into p1 from products;
    select max(prod_price) into ph from products;
END;

CALL productingpricing(@pricelow,@pricehigh);
select @pricelow, @pricehigh;
</code></pre>
<p>所有变量必须要@开头</p>
<pre><code>CREATE procedure ordertotal(
IN onumber INT,
out ototal DECIMAL(8,2)
)
begin
    select SUM(item_price*quantity)
    from orderitems
    where order_num = onumber
    INTO orotal;
END;
</code></pre>
<p>存储过程内注释使用 前置 –<br>用DECLARE 语句定义两个局部变量  DECLATE要求指定变量名和数据类型，也支持默认值。 </p>
<pre><code>declare taxrate int default 6;
</code></pre>
<p>IF 语句<br>    IF taxable THEN<br>        select total + (total/100*TAXRATE) into total ;<br>    end IF;    </p>
<h3 id="检查存储过程"><a href="#检查存储过程" class="headerlink" title="检查存储过程"></a>检查存储过程</h3><pre><code>show create procedure ordertotal;

show procedure status;
</code></pre>
<p>COMMENT 关键字用来给show procedure status的结果中显示。</p>
<h2 id="使用游标CURSOR"><a href="#使用游标CURSOR" class="headerlink" title="使用游标CURSOR"></a>使用游标CURSOR</h2><p>MYSQL5增加了游标功能<br>MYSQL检索操作返回一组称为结果集的行，需要在检索出来的行中前进或后退一行或多行，是使用游标的原因。游标是一个存储在MYSQL服务器上的数据库查询，她不是一个select语句，而是该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据。游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或作出更改。</p>
<p>游标主要用于交互式应用，其中用户需要滚动屏幕上的数据，并对数据进行浏览或作出更改。只能用于存储过程，MYSQL的游标只能用于存储过程或函数。 </p>
<p>在游标能使用前，必须声明它，这个过程实际上没有检索数据。只是定义使用的select语句而已。一旦声明后，必须打开游标以供使用。在结束游标使用时候，必须关闭游标。</p>
<h3 id="创建游标"><a href="#创建游标" class="headerlink" title="创建游标"></a>创建游标</h3><p>游标用declare for 语句创建</p>
<pre><code>CREATE procedure processorders()
begin 
    declare ordernumbers cursor
    for 
    select order_num from orders;
end;
</code></pre>
<p>打开游标：</p>
<pre><code>open ordernumbers;
</code></pre>
<p>关闭游标：</p>
<pre><code>close ordernumbers;
</code></pre>
<p>close 释放游标所有使用的内部资源和内存，因此每个游标如果不用了就要关闭。</p>
<p>如果你不明确关闭游标，mysql会在到达end语句后自动关闭它。</p>
<pre><code>CREATE procedure processorders()
begin 
    declare ordernumbers cursor
    for 
    select order_num from orders;
    open ordernumbers;

    close ordernumbers;
end;
</code></pre>
<p>在一个游标打开后，可以使用FETCH语句分别访问它的每一行，FETCH指定检索什么数据，检索出来的数据存储在什么地方。他还自动向前移动游标中的内部行指针，使得吓一跳FETCH语句检索下一行。</p>
<pre><code>CREATE procedure processorders()
begin 
    declare ordernumbers cursor
    for 
    select order_num from orders;
    open ordernumbers;
    FETCH ordernumbers into o; 

    close ordernumbers;
end;
</code></pre>
<p>declare 语句发布的时候存在特定的次序，用declare语句定义的局部变量必须在定义任意游标或者句柄之前定义，而句柄必须在游标之后定义。</p>
<p>除了repeat语句，MYSQL还支持循环语句，可以用来重复执行代码，直到使用leave语句手动退出为止。通常repeat语句的语法使他更适合用于对游标的循环。</p>
<h2 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h2><p>如果你需要某条语句在事件发生的时候自动执行。就需要触发器。<br>触发器定义： 是MYSQL相应DELETE\INSERT\UPDATE语句执行的一条MYSQL语句（或者位于begin end之间的一组一句）。（即表结构发生变化的时候自动触发执行的一组MYSQL语句）其他MYSQL语句不支持触发器。 </p>
<h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><ul>
<li>唯一触发器名</li>
<li>触发器关联的表</li>
<li>触发器应该相应的活动（delete、update）</li>
<li>触发器何时执行</li>
</ul>
<p>触发器名必须在每个表唯一，但不必在数据库唯一。</p>
<pre><code>CREATE TRIGGER newproduct after insert on products
for each row select &#39;product added&#39;;
</code></pre>
<p>只有表才支持触发器，视图和临时表都不支持。触发器按照每个表每个事件定义，每个表事件每次只允许一个触发器，所以一个表最多有6个触发器。单一触发器不能与多个事件或者多个表关联。</p>
<p>删除触发器</p>
<pre><code>drop trigger trigger_name;
</code></pre>
<p>触发器无法更新 只能删除重造。</p>
<h3 id="使用触发器-1"><a href="#使用触发器-1" class="headerlink" title="使用触发器"></a>使用触发器</h3><p>INsert 触发器：</p>
<ul>
<li>在INSERT触发器代码内，可以应用一个名为new的虚拟表，访问被插入的行；</li>
<li>在before insert触发器中，new得知可以被更新（允许更改被插入的值）</li>
<li>对于AUTO_increment列，new在insert执行之前包含0，在insert执行之后包含新的自动生成的值。</li>
</ul>
<p>当前版本不允许触发器返回任何结果，所以必须要用into @变量名</p>
<pre><code>create trigger trigger_name after insert on table_name
for each row select new.column_name1,new.column_name2 into @various_name1,@various_name2;
</code></pre>
<p>DELETE触发器：<br>-在DELETE触发器内可以引用一个叫OLD的虚拟表，访问被删除的行，OLD中的值全都是只读的，不能更新。</p>
<pre><code>create trigger deletedorder before delete on orders
for each row 
begin
    insert into archive_orders(order_num,order_date,cust_id)
    values(old.order_num,old.order_date,old.cust_id);
end;
</code></pre>
<p>尽量使用before delete触发器，因为befor delete触发的有点：由于某种原因，如果不能存档，则delete本身会被放弃。</p>
<p>update触发器：</p>
<ul>
<li>在update触发器代码中，可以引用一个名为old的虚拟表访问之前的值，引用一个名为new的虚拟表访问更新的值。</li>
<li>before update触发器，new中的值可能也会被更新</li>
<li>old中的值都是只读的，不可以更新</li>
</ul>
<p>显然任何数据净化都需要update之前进行。</p>
<p>创建触发器的可能需要特护的安全访问权限，但是触发器执行是自动的。如果insert\delete\update能执行，则相关触发器也可以执行。</p>
<p>触发器可以很好地保证数据一致性（数据大小写、格式），他总是自动执行而且与客户机无关。</p>
<p>触发器的一种非常有意义的使用是创建审计跟踪，使用触发器，把更改（如果需要还有之前之后的状态）记录到另一个表中很方便。</p>
<p>但是触发器不支持call  所以触发器内部不能调用存储过程。</p>
<h2 id="管理事务处理"><a href="#管理事务处理" class="headerlink" title="管理事务处理"></a>管理事务处理</h2><p>并非所有引擎都支持事务处理，MYISAM不支持，INNODB支持。</p>
<p>事务处理transaction processing 可以用来维护数据库的完整性，他保证成批的Mysql操作要么完全执行，要么完全不执行。</p>
<p>事务处理是一种机制，用来管理必须成批执行的MYSQL操作，以保证数据库不包含不完整的操作结果。利用事务处理，可以保证一组操作不会中途停止，要么全部执行要么，完全不执行。如果没有错误发生，整租语句提交到（写到）数据库表。如果发生错误则进行回退（撤销）已恢复数据库到某种安全的状态。</p>
<ul>
<li>事务 transaction 指一组SQL语句</li>
<li>回退 rollback  只撤销指定sql语句</li>
<li>提交 commit 制将未存储的SQL语句写入数据库表中</li>
<li>保留点 savepoint 知事务处理中设置的临时占位符，你可以对他发布回退</li>
</ul>
<p>控制事务处理：<br>管理事务处理的关键在于酱SQL与剧组分解为逻辑块，并且明确规定数据何时应该回退，何时不应该回退。</p>
<pre><code>start transaction;
delete from ordertotals;
rollback;
</code></pre>
<p>rollback回退到start transaction时的数据库表状态，并同时关闭了事务，要是需要再次使用需要再次start。rollback只能在一个事务处理内使用。</p>
<p>事务处理用来管理INSERT\UPDATA\DELETE语句，但是不能回退create\DROP操作 事务处理块有则撤销不掉。</p>
<h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p>一般MYSQL都是硬汉提交的，提交写入保存操作是自动执行的，但是在事务处理块中，提交不会隐含的进行，为进行明确的提交，使用commit语句</p>
<pre><code>start transaction;
delete from ordertotals;
delete from orderprice;
commit;
</code></pre>
<p>因为事务处理块中，提交不会隐含提交，最后commit提交，sql语句块，当语句块内出现错误时，则全部撤销，如果没有错误就写入。<br>commit 和rollback后则会自动关闭事务transaction</p>
<h3 id="使用保留点"><a href="#使用保留点" class="headerlink" title="使用保留点"></a>使用保留点</h3><p>为了支持回退部分事务处理，必须能在事务处理块中合适位置放置占位符，如果要回退，则回退到某个占位符。<br>这些占位符成为保留点，可以用savepoint创建占位符。</p>
<pre><code>SAVEPOINT DELETE1;
</code></pre>
<p>保留点也要唯一取名。倒退的时候用rollback to</p>
<pre><code>ROLLBACK TO DELETE1;
</code></pre>
<p>保留点越多越好。保留点在事务处理完后自动释放。也可以用 release savepoint；</p>
<h3 id="更改默认提交行为"><a href="#更改默认提交行为" class="headerlink" title="更改默认提交行为"></a>更改默认提交行为</h3><pre><code>SET autocommit = 0;
</code></pre>
<p>autocommit 标志决定是否自动提交更改，不管有没有commit语句。</p>
<p>autocommit标志是针对每个连接而不是服务器的~！！！</p>
<h2 id="本地化-全球化"><a href="#本地化-全球化" class="headerlink" title="本地化 全球化"></a>本地化 全球化</h2><h3 id="字符集-和校对顺序"><a href="#字符集-和校对顺序" class="headerlink" title="字符集 和校对顺序"></a>字符集 和校对顺序</h3><p>名词定义：</p>
<ul>
<li>字符集： 字母和符号的集合</li>
<li>编码： 为某个字符集成员的内部表示</li>
<li>校对：未规定字符如何比较的指令</li>
<li>不同的语言和字符集需要不同的方式存储和检索。</li>
</ul>
<p>显示所有字符集和默认校对：</p>
<pre><code>show character set;
</code></pre>
<p>显示所有可用校对</p>
<pre><code>show collation；
</code></pre>
<p>一般区分大小写是_cs 不区分则  _ci<br>字符集很少是服务器范围的，不同表甚至不同列都是不同的字符集，而且两者可以在创建表的时候可以规定。</p>
<pre><code>create table mytable
(
    column1 int,
    column2 varchar(10)
)default character set hebrew
collate hebrew_general_ci;
</code></pre>
<p>如果只执行character则使用默认校对顺序。</p>
<p>可以对指定列特别规定：</p>
<pre><code>create table mytable
(
    column1 int,
    column2 varchar(10)，
    column2 varchar(10) character set latin 
)default character set hebrew
collate hebrew_general_ci;
</code></pre>
<p>校对对order by至关重要，如果你要按照和创建表不同的校对顺序实现也可以在select 语句内实现</p>
<pre><code>select * from customers
order by lastname,firstname collate latin_general_cs;
</code></pre>
<p>字符集可以应用很广泛，在group，having,聚集函数和别名都可以用到。</p>
<h2 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h2><p>利用访问控制 访问控制和用户权限管理 </p>
<p>MYSQL服务器的安全基础：用户应该对他们需要的数据具有适当的访问权既不能多，也不能少。</p>
<p>访问控制：定义：  就是给用户提供他们所需要的访问权限，但是也仅仅提供他们所需的访问权。</p>
<p>现实生活中，日常工作不应该使用root，应该创建一系列账号，有的用于管理有的用于用户使用，有的供开发人员使用。</p>
<p>访问控制的必要性：1.防止用户恶意企图；2.防止数据梦魇，防止无意识错误。</p>
<p>除非必要不要使用root。</p>
<h3 id="管理用户"><a href="#管理用户" class="headerlink" title="管理用户"></a>管理用户</h3><p>mysql内有一个表user 装所有用户的，内有个user列包含所有用户名。</p>
<p>创建一个用户账号：</p>
<pre><code>CREATE user ben identified by &#39;password&#39;;
</code></pre>
<p>也可以用grant来创建用户</p>
<p>也可以用在表user里插入行来实现，不过这样不安全，mysql用来存储用户账号信息的表，极为重要。</p>
<p>重命名一个用户</p>
<pre><code>rename user user_name ti user_newname；
</code></pre>
<p>删除用户账号</p>
<pre><code>DROP USER user_name:
</code></pre>
<p>旧版本mysql需要先用revoke解除与账号相关的权限，然后再用drop user；</p>
<h3 id="设置访问权限"><a href="#设置访问权限" class="headerlink" title="设置访问权限"></a>设置访问权限</h3><p>为了看到赋予用户账号的权限 需要用show grants for user_name;</p>
<pre><code>show grants for user_name;
</code></pre>
<p>MYSQL的权限用用户名@主机名的方式结合定义，user@host 如果不加指定主机名，则使用默认主机名。</p>
<p>设置权限用到GRANT关键字，需要以下信息：</p>
<ul>
<li>要授予的权限</li>
<li>被授予访问权限的数据库或者表格</li>
<li>用户名</li>
</ul>
<pre><code>GRANT SELECT ON database_name.table_name to user_name;
</code></pre>
<p>grant的反操作是revoke</p>
<pre><code>revoke SELECT ON database_name.table_name from user_name;
</code></pre>
<p>常用几个表示：</p>
<ul>
<li>所有操作 grant/revoke all on….</li>
<li>整个数据库 on database_name.* </li>
</ul>
<p>使用grant 和 revoke的时候用户账号必须存在，但是表和数据库可以不存在，这允许管理员在创建数据库和标志前设计和实现安全措施。副作用是如果数据库和表被删除时，相关访问权限任然存在，如果在创建了同名数据库或者表，则这些权限任然起作用。</p>
<pre><code>grant select, delete, drop on crash.* for bforta;
</code></pre>
<h3 id="用户改密码现在变了："><a href="#用户改密码现在变了：" class="headerlink" title="用户改密码现在变了："></a>用户改密码现在变了：</h3><pre><code>use mysql;
alter user user_name@host_name identified with mysql_native_password by &#39;newpassword&#39;;
</code></pre>
<h2 id="数据库维护"><a href="#数据库维护" class="headerlink" title="数据库维护"></a>数据库维护</h2><h3 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h3><p>使用命令行实用程序mysqldump转储所有数据库内容到某个外部文件。</p>
<pre><code>mysqldump -u user_name -p database_name &gt; file_name;
</code></pre>
<p>可用命令行实现mysqlhotcopy从一个数据库复制所有数据，但是并非所有引擎都支持这个实用程序。</p>
<h3 id="为了保障所有数据都被写到磁盘（包括索引数据）-可能需要在进行备份前，使用FLUSH-TABLES-语句"><a href="#为了保障所有数据都被写到磁盘（包括索引数据）-可能需要在进行备份前，使用FLUSH-TABLES-语句" class="headerlink" title="为了保障所有数据都被写到磁盘（包括索引数据） 可能需要在进行备份前，使用FLUSH TABLES 语句"></a>为了保障所有数据都被写到磁盘（包括索引数据） 可能需要在进行备份前，使用FLUSH TABLES 语句</h3><h3 id="进行数据库维护"><a href="#进行数据库维护" class="headerlink" title="进行数据库维护"></a>进行数据库维护</h3><p>检查表键是否正确：</p>
<pre><code>analyze table table_name;
</code></pre>
<p>MYISAM表上还对索引检查：</p>
<pre><code>check table table_name;
</code></pre>
<p>如果MYISAM表访问产生不正确的不一致的结果，需要用repair table来修复相应的表。<br>如果从一个表中删除大量数据，应该用optimize table table_name； 来回收所用空间，从而优化表的性能。</p>
<h3 id="诊断启动问题"><a href="#诊断启动问题" class="headerlink" title="诊断启动问题"></a>诊断启动问题</h3><p>MYSQL配置或者服务器本身出现更改的时候容易出现服务器启动问题，在排除系统启动问题时，应该手动用mysqld启动。</p>
<h3 id="查看日志文件"><a href="#查看日志文件" class="headerlink" title="查看日志文件"></a>查看日志文件</h3><p>错误日志 它包含启动和关闭以及任意关键错误的细节。这个日志通常在data目录中叫hostname.err</p>
<p>查询日志。他记录所有mysql活动，诊断问题的时候非常有用。通常叫hostname.log 在data目录下。</p>
<p>二进制文件。记录更新过的数据所有语句。data目录内叫 hostname.bin</p>
<p>缓慢查询日志。次日至纪录执行缓慢的任何查询，这个日志在确定数据库何时需要优化很有用。 hostname-slow.log 位于data目录中。 </p>
<p>在使用日志时，可以用FLUSH LOGS语句来刷新和重新开始所有日志文件。</p>
<h2 id="改善性能"><a href="#改善性能" class="headerlink" title="改善性能"></a>改善性能</h2><ul>
<li>MYSQL 有特定的硬件建议。对于生产的服务器来说，应该遵循这些硬件建议。</li>
<li>生产DBMS应该运行在自己的专用服务器上。</li>
<li>MYSQL使用默认设置预先设置的，随着业务量和逻辑的变化，需要重新调整内存分配，缓冲区大小等等。</li>
<li>MYSQL是一个多用户多线程的DBMS，化而言之经常执行多个任务。如果这些任务中一个执行特别缓慢，则所有请求都会缓慢，如果看到显著地性能不良，可以使用show procelist显示所有活动进程和他们线程id和执行时间。可以用kill命令终结某个特定进程。</li>
<li>explain语句可以让mysql解释他如何执行一个select 语句</li>
<li>一般来说存储过程执行要比一条条执行要快。</li>
<li>要使用正确的数据类型。</li>
<li>绝不检索必须求还多的数据。</li>
<li>insert可以用可选自delayed来延迟</li>
<li>在导入数据时，应该关闭自动提交，你可能还想删除索引，然后导入完成后，在重建他们。</li>
<li>必须靠索引数据库表来改善数据检索性能。需要分析使用select语句已找出重复where 和order by 子句。如果一个简单的where子句结果都花了很长，那么可以断定其中使用的列，就是需要索引的对象。</li>
<li>or改成union</li>
<li>索引改善检索性能，但是损害插入、删除、更新性能，所以不怎么检索的数据不要索引。</li>
<li>LIKE很慢最好使用全文本搜索 fulltext。</li>
<li>数据库是不断变化的，需要不断的调整。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://andrekuu.github.io/2021/04/22/Mysql%E5%9F%BA%E7%A1%80/" data-id="cknscjo0q0004egveaa8aa7vr" data-title="Mysql基础" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机网络细节" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/" class="article-date">
  <time class="dt-published" datetime="2021-04-21T19:43:19.000Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/">计算机网络细节</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><p>TCP\UDP是传输层的两种不同传输协议。TCP传输控制协议，是一种提供可靠的、端到端的、面向连接的字节流的协议,UDP用户数据报协议，无连接的不可靠数据报服务协议。<br>（1）TCP面向连接，就是通信开始前，需要建立连接，通信过程中需要维护连接，通行结束后需要释放连接，传输数据之前需要确定接收方的存在，并与接收方协议缓冲区大小，和序号起始值；UDP面向无连接，无需维护和断开连接，也就是在与通信方没有建立连接的的情况下发送出去，网络层如果是IP协议，那发送方根据对方的ip地址就发送数据包，并且也不提供序号服务和流量控制功能。<br>（2）TCP是可靠的传输协议，保证数据送达、正确性、排序正确；UDP可能丢包、错误、乱序；<br>（3）TCP传输速度慢；UDP速度快。因为UDP没有TCP三次握手的建立连接的步骤，省去了这部分时延，同时TCP有流量控制机制，就是当源和目的主机间一条或者多条链路出现极度拥塞的时候，来遏制传输层TCP的发送，所以TCP服务模型传输速度是比不上UDP的。<br>（4）TCP是Unicast的，不支持Multicast和Broadcast，每一条TCP连接只能是端到端的也就是一对一的；UDP支持一对一，一对多，多对一和多对多的交互通信<br>（5）TCP对系统资源要求较多，UDP对系统资源要求较少。因为TCP需要维护连接状态，连接状态包括接受和发送缓存、流量控制参数和序号、确认号的参数。UDP则不跟踪和维护这些参数 所以一般在UDP致上运行的服务器，能支撑更多的活跃用户。<br> (6) 分组首部开销小。每个TCP报文段都有20字节的首部开销，而UDP只有8个字节的开销。   </p>
<p><em>虽然UDP协议不稳定但是在即时通讯（QQ聊天、在线视频、网络语音电话）的场景下，可以允许偶尔的断续，但是这种协议速度快。DNS就是一个应用 UDP 的例子，当我们输入网址访问网站时，DNS 就是通过 UDP 发送域名查询报文的。所以，如果长时间没有得到回复，我们就会看到“连接超时”的错误页面。谷歌的CHrome浏览器就不使用TCP，使用QUIC协议，快速UDP因特网连接，是运输层基于UDP作为其支撑运输的协议，并在UDP之上的应用层协议实现可靠性，在应用层中增加确认和重传机制，这样构建的应用程序可以“左右逢源”，也就是说应用进程可以进行可靠的通信，而无需受制于TCP流量控制协议带来的强加的传输速率限制。但是不加限制的在高流量应用程序上采用UDP，也会导致全网络链路上长时间拥挤，而导致大量分组溢出，高丢包率。网络管理承载、电话会议、DNS通常采用UDP,电子邮件、远程终端访问、文件传输、Web采用TCP。</em>      </p>
<h2 id="什么是TCP三次握手"><a href="#什么是TCP三次握手" class="headerlink" title="什么是TCP三次握手"></a>什么是TCP三次握手</h2><p><img src="1.png"></p>
<p>TCP是运输层中一个面向连接的、可靠的、字节流服务。因为他是面对连接的，所以需要先建立连接然后维护连接最后断开连接释放资源，三次握手说的就是TCP建立连接的这个过程，三次握手的目的是建立可靠的通信信道，确认自己和对方发送与接收正常，并且确认双方的初始序号。    </p>
<p><strong>建立TCP连接协议时，需要在客户端和服务器之间发送三个包，握手过程中传送的包里不包含应用层数据，三次握手完毕后，建立全开连接，客户端与服务器才可以正式开始传送数据。</strong>   </p>
<p><strong>第一次握手：客户端发送第一个包，其中SYN标志位为1，发送序号sequence置为X(随机32位数)，这个随机是为了避免某些安全性攻击的。客户端进入SYN_sent发送状态，等待服务器确认。这个报文段称为SYN报文段</strong><br><strong>第二次握手：服务器收到SYN报文段后，为该TCP连接分配TCP缓存和变量，当然现在为了防御SYN洪流攻击，服务器已经把这个过程挪到第三次握手完成后才开始了。并向客户TCP发送允许连接的报文段，其中包SYN标志位为1，表明服务器想要和客户机建立连接；ACK置为1，表明服务器收到了请求并同意与客户机连接，发送初始序号seq为Y，（当然现在也是也是常用SYN COOKIE，这个Y其实是用源和目的IP地址利用散列函数实现的一个值）接收确认序号X+1，此时服务器进入SYN接收状态。这个服务器发送的允许连接的报文段也被称为SYNACK报文段</strong><br><strong>第三次握手：客户端收到服务器TCP的SYNACK报文段后，客户机也要开始为连接分配缓存和变量，客户机向服务器允许连接的报文段发送一个确认的数据报，接收确认序号置为Y+1,因为已经连接建立了，所以SYN=0，发送序号seq置为X+1。此包发送完毕，客户端和服务器进入建立成功状态，完成三次握手。握手的第三个阶段是允许报文段负载携带客户到服务器的数据的。第三次握手目的是为了防止已经失效的连接请求报文段又传送到了服务端，由于现在主机没有发送新的连接请求，如果没有第三次ACK握手，服务器就会一直等待主机发来数据，而很多资源就被浪费了，TCP 需要 seq 序列号来做可靠重传或接收，因此需要三次握手来约定确定双方的初始序列号</strong> </p>
<p><em>1) A –&gt; B  SYN my sequence number is X 2) A &lt;– B  ACK your sequence number is X 3) A &lt;– B  SYN my sequence number is Y 4) A –&gt; B  ACK your sequence number is Y简单的来说就是需要第三次我说来确认这个数据报是新的，而不是delay的。</em></p>
<p><em>第一个报文段，就是A发送给B的SYN数据报中途丢失，则A会周期性超时重传，直到收到B的确认。<br>第二个报文段，即B发给A的SYNACK报文段（SYN+ACK） 中途被丢，没有到达A，则： B会周期性超时重传，直到收到A的确认<br>第三个报文段，即A发给B的ACK 中途被丢，没有到达B ：则A发完ACK，单方面认为TCP为 Established状态，而B显然认为TCP为Active状态：<br>a. 假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP 连接<br>也为 Established状态，双向可以发包。<br>b. 假定此时A有数据发送，B收到A的 Data + ACK，自然会切换为established 状态，并接受A的Data。<br>c. 假定B有数据发送，数据发送不了，会一直周期性超时重传SYN + ACK，直到收到A的确认才可以发送数据。</em></p>
<h2 id="为什么要三次握手，两次握手行不行"><a href="#为什么要三次握手，两次握手行不行" class="headerlink" title="为什么要三次握手，两次握手行不行"></a>为什么要三次握手，两次握手行不行</h2><p>不行。<br><strong>第三次握手目的是为了防止已经失效的连接请求的报文段又传送到了服务端，比如发生了delay，由于现在主机没有发送新的连接请求，如果没有第三次握手，两次握手容易死锁。服务器就会一直等待主机发来数据，而很多资源就被浪费了。此外，TCP 需要 seq 序列号来做可靠重传或接收的依据，1) A –&gt; B  SYN my sequence number is X 2) A &lt;– B  ACK your sequence number is X 3) A &lt;– B  SYN my sequence number is Y 4) A –&gt; B  ACK your sequence number is Y 在计算机网络里通信里，对于一方的通信完成结果需要另一方的确认，所以对于服务器的序号seq需要一次客户机的确认。因此需要三次握手来约定确定双方的初始序列号</strong><br>此外，如果两次握手就可以完成连接，那么我攻击一个服务器就变得非常简单，只要不断发送大量的连接请求就好了，因为服务器两次握手就完成了连接建立，连接全开，那么就需要分配资源比如缓冲区和变量，那么很容易就耗尽服务器的资源。</p>
<h2 id="什么是四次挥手"><a href="#什么是四次挥手" class="headerlink" title="什么是四次挥手"></a>什么是四次挥手</h2><p>四次挥手是指运输层中TCP协议断开连接，释放资源的步骤。</p>
<ol>
<li><p>数据传输结束后，通信的双方都可以释放连接。此时，客户机和服务器都处于ESTABLISHED（已建立连接）状态。</p>
</li>
<li><p>假设客户机请求完资源了，想要释放连接。首先，客户机的应用进程先向服务器发出连接释放报文段，该报文段中将首部的终止控制位FIN置为１（只有当FIN置为１时，才能表明客户机想要和服务器断开连接），并且序号为ｕ（注意：此时的ｕ不是随机产生的，而是之前客户机传送的数据的最后一个字节的序号加１）。此时客户机进入到FIN_WAIT_１（终止等待１）状态，等待服务器的确认。</p>
</li>
<li><p>服务器收到连接释放报文后发出确认，在发送报文中将首部中的ACK置为１（ACK置为１，表面服务器同意与客户机释放连接），并且产生序号ｖ（注意：此时的v不是随机产生的，而是之前服务器传送的数据的最后一个字节的序号加１），并且发出确认号为u+１（确认号表明服务器渴望收到的下一个报文段的第一个数据字节的序号，因为之前发送了u，所以下一个序号为u+1）。此时服务器就进入CLOSE_WAIT（关闭等待）状态，客户机进入FIN_WAIT_2(终止等待2)状态。</p>
</li>
</ol>
<p>此时，从客户机到服务器这个方向的连接就被释放了，也就是说，客户机已经没有数据要向服务器发送了，但是如果服务器向客户机发送数据，客户机仍要接收数据。也就是说：从客户机到服务器的连接已经被释放了，但是从服务器到客户机的连接还没被释放。此时，TCP连接处于半关闭状态。</p>
<ol start="4">
<li><p>如果服务器向客户机也没有要发送的数据的话，那么服务器的应用进程就可以向客户机发出连接释放报文段，该报文段中将首部的终止控制位FIN置为1，ACK也置为1，并且序号为w（重点注意，此时的w不一定等于v+1。如果在客户机释放了连接之后，服务器向客户机仍旧发送了一部分数据，那么此时w不等于v+1，但是如果期间没有再发送数据，那么w就等于v+1。总而言之，这个w等于服务器上一次发送的数据的最后一个字节加1），并且发送确认号为u+1（确认号表明服务器渴望收到的下一个报文段的第一个数据字节的序号，因为之前发送了u，所以下一个序号为u+1）。此时服务器就进入了LAST_ACK（最后确认）状态。</p>
</li>
<li><p>客户机收到服务器的连接释放报文后，必须对此报文进行确认。在该报文段中将ACK置为1，序号为u+1，确认号为w+1（确认号表明服务器渴望收到的下一个报文段的第一个数据字节的序号，因为之前发送了w，所以下一个序号为w+1）。此时客户机进入到TIME_WAIT（等待时间）状态。但是，此时TCP连接还没有被释放掉。必须经过2MSL后客户机才能进入到CLOSED状态。（MSL:最长报文段寿命，RFC建议为两分钟，也就是说，要经过四分钟才能进入到CLOSED状态）。</p>
</li>
</ol>
<p><img src="2.png"></p>
<h2 id="什么是四次挥手中的2MSL-为什么要等2MSL"><a href="#什么是四次挥手中的2MSL-为什么要等2MSL" class="headerlink" title="什么是四次挥手中的2MSL 为什么要等2MSL"></a>什么是四次挥手中的2MSL 为什么要等2MSL</h2><p>MSL是Maximum Segment Lifetime英文的缩写，中文译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。RFC中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。<br>第一：为了保证客户机最后发送的那个ACK报文段能够到达服务器。这个ACK报文段可能会丢失。因而使处在LAST_ACK状态的服务器收不到对已发送的FIN＋ACK报文段的确认。客户机就能在2MSL时间内收到服务器重传的FIN+ACK报文段。接着客户机重传一次确认，重新启动2MSL计时器，直到最后客户机和服务器都可以进入到CLOSED（关闭）状态。如果没有2MSL等待时间，那么就无法收到重传的FIN+ ACK包，无法进入正常的CLOSED状态。<br>第二，防止“已失效的连接请求报文段”出现在本连接中。客户机在发送完最后一个ACK报文段，再经过时间2MSL，就可以使本连接持续的时间内所产生的报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</p>
<h2 id="为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手？</h2><p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。其实，在进行第二次握手时（即服务器向客户机进行应答时），可以看作时发了两次包，先回答客户机的服务请求（ACK＝１，接受确认序号X+1），然后再向客户机发出连接请求（SYN＝１，ｓｅｑ＝ｙ）</p>
<h2 id="TCP-IP五层模型"><a href="#TCP-IP五层模型" class="headerlink" title="TCP/IP五层模型"></a>TCP/IP五层模型</h2><p>应用层：  提供给客户端访问服务器网络服务的接口 。常用协议：HTTP、SMTP、FTP、ping、telnet、DNS、DHCP等</p>
<p>传输层：数据传输协议TCP 或 UDP</p>
<p>网络层 : 负责对数据包进行路由选择和存储转发，负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段和用户数据报封装成分组（IP数据报）或包进行传送。</p>
<p>IP协议:逐跳发送模式；根据数据包的目的地IP地址决定数据如何发送；如果数据包不能直接发送至目的地，IP协议负责寻找一个合适的下一跳路由器，并将数据包交付给该路由器转发</p>
<p>ICMP协议：因特网控制报文协议，用于检测网络连接</p>
<p>数据链路层： 负责分配MAC地址常用协议：地址解析协议（ARP）和反地址解析协议（RARP）,实现IP地址与机器物理地址（MAC地址）之间的转换两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻的链路上传送帧（frame)。每一帧包括数据和必要的控制信息。网卡接口的网络驱动程序，处理数据在物理媒介上的传输；不同的物理网络具有电气特性，网络驱动程序隐藏实现细节，为上层协议提供一致接口</p>
<p>物理层:所传数据单位是比特（bit)。物理层要考虑用多大的电压代表1 或 0 ，以及接受方如何识别发送方所发送的比特。</p>
<p>各网络层对应的工作设备：<br>物理层：中继器、集线器<br>数据链路层：网桥或交换机<br>网络层中继系统：路由器<br>网络层以上的中继系统：网关</p>
<h2 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h2><p>前端处理机：FEP  网卡就是前段处理器的化身  </p>
<h3 id="分组交换技术："><a href="#分组交换技术：" class="headerlink" title="分组交换技术："></a>分组交换技术：</h3><ol>
<li>存储转发技术 发送方到接收方，中间要经过多个节点的暂时存储，然后各根据接收方的地址，发送给下一个节点。</li>
<li>发送数据之前，要对数据分段处理，通常我们把要发送的整块数据叫一个报文，再把报文划分成更小的一个个数据段，在每段前面再加个首部，就构成了一个分组，分组也可以叫包，首部也可以叫包头，分组交换网的结构主要由主机host和节点交换机（node switch）组成。主机负责信息处理和其他主机通过网络交换信息。节点交换机主要是分组的存储和转发。     </li>
</ol>
<h3 id="分组交换技术的优点："><a href="#分组交换技术的优点：" class="headerlink" title="分组交换技术的优点："></a>分组交换技术的优点：</h3><p>优点：</p>
<ul>
<li>高效：逐段占用通信链路，动态分配传输宽带</li>
<li>灵活：智能节点能够独立处理数据分发</li>
<li>迅速：分组作为传输单位，无需建立连接</li>
<li>可靠：完善的网络协议<br>缺点：</li>
<li>传输时延：各节点进行存储转发的时候需要排队</li>
<li>首部数据存在开销 </li>
</ul>
<h3 id="计算机网络分类"><a href="#计算机网络分类" class="headerlink" title="计算机网络分类"></a>计算机网络分类</h3><p>范围分：</p>
<ul>
<li>广域网 几十-几千公里</li>
<li>局域网</li>
<li>城域网 5- 50公里<br>使用者：</li>
<li>公用网 通讯公司建造的网络</li>
<li>专用网 公司为了公司建设的内部网络（军队、电力）</li>
</ul>
<h3 id="网络体系工作流程："><a href="#网络体系工作流程：" class="headerlink" title="网络体系工作流程："></a>网络体系工作流程：</h3><ol>
<li>激活：使用信令确保发送的通路，保证数据在这条信道上可以正常的发送和接受。   </li>
<li>进行数据分析，识别接收方</li>
<li>发送方对接收方就绪检测</li>
<li>文件系统的格式转换</li>
<li>差错控制</li>
<li>其他</li>
</ol>
<h3 id="OSI七层模型失败的原因："><a href="#OSI七层模型失败的原因：" class="headerlink" title="OSI七层模型失败的原因："></a>OSI七层模型失败的原因：</h3><ol>
<li>糟糕的时机：推出的时机太晚了，已经有大量的应用开发实现了，厂商们担心新协议的接受程度，保守的延续旧协议。</li>
<li>糟糕的技术：无论是技术还是模型都有缺陷，其中的会话层和表示层基本是空的，链路层和数据层东西又太多。模型中协议非常复杂，实现起来非常困难。</li>
<li>糟糕的实现：OSI复杂而导致实现起来性能也差。</li>
<li>糟糕的策略：政府的产物，所以大家觉得是要把有缺陷的产物强加给开发人员。</li>
</ol>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>确定与传输媒体的接口特征：</p>
<ol>
<li>机械特征（接口形状 排列）</li>
<li>电气特征（承受电压范围）</li>
<li>功能特征（电压代表什么）</li>
<li>规程特征（工程实现各个事件出现的次序）</li>
</ol>
<p>局域网是基于广播技术发展起来的网络，广域网是基于交换技术发展出来的网络</p>
<p>网络体系结构可以定义为建立和使用通信硬件和软件的一套规则和规范</p>
<p>TCP/IP模型由低到高分别为网络接口层 、网络层、传输层、应用层。</p>
<p>按交换方式来分类，计算机网络可以分为电路交换，报文交换和分组交换三种</p>
<h3 id="信道："><a href="#信道：" class="headerlink" title="信道："></a>信道：</h3><p>向某一方向传输信息， 通信信道（发送信道、接收信道）。<br>单工通信（比如耳机）<br>双向通信（需要两个信道）<br>双向同时通信（电话）   </p>
<h3 id="信道容量："><a href="#信道容量：" class="headerlink" title="信道容量："></a>信道容量：</h3><p>单位时间内信道正确传输的比特数  bps（比特每秒）<br>香农定律 </p>
<h3 id="数据和信号的分类："><a href="#数据和信号的分类：" class="headerlink" title="数据和信号的分类："></a>数据和信号的分类：</h3><p>模拟数据用模拟信号发送 - 载波<br>数字数据用数字信号发送 - 编码<br>模拟数据用数字信号发送 - 采样<br>数字信号用模拟信号发送 - 调制</p>
<h3 id="传输媒体分类："><a href="#传输媒体分类：" class="headerlink" title="传输媒体分类："></a>传输媒体分类：</h3><p>导向传输媒体 铜线（同轴电缆，用于有线电视网） 光纤 双绞线（价格便宜性能不错，目前的电话线、网线）<br>非导向传输媒体  无线传输  </p>
<h3 id="光纤特点："><a href="#光纤特点：" class="headerlink" title="光纤特点："></a>光纤特点：</h3><ol>
<li>依靠光波承载信息，衰减少，传输距离远</li>
<li>抗雷电和电磁干扰性能好</li>
<li>无辐射，保密性好</li>
<li>体积小，重量轻</li>
<li>光线断裂的检测和修复都很难</li>
</ol>
<p>单芯光缆、多芯光缆</p>
<h3 id="光纤工作流程："><a href="#光纤工作流程：" class="headerlink" title="光纤工作流程："></a>光纤工作流程：</h3><p>计算机通过T型接头连接光纤，光信号通过接口的光接收机（光电二极管）变成电信号，通过铜线经过信号再生器接到计算机上。   </p>
<h3 id="短波通信："><a href="#短波通信：" class="headerlink" title="短波通信："></a>短波通信：</h3><p>利用电离层反射实现，但是电离层的不稳定产生的衰弱现象，和多径效应导致质量不好。 </p>
<h3 id="地面微波接力通信："><a href="#地面微波接力通信：" class="headerlink" title="地面微波接力通信："></a>地面微波接力通信：</h3><p>地球表面是曲面，所以多个每个基站直接通过微波传输信息，并接收到信息后放大作为中继继续向外传输。 </p>
<h3 id="卫星通信："><a href="#卫星通信：" class="headerlink" title="卫星通信："></a>卫星通信：</h3><p>利用近地轨道的卫星实现卫星通信。 和地面微波接力通信一样缺点是保密性较差，主要用于广播。</p>
<h3 id="DTE数据终端设备："><a href="#DTE数据终端设备：" class="headerlink" title="DTE数据终端设备："></a>DTE数据终端设备：</h3><p>具有一定信息处理能力，收发数据能力的设备，比如计算机</p>
<h3 id="DCE-数据电路端接设备："><a href="#DCE-数据电路端接设备：" class="headerlink" title="DCE 数据电路端接设备："></a>DCE 数据电路端接设备：</h3><p>在DTE和传输线中提供信号变换和编码功能，并负责建立、保持和释放数据链路连接 ，比如MODELM调制解调器。</p>
<h3 id="双绞线："><a href="#双绞线：" class="headerlink" title="双绞线："></a>双绞线：</h3><p>双绞线内有8根线，其中四根备用，一根作为接受高电平数据，一根发送高电平数据，一根接受低电平数据，一根发送低电平数据。网卡的接口要和双绞线相反。 因为这样的特性所以，网线分为直通线（两端都是586B），交叉线是一段568b一端568A，这样就可以连接两台计算机了。所以如果不是同类型的(DTE,DCE)用直通线，同类型用交叉线。</p>
<h3 id="信道复用技术："><a href="#信道复用技术：" class="headerlink" title="信道复用技术："></a>信道复用技术：</h3><ol>
<li>时分复用 ：时间划分为一个个时分复用帧，不同的时间占用同样的带宽资源</li>
<li>频分复用 ：将信号的带宽划分为各个小的频带，每个用户只用某个频带，不同时间占用不一样的带宽资源（光纤中发送不一样波长的光波进行通信叫波分复用，是光的频分复用）</li>
<li>码分复用 ：不同的编码。（CDMA：共享全部时间和带宽，经过计算后将其他站的信息过滤掉，利用内积运算过滤）</li>
<li>多分复用</li>
</ol>
<h2 id="数据链路层："><a href="#数据链路层：" class="headerlink" title="数据链路层："></a>数据链路层：</h2><h3 id="链路："><a href="#链路：" class="headerlink" title="链路："></a>链路：</h3><p>一条无源的、点到点的物理线段、中间没有其他点的交换节点    </p>
<h3 id="数据链路："><a href="#数据链路：" class="headerlink" title="数据链路："></a>数据链路：</h3><p>物理线路+链路控制规程形成的数据管道。数据链路上的通信规则就是数据链路的协议。  </p>
<h3 id="数据链路的三个基本功能"><a href="#数据链路的三个基本功能" class="headerlink" title="数据链路的三个基本功能"></a>数据链路的三个基本功能</h3><ol>
<li>封装成帧：就是在一段数据的前后分别添加首部和尾部。首部和尾部确认了帧的界限和一些控制信息。（MTU就是链路层协议规定 的最大传输帧的数据部分也就是从IP层传下来的IP数据包的最大长度）</li>
<li>透明传输：因为帧的首部和尾部确定了帧的长度，所以帧的数据段含有的首部和尾部字符的需要处理，比如在前面插入转义字符</li>
<li>差错控制：传输过程中可能会出现比特差错，0,1对调，为了保证传输可靠性，使用循环冗余校验CRC。</li>
</ol>
<h3 id="CRC："><a href="#CRC：" class="headerlink" title="CRC："></a>CRC：</h3><p>在发送端，先把数据划分为组。假设每组K个比特。将会与一个N+1位的除数P做除法，得到余数R，这个R就是附加在数据后面就是负责差错检验的冗余码。接收方将接收到的每一帧数据与除数P再次进行模2的除法运算，余数为0则判断这个帧没有差错，就接受。R！=0则将他丢弃。CRC只能检测是否出错，不知道出错的位置，而且也可能出现数据错误了但是余数也是0的漏检情况。所以CRC只能保证无差错接收，但这并不意味这可靠传输，因为除了差错的可能性还可能出现帧丢失、帧乱序的情况。因此必须要加上确认和重传机制才能保证可靠传输。</p>
<h3 id="帧检验序列FCS："><a href="#帧检验序列FCS：" class="headerlink" title="帧检验序列FCS："></a>帧检验序列FCS：</h3><p>在数据后面添加冗余码就叫帧检验序列。可以不是CRC算得的，可以识别的方法算的一个检验冗余码。  </p>
<h3 id="停止等待协议：（链路层）"><a href="#停止等待协议：（链路层）" class="headerlink" title="停止等待协议：（链路层）"></a>停止等待协议：（链路层）</h3><p>接收方收到数据方发送的数据后，将其提交给主机，并向发送方发送一个确认信息ACK(ACknowledge)，数据方才会发送下一帧信息；如果数据帧出错（CRC检验），则会向发送方发送一个否认帧 NAK 发送方会重传这一帧数据；如果数据帧丢失，发送方一直收不到消息，就会一直等待出现死锁，所以发送方每发送一帧就会启动一个超时计时器，如果在限定的时间内没有收到消息，就会自动重传这帧数据，这种被称为超时重传；如果应答帧出现丢失，那么也会出现超时重传，则接收端会面临重复帧的问题，为了解决重复帧的问题，我们给每个帧带上不同的序号，接收方接受到重复帧以后会丢弃这个数据，并再向发送方发送一个确认帧。</p>
<h3 id="ARQ-自动重传请求："><a href="#ARQ-自动重传请求：" class="headerlink" title="ARQ 自动重传请求："></a>ARQ 自动重传请求：</h3><p>这种自动重传请求是自动发生的。</p>
<h3 id="停止等待协议的优缺点："><a href="#停止等待协议的优缺点：" class="headerlink" title="停止等待协议的优缺点："></a>停止等待协议的优缺点：</h3><p>优点是简单，但是缺点是信道利用率太低了。</p>
<h3 id="连续ARQ协议："><a href="#连续ARQ协议：" class="headerlink" title="连续ARQ协议："></a>连续ARQ协议：</h3><p>为了处理停止等待协议的超低信道利用率，采用了流水线发送数据的方式，可以连续发送多个分组。就是发送数据后不用停下来等确认帧，一边发送一遍等待确认帧。由于连续发送数据帧，所以需要对数据帧连续编号，同时确认帧也需要编号。接收方收到出现差错后的后处理，可以选择向发送方发送否认帧，也可以不响应。接收端按序接受数据，而且必须连续，如果有一帧数据丢失，则后面的数据帧也会被接收端丢弃。而发送方等不到某帧数据的确认帧就会把该帧包括以后的每一帧都要重传一遍。（这种称为回退N GO-BACK-N）为了减少开销，接受方只对按序到达的最后一个分组发送确认， 采取累计确认的方式。在等待确认帧的时候，发送方也不能一直发送数据，因为发送数据越多，如果出错，则回退数据量也大，增加了重传开销，而且传送的数据越多，编号需要花更多的比特位来实现，也增加了开销。</p>
<h3 id="连续ARQ协议优缺点："><a href="#连续ARQ协议优缺点：" class="headerlink" title="连续ARQ协议优缺点："></a>连续ARQ协议优缺点：</h3><p>提高了信道利用率，但是回退的操作导致如果信道通信质量很差的时候效率可能还不如停等协议</p>
<h3 id="滑动窗口协议："><a href="#滑动窗口协议：" class="headerlink" title="滑动窗口协议："></a>滑动窗口协议：</h3><p>就是在发送方和接收方分别设置的可以移动的发送窗口，通过对序号的设置，可以对已经确认的帧的序号循环利用，同时加入一定的控制机制，避免二义性。也就是对连续ARQ协议里的连续发送的数据流量进行控制，只有在窗口的帧才可以被发送出去。当发送方收到了一个确认帧以后，发送方的滑动窗口就像右滑动一个，新加入窗口的数据就可以发送出去了。接收方的滑动窗口的作用是确认哪些帧可以接受，哪些帧不可以接收，接收方只有接受了处于滑动窗口内的帧时，才会收下这帧数据，否则一律丢弃，接收完会发送确认帧。在连续ARQ协议中接收方窗口宽度为1。</p>
<h3 id="选择重传ARQ协议："><a href="#选择重传ARQ协议：" class="headerlink" title="选择重传ARQ协议："></a>选择重传ARQ协议：</h3><p>增大接收端滑动窗口宽度，先接收下那些发送序号不连续但在窗口内的数据帧，等所有帧到达窗口后再一起提交。这样可以避免重传已经确认的帧，代价是需要在接收方设置相当容量的缓冲区。</p>
<p>原来因为信道质量低下的问题，普遍选择可靠传输协议，现在通信线路质量的提升，出现传输错误的几率降低。所以现在在链路层，使用最为普遍的是点对点协议PPP。</p>
<h3 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h3><ol>
<li>PPP协议很简单，因为设计网络层次的时候，把最复杂的部分放在了运输层</li>
<li></li>
<li></li>
<li></li>
<li>协议中，网络层的IP协议就非常简单，所以PPP设置非常简单。</li>
<li>封装成帧：PPP协议规定了特殊的字符作为帧定界字符，以便于接收方提取完整的数据帧。</li>
<li>透明性：转义符来实现帧定界出现在数据里。</li>
<li>多种网络层协议：要能在一条物理连路上，实现多挣网络协议的运行。</li>
<li>必须在多种类型链路中运行（穿/并 低/高速）</li>
<li>差错检测</li>
<li>随时自动检测链路连接状态</li>
<li>需要设置最大传送单元MTU</li>
<li>网络层地址协商</li>
<li>数据压缩的协商</li>
</ol>
<h3 id="PPP格式："><a href="#PPP格式：" class="headerlink" title="PPP格式："></a>PPP格式：</h3><p>首部4个字段，尾部两个字段，首部第一个和尾部最后一个都是标志字段，规定值是16进制的7E（2进制0b1111110）为帧的定界符。首部中的地址字段A为16进制的FF，控制字段设置为十六进制03，目前这两个数字没有什么意义。在后面是PPP协议字段，占两个字节。当协议字段为0x0021时，PPP帧的信息字段就是IP数据报。若为0XC021则信息字段是PPP链路控制数据，0X8021时，则表示这是网络控制数据。信息部分通常都是IP层传下来的IP数据报，这部分不超过1500字节。在后面就是真校验序列FCS，占两个字节。  </p>
<p><img src="1.png" alt="PPP格式"></p>
<h3 id="PPP透明传输问题："><a href="#PPP透明传输问题：" class="headerlink" title="PPP透明传输问题："></a>PPP透明传输问题：</h3><ol>
<li>PPP异步传输时，使用一种特殊的字符填充法。</li>
<li>PPP在同步传输链路时，协议规定采用硬件来完成零比特填充。（遇到5个1就自动填充一个0）</li>
</ol>
<h2 id="信道共享技术"><a href="#信道共享技术" class="headerlink" title="信道共享技术"></a>信道共享技术</h2><p>不同用户的信号在信道里叠加和碰撞</p>
<h3 id="信道共享（多点接入技术）的要求："><a href="#信道共享（多点接入技术）的要求：" class="headerlink" title="信道共享（多点接入技术）的要求："></a>信道共享（多点接入技术）的要求：</h3><ol>
<li>要求某一时刻 只有唯一信息有效传递</li>
<li>要求平等的对待用户</li>
</ol>
<ul>
<li>平等发送</li>
<li>平等接收</li>
<li>实时反映</li>
</ul>
<h3 id="受控接入："><a href="#受控接入：" class="headerlink" title="受控接入："></a>受控接入：</h3><p>分为集中式控制（轮询）和分散式控制（令牌环网）</p>
<h3 id="轮询："><a href="#轮询：" class="headerlink" title="轮询："></a>轮询：</h3><p>轮询方式下，网络中接入点分为主机和站两种类型。主机负责接入管理，逐个对站询问是否有信息要发送。站则参与数据传输。</p>
<h3 id="轮叫轮询："><a href="#轮叫轮询：" class="headerlink" title="轮叫轮询："></a>轮叫轮询：</h3><p>这种方式下，每个站只能收到主机发来的信息，也只能向主机发送信息。主机按照顺序从1站开始逐个询问各站是否有数据要发送。（如果1站没有信息要发，就发送一个控制帧给主机）</p>
<p>缺点：轮询帧在线路上轮番往返，增加了帧的等待时延。</p>
<h3 id="传递轮询："><a href="#传递轮询：" class="headerlink" title="传递轮询："></a>传递轮询：</h3><p>每个循环由主机向N站发送轮询帧，然后由N站向N-1站发送轮询帧，知道最后再由1站把发送权交会给主机，完成一个循环。传递轮询的帧时延总是小于同样条件下的轮叫轮询，而且站间距离越大，轮叫轮询的效果越好。</p>
<p>缺点：协议复杂，实现难度和成本高。</p>
<h3 id="令牌环网："><a href="#令牌环网：" class="headerlink" title="令牌环网："></a>令牌环网：</h3><p>这个网络的拓扑结构是一个环。<br>令牌其实是一个帧，在环路中流动。当有站有数据要发送时，必须先截获这个令牌。当发出的数据在环路中流动时经过目的站时，目的站复制这个帧，表示接受了数据，并将这个数据帧发转发给下一站，让他在环路上继续流动，发送站回收数据检查数据是否被成功接收。判断发送成功后，发送站会生成一个新的令牌，放回环路中继续流动。</p>
<h3 id="令牌环网的特点："><a href="#令牌环网的特点：" class="headerlink" title="令牌环网的特点："></a>令牌环网的特点：</h3><ol>
<li>公平原则，适合重载环境</li>
<li>每个站占用信道的等待时间有上限</li>
<li>闭合的环一点断多点瘫痪不易检查断点。</li>
</ol>
<h3 id="令牌总线网"><a href="#令牌总线网" class="headerlink" title="令牌总线网"></a>令牌总线网</h3><p>结构上是一个总线型的网络，但在逻辑上构成了一个环。</p>
<p>特点： 又有总线网络的介入方便和可靠性高的优点，也具有令牌环网不冲突，有时延上限的优点。协议复杂，所以推广应用比较差。</p>
<h2 id="信道共享技术之随机接入技术"><a href="#信道共享技术之随机接入技术" class="headerlink" title="信道共享技术之随机接入技术"></a>信道共享技术之随机接入技术</h2><h3 id="纯ALOHA"><a href="#纯ALOHA" class="headerlink" title="纯ALOHA"></a>纯ALOHA</h3><p>工作原理：想发就发，如果规定时间内收到接受方传来的应答，则表示发送成功，否则重发。<br>重发策略：若立即重发，则显然要再次冲突。等待随机一段时间，然后重发，如果再次冲突，则再等待一段时间。<br>特点：负载越重，冲突概率越大，性能越差。     </p>
<h3 id="时隙ALOHA："><a href="#时隙ALOHA：" class="headerlink" title="时隙ALOHA："></a>时隙ALOHA：</h3><p>把时间划分为一个个时隙长度刚好为发完一个帧的长度，帧无论什么时候产生，只能在每个时隙开始时发送到信道上。<br>特点：提高了一定信道的吞吐量，改善了性能。  </p>
<h3 id="CSMA：载波监听多点接入"><a href="#CSMA：载波监听多点接入" class="headerlink" title="CSMA：载波监听多点接入"></a>CSMA：载波监听多点接入</h3><p>每个站在发送数据之前，都会检测一下信道是否已被其他站点占用“先听后发”。<br>非坚持CSMA：一旦监听到信道忙，就不再监听；延迟一个随机时间后再次监听。<br>坚持CSMA：监听到信道忙时，仍然继续监听，直到信道空闲。1-坚持CSMA：一听到空闲就立即发送数据（以概率1发送）；2-坚持CSMA：听到信道空闲时，以概率P发送数据，即以概率1-p延迟一段时间后再发送。</p>
<h3 id="CSMA缺点："><a href="#CSMA缺点：" class="headerlink" title="CSMA缺点："></a>CSMA缺点：</h3><ol>
<li>传播时延</li>
<li>任然存在冲突可能</li>
<li>在冲突发生时，站不知道是出现冲突，这样发送数据的站将一直把数据发出，但这显然这些数据是错误的，因此这段时间是浪费的。</li>
</ol>
<h3 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h3><p>先听后发， 边发边听。一边发送一边监听，如果监听到冲突，则冲突双方都立即停止发送，（检测到冲突停止发送后会发一个人为干扰信号，强化冲突让所有人听到）信道很快空闲，从而提高效率。</p>
<h3 id="检测冲突的方法："><a href="#检测冲突的方法：" class="headerlink" title="检测冲突的方法："></a>检测冲突的方法：</h3><ol>
<li>比较接收到的信号电压大小，如果冲突，会大一倍</li>
<li>检测曼彻斯特编码过零点。</li>
<li>发送的同时也接受，就可以比较接收到的信号和发送的信号区别。</li>
</ol>
<h3 id="碰撞槽时间："><a href="#碰撞槽时间：" class="headerlink" title="碰撞槽时间："></a>碰撞槽时间：</h3><p><img src="2.png"><br>信道的最大冲突检测时间是2T （T为距离最远的两个站传输时延）<br>如果一个帧的发送时间小于碰撞槽时间的话，则冲突发生也无法检测到。所以我们对信道上的最小传输帧长也做了限制。   </p>
<h2 id="局域网技术"><a href="#局域网技术" class="headerlink" title="局域网技术"></a>局域网技术</h2><p>基于IEEE 802参考模型<br>将数据链路层分为两个自层，一个MAC（media access control）媒体访问控制,负责向下层提供媒体访问方法，一个LLC（Logical link control）逻辑链路控制，向上层提供连接环境。<br><img src="3.png"><br>物理层实现信号编码译码，同步码的产生和去除，比特的传输和接收。<br>MAC：成帧和拆帧  实现和维护MAC协议，比特差错检验（发现错误后交给LLC子层处理）和寻址。<br>LLC子层建立和释放逻辑电路，与高层的接口，差错控制和帧加减序号。局域网的传输介质访问细节对于LL子层是透明的。<br>高层数据+LLC首部 形成LLCPDU。然后交给MAC，MAC子层会把LLCPDU当做MAC数据部分加上首部和尾部封装成帧。</p>
<h3 id="局域网当中地址表示采用二进制，48bit的MAC地址。因为太长了，所以实际记录的时候转成6组16进制数来表示。（比如00-00-0C-01-23-45，有时候也可以用冒号来分割）他在记录地址信息的时候，需要保证全球唯一性。（全世界没有两个设备MAC地址是一样的）"><a href="#局域网当中地址表示采用二进制，48bit的MAC地址。因为太长了，所以实际记录的时候转成6组16进制数来表示。（比如00-00-0C-01-23-45，有时候也可以用冒号来分割）他在记录地址信息的时候，需要保证全球唯一性。（全世界没有两个设备MAC地址是一样的）" class="headerlink" title="局域网当中地址表示采用二进制，48bit的MAC地址。因为太长了，所以实际记录的时候转成6组16进制数来表示。（比如00.00.0C.01.23.45，有时候也可以用冒号来分割）他在记录地址信息的时候，需要保证全球唯一性。（全世界没有两个设备MAC地址是一样的）"></a>局域网当中地址表示采用二进制，48bit的MAC地址。因为太长了，所以实际记录的时候转成6组16进制数来表示。（比如00.00.0C.01.23.45，有时候也可以用冒号来分割）他在记录地址信息的时候，需要保证全球唯一性。（全世界没有两个设备MAC地址是一样的）</h3><p>生产网卡和网络接口的前24bit是制造商ID，后24位企业分配保证不重复<br><img src="5.png"></p>
<h3 id="以太网-Ethernet"><a href="#以太网-Ethernet" class="headerlink" title="以太网 Ethernet"></a>以太网 Ethernet</h3><p>以太网采用CSMA/CD，重载下性能差。我们使用的局域网也称为以太网（一般使用CSMA/CD都叫以太网）</p>
<p>10 BASE 5,10 BASE 2,10 BASE T,10 BASE F (A BASE B,A是带宽，比如10兆带宽，10Mbp s)</p>
<p><img src="6.png"></p>
<p>为了比特同步，所以实际传输的要比MAC帧还要多8个字节    </p>
<h3 id="标准以太网（10-BASE-5）"><a href="#标准以太网（10-BASE-5）" class="headerlink" title="标准以太网（10 BASE 5）"></a>标准以太网（10 BASE 5）</h3><p>传输媒体10mm铜轴粗缆，特性阻抗50欧姆，曼彻斯特编码，总线拓扑，10Mbps，单段最长500m。（信号衰减变形极限500米）当然可以通过中继器REPEATER来实现对信号的放大和整形，中继器是物理层上实现局域网互联的设备，负责连接各个电缆，从而延长500米。不过中继器也不是万能的，最多有5端500米的电缆通过4个中继器连接在一起，而且其中只能有三段电缆能够连接计算机，即543规则。</p>
<h3 id="细缆以太网（10-BASE-2）"><a href="#细缆以太网（10-BASE-2）" class="headerlink" title="细缆以太网（10 BASE 2）"></a>细缆以太网（10 BASE 2）</h3><p>传输媒体是细缆，阻抗特性500欧姆，曼彻斯特编码，总线拓扑，10Mbps，单段最长185m。 5X185 =925m 网络跨栏。</p>
<h3 id="10-base-T："><a href="#10-base-T：" class="headerlink" title="10 base T："></a>10 base T：</h3><p>使用双绞线 和星型拓扑接口 单段最长100m，使用HUB（集线器）来互联。主机用线缆连接（网线）带RJ-45连接器连接主机和HUB，一个HUB可以连多个主机，并可以用hub之间级联的方式来实现。但是也得遵守543规则，也就是级联中任意两个HUB的距离不能超过5个（包括这两个）</p>
<p>RJ-45连接器 水晶头~~</p>
<h3 id="HUB："><a href="#HUB：" class="headerlink" title="HUB："></a>HUB：</h3><p>HUB是一个多端口的转发器，对信号进行整形和放大，然后对所有端口转发出去。在以HUB为中心设备时，即使网络中某条线路产生了故障，并不影响其它线路的工作。所以HUB在局域网中得到了广泛的应用。集线器（HUB）属于数据通信系统中的基础设备，它和双绞线等传输介质一样，是一种不需任何软件支持或只需很少管理软件管理的硬件设备。它被广泛应用到各种场合。集线器工作在局域网(LAN)环境，应用于OSI参考模型第一层，因此又被称为物理层设备。集线器内部采用了电器互联，当维护LAN的环境是逻辑总线或环型结构时，完全可以用集线器建立一个物理上的星型或树型网络结构。在这方面，集线器所起的作用相当于多端口的中继器。其实，集线器实际上就是中继器的一种，其区别仅在于集线器能够提供更多的端口服务，所以集线器又叫多口中继器。</p>
<h3 id="快速以太网"><a href="#快速以太网" class="headerlink" title="快速以太网"></a>快速以太网</h3><p>100Mb/s CSMA/CD 传输介质5类UTP 双绞线就是  单段线路100m 使用HUB连接这些和10 BASE差不多 可以实现向下兼容。<br>不过百兆以太网，系统最多两个集线器，且两个集线器距离不大于5m。所以最大的距离是205米。</p>
<h3 id="100BASEFX"><a href="#100BASEFX" class="headerlink" title="100BASEFX"></a>100BASEFX</h3><p>光纤作为传输截止。CSMA/CD，使用一对光纤作为传输截止，因为光纤只能单向传输。</p>
<h3 id="局域网的拓展："><a href="#局域网的拓展：" class="headerlink" title="局域网的拓展："></a>局域网的拓展：</h3><h3 id="网桥："><a href="#网桥：" class="headerlink" title="网桥："></a>网桥：</h3><p><img src="8.png"><br>网桥内部有一个地址表MAC地址表，记录了端口和主机对应的关系。<br>网桥的作用就是</p>
<ol>
<li>过滤通信量，隔离冲突域，在不同冲突域内的主机，数据通信任然可以同时进行。</li>
<li>扩大物理范围</li>
<li>可以互联不同的物理层</li>
<li>提高了可靠性<br>缺点：</li>
<li>帧的处理导致更高的传输延迟</li>
<li>没有流量控制功能，可能产生溢出</li>
<li>只适合小规模局域网，大规模局域网可能会产生传播风暴   </li>
</ol>
<p>透明网桥的帧转发策略，是查看帧的地址，如果是相同网络的数据交换（同一个集线器连着的）就丢弃帧，不需要向别的端口传输该数据；不同网络的数据交换请求，则会接收帧转发它。帧的转发规则：网桥会查看内部MAC地址表，如果接受方在mac地址表内，则会按照表的指定端口转发帧。如果不在表内，用扩散flooding方式转发帧（就是往每个端口转发帧）。</p>
<p>网桥是比较早期的扩展局域网的手段，目前是采用局域网交换机来实现拓展。局域网交换机与网桥的关系比较类似于HUB与中继器。</p>
<h3 id="局域网交换机"><a href="#局域网交换机" class="headerlink" title="局域网交换机"></a>局域网交换机</h3><p><img src="9.png"></p>
<ul>
<li>各端口平时都不连通</li>
<li>当接入交换机的设备之间需要通信时，交换器能够同时连通许多对端口</li>
<li>每一对相互通信的设备都能像独占通信介质那样进行无冲突的数据传输</li>
<li>在双方通信完成，将断开连接</li>
</ul>
<p>局域网交换机的策略是</p>
<ol>
<li>STORE&amp;forword，完全缓存后，再根据字段里的地址判断是否需要转发。可以进行CRC校验。缓存所花的的延时较长。</li>
<li>Cut through 仅仅缓存前6个字节的MAC地址，转发所花费的时延就降低了，但是无法进行CRC校验，可能转发报文碎片。</li>
<li>fragment free 缓存前64字节的数据，这样减少报文碎片出现的概率。在局域网中，小于64字节的数据一定是报文碎片。 </li>
</ol>
<h3 id="1000BASECX"><a href="#1000BASECX" class="headerlink" title="1000BASECX"></a>1000BASECX</h3><p>短距离屏蔽铜缆，最长距离25米。<br>1000baselx 光纤，长波激光光源LWL，1000basesx 光纤 短波SWL。<br>1000baseT 双绞线</p>
<p>千兆以太网需要帧拓展，将帧拓展成512字节（如果帧不足512字节的话），但是如果发送一堆短帧，都填充扩展，实际上降低了数据传输效率，所以，帧开发技术，就是第一个短帧扩充后成功发送后，后续短帧们以一定帧间隙组成组发送，这就是帧突发。  </p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="互联网："><a href="#互联网：" class="headerlink" title="互联网："></a>互联网：</h3><p>Internet和 internet 。Internet是全球最大的，开放的，有众多网络相互连接而成的特定的计算机网络，采用TCP/IP协议，前身为ARPANTET<br>internet泛指多个网络互联形成的网络<br><img src="10.png"></p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>ip地址是ip协议的地址 网络层提供两种服务，可靠的面向连接的服务，一种是不可靠的无连接服务。ip是不可靠的无连接服务。  </p>
<p>IP 的核心思想是：尽力传递的设计思想，因为IP无法保证数据传输正确、成功和顺序。</p>
<h3 id="面向连接"><a href="#面向连接" class="headerlink" title="面向连接"></a>面向连接</h3><p>就是通信开始前，需要建立连接，通信过程中需要维护连接，通行结束后需要释放连接。（比如打电话）</p>
<h3 id="无连接："><a href="#无连接：" class="headerlink" title="无连接："></a>无连接：</h3><p>无需维护和断开连接（发送短信） 但是这种方式无法保证传输的可靠性，可能出现数据丢失，但是IP不管这些，把纠错重传交给传输层解决。快速、简单、效率高。</p>
<h3 id="IP层主要协议"><a href="#IP层主要协议" class="headerlink" title="IP层主要协议"></a>IP层主要协议</h3><p>IP协议和几个偏辅助的协议两个偏上层的 ICMP , IGMP<br>和两个偏下层的 ARP。RARP 协议。     </p>
<h3 id="IP地址-1"><a href="#IP地址-1" class="headerlink" title="IP地址"></a>IP地址</h3><p>32位2进制，4个点分的十进制数来表示 （202.118.110.196）<br>所以每个点分的十进制数 对应一个8位2进制数，所以0-255之前。<br>IP地址可以分为网络号和主机号<br>因为IP寻址的时候是先根据网络号寻找网络，在根据主机号寻找主机。</p>
<h3 id="IP地址的分类："><a href="#IP地址的分类：" class="headerlink" title="IP地址的分类："></a>IP地址的分类：</h3><p>IP地址一般分为A\B\C\D\E类5类，主要常用的是A\B\C类<br>A类前8个为网络号，后24位 主机号，A类第一比特位0。 1.0.0.0 - –127.255.255.255<br>B类前16位为网络号，后16位为主机号，B类前两位比特位10 128.0.0.0 —191.255.255.255<br>C类前24位为网络号，后8位为主机号，C类前三位比特位为110  192.0.0.0 — 223.255.255.255<br>D类1110开头 224.0.0.0 — 239.255.255.255<br>E类11110开头 240.0.0.0—- 247.255.255.255 </p>
<h3 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h3><p>IP32位全0表示自己this host，全1表示所有，表示广播（本网络内的广播）<br>网络号为全0接主机号则表示this network里的一个主机号<br>主机号为全0表示这个网络的网络号。<br>主机号全为1表示某网络的广播地址。<br>这些特殊含义的地址是不可以分配给主机的。<br>127开头的+anything， loopback address 表示本机<br>三个IP地址都指向本机，0.0.0.0，127.0.0.1 还有就是主机的地址。0.0.0.0是不能参与通信的，127.0.0.1是可以发数据的，但是不会经过物理层和链路层的封装，直接进入IP层的转发直接发给接收模块。<br>所以一个网络最多容纳2**n - 2台主机。</p>
<h3 id="子网掩码："><a href="#子网掩码：" class="headerlink" title="子网掩码："></a>子网掩码：</h3><p>比如C类的子网掩码 255.255.255.0<br>子网掩码和IP做与操作，就可以得到IP地址对应的网络号。子网掩码是由连续的若干个二进制“1”组成的代码<br>确定网络ID和主机ID的方法：子网掩码 AND IP地址 = 网络地址(ID)<br>子网掩码是主机判断目的IP地址是否与主机出在同一个网络的唯一依据。主机在发送数据之前，需要用目的IP地址与子网掩码进行与运算。再把本机的IP地址与子网掩码与运算然后看看是否相同，结果相同则意味着数据传输在本网络进行。如果不同则意味着要把数据发送到所在网络的出口，发送到其他网络中去。</p>
<h2 id="ARP协议：Address-resolution-Protocol"><a href="#ARP协议：Address-resolution-Protocol" class="headerlink" title="ARP协议：Address resolution Protocol"></a>ARP协议：Address resolution Protocol</h2><p>地址解析协议 MAC地址和IP地址之间的转换协议。数据链路层有自己的MAC地址，TCP/IP有自己的IP地址。（IP地址相当于一个人的人名，MAC地址相当于这个人本身）<br>ARP协议的基本原理： 发送方会向该网络里发送一个ARP请求的广播（相当于叫这个人的名字），然后对应接收主机会发送一个ARP应答。以后再和这个接收方通信就不需要再次广播了，而是有记忆的。以后可以直接发送数据。</p>
<p>局域网中要尽量避免广播和广播通信。</p>
<p>ARP协议的改进，上来就给每个主机分配了一个ARP Cache，相当于MAC地址和IP地址的映射表。当发送方主机发送广播的时候，也会顺带把自己的MAC与IP地址发送出去，接收方会接受了并存在自己的ARP CACHE里。应答ARP以后也会捎带发送自己的IP和MAC地址。  </p>
<p><img src="11.png"></p>
<h3 id="ARP协议漏洞："><a href="#ARP协议漏洞：" class="headerlink" title="ARP协议漏洞："></a>ARP协议漏洞：</h3><p>ARP协议默认相信发送来的MAC和IP地址真实有效。这样就产生了一个协议漏洞，可以利用欺骗ARP协议入侵方式。</p>
<p>ARP协议漏洞的根本是ARP协议支持MAC IP之间动态地址映射。所以一种解决办法是使用静态地址映射。</p>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p>IP数据报datagram 是IP协议的PDU，是Internet上数据传输的最基本单元。路由器在不同网络将转发IP分组，实现IP数据报的寻路功能。</p>
<p><img src="12.png"></p>
<p>Version:版本号 目前是IPV4和IPV6两种。<br>首部长度：要把首部字节数/4字节数 得到的数记录在这里，单位是4字节<br>TOS:服务类型，选取这个数据报服务的优先级。对应DTRC比特位，D比特位表示低时延，T表示高吞吐率 R表示高可靠性  C比特被置1表示低费用。这四个比特不可能同时被置为1。只能将其中一个置为1.<br>Total Length：总长度，以字节为单位<br>TTL：初始值为255，当减为0是被路由丢弃。<br>协议：指高层的协议类型<br>checksum：首部检验和<br>一般IP协议头部长度20字节       </p>
<h3 id="IP报文的分片："><a href="#IP报文的分片：" class="headerlink" title="IP报文的分片："></a>IP报文的分片：</h3><p>IP数据报被帧封装，所以受限于帧的长度，帧的最大传输单元是MTU，只局域网中最长的帧，这里限制了封装的IP报文的长度<br>当传输数据报的MTU大于传输过程中比如路由器将最大MTU的限制，也就是较大报文经过MTU小的局域网前，这时候就需要对报文进行分片。<br>路由器会把IP数据报数据部分成若干份，并在前面加上分片的首部，来记录这个分片在原始IP数据报当中的位置等相关信息。<br>接收方主机需要有一个缓冲区，然后缓冲区接收完分片后重组成原来的IP数据报。这样就需要在报文的开头一个区域记录分片的位置，也就是记录分片的偏移量。第一个分片的offset 为0，后一个的偏移量就是前一个长度。<br>标识（重组时同一数据报的标识相同）、标志（就是后面还有没有分片了）、偏移量（就是在原来数据报里的偏移量位置，偏移量单位是 8字节 所以要偏移字节除以8 = offset）</p>
<h2 id="IP路由器："><a href="#IP路由器：" class="headerlink" title="IP路由器："></a>IP路由器：</h2><p>网络中有很多路由器负责分发，组成一个分发网，数据从发送方到接收方，选择一条IP路由就像是寻路。 </p>
<p>路由系统要解决的问题：</p>
<ol>
<li>如何依据路标寻路</li>
<li>如何维护路标</li>
</ol>
<p>路由器转发数据的时候以路由表为依据。</p>
<h3 id="IP路由的寻址："><a href="#IP路由的寻址：" class="headerlink" title="IP路由的寻址："></a>IP路由的寻址：</h3><ol>
<li>直接寻址（源与宿在相同网络）物理网络内部确定主机 –主机的数据传输路径    </li>
<li>间接寻址：经过路由器的转发就叫间接寻址 </li>
</ol>
<p>下一站转发的网络地址就是网关。这个设备在网络上的默认出口。</p>
<h3 id="网关："><a href="#网关：" class="headerlink" title="网关："></a>网关：</h3><p>网关就是一个网络通向另一个网络的出口。<br>网关(Gateway)网间连接器、协议转换器。</p>
<h3 id="默认路由："><a href="#默认路由：" class="headerlink" title="默认路由："></a>默认路由：</h3><p>路由器在转发过程中，会挨个子网掩码与操作和目的网络得到的网络地址和目的IP地址的网络地址比较，如果都不相同，最后会有一条全0.0.0.0的目的网络，就完成了往默认路由方向转发的过程。 </p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><ol>
<li>因为主机一般有多个进程在使用网络通信，所以只是把数据报交付给主机还没完成全部工作。</li>
<li>IP提供两种服务一种可靠的蓄电路服务，一种不可靠的数据报服务，和不可靠的数据报服务。<br>总结来说 <strong>传输层作用</strong>：进程寻址和网络层上的服务保证</li>
</ol>
<h3 id="传输层作用："><a href="#传输层作用：" class="headerlink" title="传输层作用："></a>传输层作用：</h3><ul>
<li>为应用进程提供端到端的服务</li>
<li>增强网络层提供的服务质量QoS</li>
</ul>
<h3 id="传输实体"><a href="#传输实体" class="headerlink" title="传输实体"></a>传输实体</h3><p>传输实体之间传输，传输协议称为TPDU 。传输实体就是收/发两端的传输层实现对等实体通信的硬件或软件。利用网络层提供点到点的分组传输服务，向高层提供端到端的TPDU（传输协议数据单元）传输服务。</p>
<h3 id="点到点、端到端"><a href="#点到点、端到端" class="headerlink" title="点到点、端到端"></a>点到点、端到端</h3><p>主机A TO 主机B 就是端到端，点到点是A to 路由器R1，点到点是 R1 TO 路由器R2，这些是点到点的。链路层保证的是点到点的可靠性。</p>
<h3 id="TCP协议-Transmission-Control-Protocol"><a href="#TCP协议-Transmission-Control-Protocol" class="headerlink" title="TCP协议 Transmission Control Protocol"></a>TCP协议 Transmission Control Protocol</h3><p>为应用进程提供可靠的、端到端的、面向连接的字节流通性，解决分组的重传和排序问题。利用网络层的IP协议提供的不可靠的分组传输服务，解决分组的重传和排序问题。<br>面向连接意味着，传输数据之前需要确定接收方的存在，并与接收方协议缓冲区大小，和序号起始值。<br>TCP连接是全双工的，支持同时双向传输<br>Unicast 只支持两端点之间的通信，不支持多播和广播Multicast和Broadcast。<br>面向字节流。     </p>
<p>TCP协议的传输实体 软件实现，用户进程，操作系统核心的一部分， 管理TCP字节流实现与IP层的接口。</p>
<p>在主机中，有多个进程，会给进程编号，就叫PORT端口。TCP协议用16比特来给端口编号。   </p>
<pre><code>clientSocket.connect((serverName, serverPort))
</code></pre>
<p><strong>固定端口号</strong>：全局分配<br>优点是知道与当前应用通信的端口号；缺点就是没有在国际组织注册的进程没有端口号，新的进程的端口号获得就变得非常复杂了。固定端口号小于1024的已经全部被分光了。     </p>
<p><strong>临时端口</strong>：<br>主机建立连接时为用户进程动态的分配端口（大于等于1024的端口号）    </p>
<p>对于标准服务进程，为他分配固定端口号，对于临时启动的user应用，临时分配端口号。</p>
<h3 id="Socket通信（套接口）："><a href="#Socket通信（套接口）：" class="headerlink" title="Socket通信（套接口）："></a>Socket通信（套接口）：</h3><p>一个进程有一个或多个套接字，套接字是网络和应用程序之间数据传递的门户。<br>接受主机的运输层是吧数据报中的数据缴费给正确的套接字，这个过程就叫做多路分解。主机上每个套接字有一个端口，传输层检查报头的目的端口号，找到对应port端口，并将应用层数据报定向给对应的套接字。     当我们开发一个新的应用程序的时候，必须分配一个端口号。<br>两步走，第一步先根据IP地址找到响应主机，然后再通过找到对应的端口号，找到通信对手方的应用。是由UNIX系统提出来的，用套接口来标识用户进程通信的端点。</p>
<p><img src="13.png"></p>
<p>端口号是传输层的进程的寻址依据。</p>
<p>应用层–TCP加TCP头部形成TCP报文–再加IP头部 形成分组 — 再被链路层封装成帧<br><img src="14.png"><br>源端口号码和目的端口号 各15位。偏移单位是4字节，存储的是TCP首部长度/4的值<br>标志  URG紧急指针域 CK确认域有效即确认号有效  psh字段为1则不比缓冲区满即可上传  RST 复位用于崩溃或错误连接  SYN用于建立连接时使用的同步序号   FIN表示发送方到大数据结尾 请求断开连接</p>
<h3 id="TCP的差错控制："><a href="#TCP的差错控制：" class="headerlink" title="TCP的差错控制："></a>TCP的差错控制：</h3><p>是一种回退N GBN和选择重传SR协议的混合体，TCP接收方有选择的确认失序报文，而不是累计的确认最后一个正确接收的有序报文段。当该机制与选择重传机制结合起来的时候，也就是跳过重传哪些已经被接收方选择性确认过的报文段。 </p>
<h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>使用选择重传ARQ 选择滑动窗口。TCP协议是面向字节流的，所以他的序列号是上一个序列号加上上一个报文中有多少字节数。 TCP头部里的窗口是接收方向发送方发送的用于控制发送方发送的报文段的尺寸的。防止接收端缓冲溢出。</p>
<h3 id="传输层的UDP协议"><a href="#传输层的UDP协议" class="headerlink" title="传输层的UDP协议"></a>传输层的UDP协议</h3><p>用户数据报服务。无连接的数据报服务协议，也就是在与通信方没有建立连接的的情况下发送出去，并且也不提供序号服务和流量控制功能。</p>
<p>使用场合： 实时数据传输，节省了建立/释放连接和重传的开销。 有应用层自己解决和纠错问题。   </p>
<p>流程：发送端：分配源端口、指定宿端口，构造UDP数据报，交个IP<br>    接收端： 匹配UDP头部宿端口的硬应用程序，匹配成功后，数据报排入相应的队列，若端口队列满<br>    了，则丢弃数据报。匹配不成功 就丢弃数据报，回送“宿端口不可达”的ICMP报文<br>UDP头部：<br><img src="15.png"></p>
<p>传输层在不保证可靠性的情况下可以考虑使用UDP 因为其简单高效容易实现。</p>
<h2 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h2><h3 id="EMAIL工作模型："><a href="#EMAIL工作模型：" class="headerlink" title="EMAIL工作模型："></a>EMAIL工作模型：</h3><p>Email由源主机向原邮件服务器发送，再向目的邮件服务器，再向目的主机发送。</p>
<p><img src="16.png"></p>
<p>Email 由两部分组成 header+body 刚开始发送Email有诸多限制，之后，出台了MIME，修订了原来的很多限制和要求，使得可以发送非标准ACSII和对邮件长度不限制，还可以传输图片 声音等一些文件。<br><img src="17.png"></p>
<h3 id="SMTP-简单邮件协议："><a href="#SMTP-简单邮件协议：" class="headerlink" title="SMTP 简单邮件协议："></a>SMTP 简单邮件协议：</h3><p>server服务器在25号端口上监听，有连接请求时，接受连接，然后传输邮件，传输完毕后再将连接断开。这是个纯ASCII字符的协议。<br>个人计算机没有固定域名和IP地址，因此不可以做为SMTP的服务器。</p>
<h3 id="POP3协议（一个邮件代理协议）："><a href="#POP3协议（一个邮件代理协议）：" class="headerlink" title="POP3协议（一个邮件代理协议）："></a>POP3协议（一个邮件代理协议）：</h3><p>server服务器监听110号端口上监听，有连接请求时，接受并与之建立，TCP连接，然后用户就需要提供用户名 密码和需要取出的邮件序号，然后serve会把这个邮件按照用户名提供的地址找到，然后传输邮件，传输完毕后再将连接断开。这个就是用户取邮件的时候的一个简单邮件协议。因为取邮件的时候无法使用SMTP协议。</p>
<h3 id="文件传输协议FTP协议：FILE-Transform"><a href="#文件传输协议FTP协议：FILE-Transform" class="headerlink" title="文件传输协议FTP协议：FILE Transform"></a>文件传输协议FTP协议：FILE Transform</h3><p>一个实例： QQ的离线文件传输<br>用户接口–发送需求和命令—-用户协议的解析器解析用户的指令和需求—与文件服务器建立连接====文件服务器的21号端口（这个端口用于命令的传输）—-在本地系统找到该文件 —然后20号端口用于数据的传输–</p>
<h3 id="WWW应用"><a href="#WWW应用" class="headerlink" title="WWW应用"></a>WWW应用</h3><p>超文本标记语言(HTML)把信息组织成为图文并茂的超文本<br>超链接，起于1989年。在Internet上，标识唯一的主机我们用IP地址，标识唯一的进程我们使用端口号POrt号，二者结合就可以标识唯一的在Internet上的一个进程     </p>
<p>异构计算机上展示的内容是相同的，这是通过运行同一种解析器，使得能够运行解析器的解析出来的文档风格是相同的。  </p>
<p>当代高性能服Web服务器，通常只是用一个进程，但是为了每个新的客户连接创造一个具有新连接套接字的新线程，对于一台这样的服务器，他可能同时拥有多个连接套接字连接到相同的进程。</p>
<h3 id="标识WWW网页："><a href="#标识WWW网页：" class="headerlink" title="标识WWW网页："></a>标识WWW网页：</h3><p>URL uniform resource locator 是对能从Internet上得到的资源的位置和访问方法的一种简洁表示。    </p>
<pre><code>格式是   &lt;访问方式&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt; 
</code></pre>
<p>WWW 服务器server 会打开80端口，与客户机实现TCP连接，客户机将自己要访问的WWW地址发给服务器，这个服务器会在自己的HTML文档中找到对应文档，然后返回给客户端。</p>
<p>我们平时用HTML方式下的 http://主机（www..com）  平时浏览器会自动设置默认端口80 所以端口后面不用写了，如果有些服务器不是打开这个端口的，比如8080端口 就可以写 ：8080</p>
<h3 id="HTML语言"><a href="#HTML语言" class="headerlink" title="HTML语言"></a>HTML语言</h3><p>超文本的标记语言  是一种标记语言，HTML文档使用标签Tag + body组成<br>采用HTML语言，可以让异构的计算机客户端，使用解析和解释器就能得到相同风格的网页文本</p>
<h3 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h3><p>超文本传输协议  用户和服务器之间传输文档的时候用HTTP协议，也是一个纯文本协议。基于TCP连接。<br>由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。     </p>
<p>HTTP使用TCP而不是UDP的原因在于（打开）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。</p>
<h2 id="DNS-域名系统"><a href="#DNS-域名系统" class="headerlink" title="DNS 域名系统"></a>DNS 域名系统</h2><p>Internet上每台主机的标识是他的唯一的IP地址。但是我们不一定都知道主机地址，因为在Internet上有一个将主机名和IP地址互相转换的应用层协议 DNS协议。 DNS的作用就是将主机名字转换为二进制IP地址。</p>
<p>Internet里的域名系统被设计成一个联机分布数据库系统，DNS采用客户服务器模式。客户提出请求，服务器返回对应的IP地址。DNS服务器由若干个域名服务器组成，大多数域名的转换都是在本地映射，少数域名在Internet上网上通信映射。</p>
<h3 id="Internet的域名结构"><a href="#Internet的域名结构" class="headerlink" title="Internet的域名结构"></a>Internet的域名结构</h3><p>域名结构 采用层次树状结构的命名方法<br>域名的结构由若干个分量组成，各分量之间用点隔开<br>每一级域名由英文字母和数字组成  不分大小写 《63个字符   最低级的域名在最左边  最顶级在右边</p>
<p>顶级域名分为：国际顶级域名 （国际组织） 国家顶级域名 CN  US  ton共顶级域名  </p>
<p>绝对域名就是一直写到顶级域名    </p>
<h3 id="DNS服务查询流程"><a href="#DNS服务查询流程" class="headerlink" title="DNS服务查询流程"></a>DNS服务查询流程</h3><p>客户机发出某查询域名IP地址请求，本地DNS服务器如果查不到就会询问上一级服务器，然后上一级服务器找到对应的DNS服务器，把这个地址返回给本地的DNS服务器，本地的DNS服务器会去向这个DNS服务器发送IP地址查询请求。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://andrekuu.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/" data-id="cknscjo0t0007egve3q6311s5" data-title="计算机网络细节" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-LeetCode-周赛总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/22/LeetCode-%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2021-04-21T19:41:24.000Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/22/LeetCode-%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/">LeetCode 周赛总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="名次：-883-4801-（AC-3道）-Bug-1次"><a href="#名次：-883-4801-（AC-3道）-Bug-1次" class="headerlink" title="名次： 883 / 4801  （AC 3道） Bug 1次"></a><em>名次： 883 / 4801  （AC 3道） Bug 1次</em></h2><h2 id="反思："><a href="#反思：" class="headerlink" title="反思："></a>反思：</h2><p>这次周赛总体来说非常简单，名次大退步，全部题目都有思路，而且实现起来不复杂，上来就有思路了都，但是出了大问题，一个是第三题提交到了Pyhton2上白白bug了一次，一个是第四题，有问题居燃花了1个小时检查出来，记住记住！！！！<strong>初始化也是可能出问题的，一定要考虑初始化的数据是不是会错过一些判断条件！！！！！！</strong>   </p>
<p>第一题明显复杂度不高的情况，没必要上来就剪枝优化，simply is better！  </p>
<h3 id="5701-仅执行一次字符串交换能否使两个字符串相等"><a href="#5701-仅执行一次字符串交换能否使两个字符串相等" class="headerlink" title="5701. 仅执行一次字符串交换能否使两个字符串相等"></a>5701. 仅执行一次字符串交换能否使两个字符串相等</h3><p>给你长度相等的两个字符串 s1 和 s2 。一次 字符串交换 操作的步骤如下：选出某个字符串中的两个下标（不必不同），并交换这两个下标所对应的字符。<br>如果对 其中一个字符串 执行 最多一次字符串交换 就可以使两个字符串相等，返回 true ；否则，返回 false 。</p>
<p>示例 1：<br>输入：s1 = “bank”, s2 = “kanb”<br>输出：true<br>解释：例如，交换 s2 中的第一个和最后一个字符可以得到 “bank”<br>示例 2：<br>输入：s1 = “attack”, s2 = “defend”<br>输出：false<br>解释：一次字符串交换无法使两个字符串相等<br>示例 3：<br>输入：s1 = “kelb”, s2 = “kelb”<br>输出：true<br>解释：两个字符串已经相等，所以不需要进行字符串交换<br>示例 4：<br>输入：s1 = “abcd”, s2 = “dcba”<br>输出：false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def areAlmostEqual(self, s1: str, s2: str) -&gt; bool:</span><br><span class="line">        n, m &#x3D; len(s1), len(s2)</span><br><span class="line">        lst1, lst2 &#x3D; [0] * 26, [0] * 26</span><br><span class="line">        count &#x3D; 0</span><br><span class="line">        if n !&#x3D; m:</span><br><span class="line">            return False</span><br><span class="line">        for i in s1:</span><br><span class="line">            lst1[ord(i) - ord(&#39;a&#39;)] +&#x3D; 1</span><br><span class="line">        for i in s2:</span><br><span class="line">            lst2[ord(i) - ord(&#39;a&#39;)] +&#x3D; 1</span><br><span class="line">        if lst1 !&#x3D; lst2:</span><br><span class="line">            return False</span><br><span class="line">        for i in range(n):</span><br><span class="line">            if s1[i] !&#x3D; s2[i]:</span><br><span class="line">                count +&#x3D; 1</span><br><span class="line">        return count &lt;&#x3D; 2</span><br></pre></td></tr></table></figure>
<p>其实竞赛提交的代码其实有bug的就是我只统计了两个字符串是否相等啊，出现的字符种类是否相等，然后比较出现在相同index位置下不同的次数，这个其实忽视了比如像s1 = “abbbd”, s2 = “abddd”这种，就永远无法使用题目要求的直接执行一次交换位置实现！！！ 所以其实还是要统计两个字符串的字符出现频率和种类都相等，才可能通过题目要求的交换实现。     </p>
<p>第二题更简单了 其实写法上可以更加简单，因为根据题意两条边之间必然会出现一个共同点</p>
<h3 id="5702-找出星型图的中心节点"><a href="#5702-找出星型图的中心节点" class="headerlink" title="5702. 找出星型图的中心节点"></a>5702. 找出星型图的中心节点</h3><p>有一个无向的 星型 图，由 n 个编号从 1 到 n 的节点组成。星型图有一个 中心 节点，并且恰有 n - 1 条边将中心节点与其他每个节点连接起来。<br>给你一个二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示在节点 ui 和 vi 之间存在一条边。请你找出并返回 edges 所表示星型图的中心节点。    </p>
<p>示例 1：<br>输入：edges = [[1,2],[2,3],[4,2]]<br>输出：2<br>解释：如上图所示，节点 2 与其他每个节点都相连，所以节点 2 是中心节点。<br>示例 2：<br>输入：edges = [[1,2],[5,1],[1,3],[1,4]]<br>输出：1<br>提示：<br>3 &lt;= n &lt;= 105<br>edges.length == n - 1<br>edges[i].length == 2<br>1 &lt;= ui, vi &lt;= n<br>ui != vi<br>题目数据给出的 edges 表示一个有效的星型图   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findCenter(self, edges: List[List[int]]) -&gt; int:</span><br><span class="line">        aset &#x3D; set()</span><br><span class="line">        for edge in edges:</span><br><span class="line">            if edge[0] in aset:</span><br><span class="line">                return edge[0]</span><br><span class="line">            if edge[1] in aset:</span><br><span class="line">                return edge[1]</span><br><span class="line">            aset.update(edge)</span><br></pre></td></tr></table></figure>

<h3 id="1792-最大平均通过率"><a href="#1792-最大平均通过率" class="headerlink" title="1792. 最大平均通过率"></a>1792. 最大平均通过率</h3><p>一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 classes ，其中 classes[i] = [passi, totali] ，表示你提前知道了第 i 个班级总共有 totali 个学生，其中只有 passi 个学生可以通过考试。<br>给你一个整数 extraStudents ，表示额外有 extraStudents 个聪明的学生，他们 一定 能通过任何班级的期末考。你需要给这 extraStudents 个学生每人都安排一个班级，使得 所有 班级的 平均 通过率 最大 。<br>一个班级的 通过率 等于这个班级通过考试的学生人数除以这个班级的总人数。平均通过率 是所有班级的通过率之和除以班级数目。<br>请你返回在安排这 extraStudents 个学生去对应班级后的 最大 平均通过率。与标准答案误差范围在 10-5 以内的结果都会视为正确结果。<br>示例 1：</p>
<p>输入：classes = [[1,2],[3,5],[2,2]], extraStudents = 2<br>输出：0.78333<br>解释：你可以将额外的两个学生都安排到第一个班级，平均通过率为 (3/4 + 3/5 + 2/2) / 3 = 0.78333 。<br>示例 2：    </p>
<p>输入：classes = [[2,4],[3,9],[4,5],[2,10]], extraStudents = 4<br>输出：0.53485    </p>
<p>提示：</p>
<p>1 &lt;= classes.length &lt;= 105<br>classes[i].length == 2<br>1 &lt;= passi &lt;= totali &lt;= 105<br>1 &lt;= extraStudents &lt;= 105   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 我的思路是统计所有增加率的变化值变化，排序每次取最大的变化率的实现插入一个人，然后在插入回队列</span><br><span class="line">class Solution:</span><br><span class="line">    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -&gt; float:</span><br><span class="line">        for i in classes:</span><br><span class="line">            i.append((i[0]+1)&#x2F;(i[1]+1) - i[0]&#x2F;i[1])</span><br><span class="line">        classes.sort(key&#x3D;lambda x:x[2])</span><br><span class="line">        def insort(s, lst, key &#x3D; 0):</span><br><span class="line">            left, right &#x3D; 0, len(lst)</span><br><span class="line">            while left &lt; right:</span><br><span class="line">                mid &#x3D; left + (right - left)&#x2F;&#x2F;2</span><br><span class="line">                if lst[mid][key] &lt; s[key]:</span><br><span class="line">                    left &#x3D; mid + 1</span><br><span class="line">                else:</span><br><span class="line">                    right &#x3D; mid</span><br><span class="line">            lst.insert(left, s) </span><br><span class="line">        for _ in range(extraStudents):</span><br><span class="line">            temp &#x3D; classes.pop()</span><br><span class="line">            temp &#x3D; [temp[0]+1, temp[1]+1, (temp[0]+2)&#x2F;(temp[1]+2) - (temp[0]+1)&#x2F;(temp[1]+1)]</span><br><span class="line">            insort(temp, classes, 2)</span><br><span class="line">        sum &#x3D; 0</span><br><span class="line">        for i in classes:</span><br><span class="line">            sum +&#x3D; i[0]&#x2F;i[1]</span><br><span class="line">        return sum&#x2F;len(classes)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 另一种做法是 大根堆，效率高很多。</span><br><span class="line">class Solution:</span><br><span class="line">    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -&gt; float:</span><br><span class="line">        diff &#x3D; lambda x, y: (x + 1) &#x2F; (y + 1) - x &#x2F; y</span><br><span class="line">        </span><br><span class="line">        q &#x3D; list()</span><br><span class="line">        ans &#x3D; 0.</span><br><span class="line">        for x, y in classes:</span><br><span class="line">            ans +&#x3D; x &#x2F; y</span><br><span class="line">            # python 中的优先队列是小根堆，所以要对增加量取相反数，达到大根堆的效果</span><br><span class="line">            q.append((-diff(x, y), x, y))</span><br><span class="line">        </span><br><span class="line">        heapq.heapify(q)</span><br><span class="line">        </span><br><span class="line">        for _ in range(extraStudents):</span><br><span class="line">            d, x, y &#x3D; heapq.heappop(q)</span><br><span class="line">            ans +&#x3D; -d</span><br><span class="line">            heapq.heappush(q, (-diff(x + 1, y + 1), x + 1, y + 1))</span><br><span class="line">        </span><br><span class="line">        return ans &#x2F; len(classes)</span><br></pre></td></tr></table></figure>


<h3 id="1793-好子数组的最大分数"><a href="#1793-好子数组的最大分数" class="headerlink" title="1793. 好子数组的最大分数"></a>1793. 好子数组的最大分数</h3><p>给你一个整数数组 nums （下标从 0 开始）和一个整数 k 。    </p>
<p>一个子数组 (i, j) 的 分数 定义为 min(nums[i], nums[i+1], …, nums[j]) * (j - i + 1) 。一个 好 子数组的两个端点下标需要满足 i &lt;= k &lt;= j 。      </p>
<p>请你返回 好 子数组的最大可能 分数 。       </p>
<p>示例 1： </p>
<p>输入：nums = [1,4,3,7,4,5], k = 3<br>输出：15<br>解释：最优子数组的左右端点下标是 (1, 5) ，分数为 min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15 。<br>示例 2：  </p>
<p>输入：nums = [5,5,4,5,4,1,1,1], k = 0<br>输出：20<br>解释：最优子数组的左右端点下标是 (0, 4) ，分数为 min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20 。  </p>
<p>提示：  </p>
<p>1 &lt;= nums.length &lt;= 105<br>1 &lt;= nums[i] &lt;= 2 * 104<br>0 &lt;= k &lt; nums.length   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 思路是维护window的边界扩展时贪心算法，两者最大的 </span><br><span class="line">class Solution:</span><br><span class="line">    def maximumScore(self, nums: List[int], k: int) -&gt; int:</span><br><span class="line">        i, j, temp &#x3D; k, k, 1</span><br><span class="line">        n &#x3D; len(nums)</span><br><span class="line">        min_temp &#x3D; nums[k]</span><br><span class="line">        res &#x3D; nums[k]</span><br><span class="line">        while i &gt; 0 and j &lt; n -1:</span><br><span class="line">            temp +&#x3D; 1</span><br><span class="line">            if nums[i - 1] &lt;&#x3D; nums[j + 1]:</span><br><span class="line">                j +&#x3D; 1</span><br><span class="line">                min_temp &#x3D; min(nums[j], min_temp)</span><br><span class="line">            else:</span><br><span class="line">                i -&#x3D; 1</span><br><span class="line">                min_temp &#x3D; min(nums[i], min_temp)</span><br><span class="line">            res &#x3D; max(res, temp * min_temp)</span><br><span class="line">        if not i:</span><br><span class="line">            for k in range(j + 1, n):</span><br><span class="line">                min_temp &#x3D; min(nums[k], min_temp)</span><br><span class="line">                temp +&#x3D; 1</span><br><span class="line">                res &#x3D; max(res, temp * min_temp)</span><br><span class="line">        else:</span><br><span class="line">            for k in range(i-1, -1, -1):</span><br><span class="line">                min_temp &#x3D; min(nums[k], min_temp)</span><br><span class="line">                temp +&#x3D; 1</span><br><span class="line">                res &#x3D; max(res, temp * min_temp)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 当然也不用每次相乘判断，只有当最小值更新的时候才需要更新res 所以可以剪枝</span><br><span class="line">class Solution:</span><br><span class="line">    def maximumScore(self, nums: List[int], k: int) -&gt; int:</span><br><span class="line">        l &#x3D; k #左边界</span><br><span class="line">        r &#x3D; k #右边界</span><br><span class="line">        n &#x3D; len(nums) #数组长度</span><br><span class="line">        res &#x3D; 0 #最大可能分数</span><br><span class="line">        while 1 :</span><br><span class="line">            while r &lt; n and nums[r] &gt;&#x3D; nums[k]:</span><br><span class="line">                r +&#x3D; 1 #向右寻找以nums[k]为最小值的好子数组</span><br><span class="line">            while l &gt;&#x3D; 0 and nums[l] &gt;&#x3D; nums[k]:</span><br><span class="line">                l -&#x3D; 1 #向左寻找以nums[k]为最小值的好子数组</span><br><span class="line">            res &#x3D; max(res, (r - l - 1) * nums[k]) #更新最大可能分数</span><br><span class="line">            if l &lt; 0 and r &#x3D;&#x3D; n: #遍历完数组，退出循环</span><br><span class="line">                break</span><br><span class="line">            if l &gt;&#x3D; 0 and r &lt; n: #贪心，更新nums[k]为左右边界中的较大者</span><br><span class="line">                nums[k] &#x3D; max(nums[l], nums[r]) </span><br><span class="line">            elif l &lt; 0: #左边已遍历完，更新为右边界</span><br><span class="line">                nums[k] &#x3D; nums[r]</span><br><span class="line">            else: #右边已遍历完，更新左边界</span><br><span class="line">                nums[k] &#x3D; nums[l]</span><br><span class="line">        return res</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="名次：-794-2853-（AC-2道）-Bug-1次"><a href="#名次：-794-2853-（AC-2道）-Bug-1次" class="headerlink" title="名次： 794 / 2853  （AC 2道） Bug 1次"></a><em>名次： 794 / 2853  （AC 2道） Bug 1次</em></h2><h2 id="反思：-1"><a href="#反思：-1" class="headerlink" title="反思："></a>反思：</h2><p>审题不清，第一道题的罚时是因为输出int没转换为str，输入输出格式为什么不检查一下在提交，不差这几秒；第三道题，求得结果自己脑海先入为主，复杂化了问题，读清楚题目求什么好么？<br>看了一眼前100的选手，大部分都是1000+  自己题量不够天赋还没有，还不懂差距在哪里么？</p>
<p>第一题是个统计排序的题 可以用很多种排序方法实现，但是因为只是数字1-9，可以直接去重最后sorted()如果数据很大，可以考虑用堆排序，插入堆。</p>
<h3 id="字符串中第二大的数字"><a href="#字符串中第二大的数字" class="headerlink" title="字符串中第二大的数字"></a>字符串中第二大的数字</h3><p>给你一个混合字符串 s ，请你返回 s 中 第二大 的数字，如果不存在第二大的数字，请你返回 -1 。</p>
<p>混合字符串 由小写英文字母和数字组成。<br>示例 1：</p>
<p>输入：s = “dfa12321afd”<br>输出：2<br>解释：出现在 s 中的数字包括 [1, 2, 3] 。第二大的数字是 2 。<br>示例 2：   </p>
<p>输入：s = “abc1111”<br>输出：-1<br>解释：出现在 s 中的数字只包含 [1] 。没有第二大的数字。   
    </p>
<p>提示：</p>
<p>1 &lt;= s.length &lt;= 500<br>s 只包含小写英文字母和（或）数字。   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def secondHighest(self, s: str) -&gt; int:</span><br><span class="line">        table &#x3D; set()</span><br><span class="line">        for token in s:</span><br><span class="line">            if token.isdigit():</span><br><span class="line">                table.add(token)</span><br><span class="line">        if len(table) &lt; 2:</span><br><span class="line">            return -1</span><br><span class="line">        return int(sorted(table)[-2])</span><br></pre></td></tr></table></figure>

<p>第二题题目非常复杂和冗长，设计类的一个题。 先入先出的这样的一个结构。但是又涉及项目更新，所以想法应该还是往字典上走。  </p>
<h3 id="设计一个验证系统"><a href="#设计一个验证系统" class="headerlink" title="设计一个验证系统"></a>设计一个验证系统</h3><p>你需要设计一个包含验证码的验证系统。每一次验证中，用户会收到一个新的验证码，这个验证码在 currentTime 时刻之后 timeToLive 秒过期。如果验证码被更新了，那么它会在 currentTime （可能与之前的 currentTime 不同）时刻延长 timeToLive 秒。  </p>
<p>请你实现 AuthenticationManager 类：    </p>
<p>AuthenticationManager(int timeToLive) 构造 AuthenticationManager 并设置 timeToLive 参数。<br>generate(string tokenId, int currentTime) 给定 tokenId ，在当前时间 currentTime 生成一个新的验证码。<br>renew(string tokenId, int currentTime) 将给定 tokenId 且 未过期 的验证码在 currentTime 时刻更新。如果给定 tokenId 对应的验证码不存在或已过期，请你忽略该操作，不会有任何更新操作发生。<br>countUnexpiredTokens(int currentTime) 请返回在给定 currentTime 时刻，未过期 的验证码数目。<br>如果一个验证码在时刻 t 过期，且另一个操作恰好在时刻 t 发生（renew 或者 countUnexpiredTokens 操作），过期事件 优先于 其他操作。     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 哈希表</span><br><span class="line">class AuthenticationManager:</span><br><span class="line"></span><br><span class="line">    def __init__(self, timeToLive: int):</span><br><span class="line">        self.limit &#x3D; timeToLive</span><br><span class="line">        self.table &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    def generate(self, tokenId: str, currentTime: int) -&gt; None:</span><br><span class="line">        self.table[tokenId] &#x3D; currentTime</span><br><span class="line"></span><br><span class="line">    def renew(self, tokenId: str, currentTime: int) -&gt; None:</span><br><span class="line">        if tokenId in self.table:</span><br><span class="line">            if currentTime - self.table[tokenId] &lt; self.limit:</span><br><span class="line">                self.table[tokenId] &#x3D; currentTime</span><br><span class="line">            else:</span><br><span class="line">                self.table.pop(tokenId)</span><br><span class="line"></span><br><span class="line">    def countUnexpiredTokens(self, currentTime: int) -&gt; int:</span><br><span class="line">        temp &#x3D; sorted(self.table.items(), key&#x3D;lambda x: x[1], reverse&#x3D;True)</span><br><span class="line">        timedelete &#x3D; currentTime - self.limit</span><br><span class="line">        for i in range(len(self.table) - 1, -1, -1):</span><br><span class="line">            if temp[i][1] &lt;&#x3D; timedelete:</span><br><span class="line">                self.table.pop(temp[i][0])</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line">        return len(self.table)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self, val&#x3D;0, key&#x3D;None, prev&#x3D;None, nxt&#x3D;None):</span><br><span class="line">        self.expire &#x3D; val</span><br><span class="line">        self.key &#x3D; key</span><br><span class="line">        self.prev &#x3D; prev</span><br><span class="line">        self.next &#x3D; nxt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class AuthenticationManager:</span><br><span class="line"></span><br><span class="line">    def __init__(self, timeToLive: int):</span><br><span class="line">        self.ttl &#x3D; timeToLive</span><br><span class="line">        self.head &#x3D; Node(-1)</span><br><span class="line">        self.tail &#x3D; Node(-1)</span><br><span class="line">        self.head.next &#x3D; self.tail</span><br><span class="line">        self.tail.prev &#x3D; self.head</span><br><span class="line">        self.map &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    # 新建一个节点，塞到链表最后面，添加到哈希表里</span><br><span class="line">    def generate(self, tokenId: str, currentTime: int) -&gt; None:</span><br><span class="line">        node &#x3D; Node(currentTime + self.ttl, tokenId)</span><br><span class="line">        self.map[tokenId] &#x3D; node</span><br><span class="line"></span><br><span class="line">        # 塞到最后</span><br><span class="line">        last &#x3D; self.tail.prev</span><br><span class="line">        last.next &#x3D; node</span><br><span class="line">        node.prev &#x3D; last</span><br><span class="line">        self.tail.prev &#x3D; node</span><br><span class="line">        node.next &#x3D; self.tail</span><br><span class="line"></span><br><span class="line">    # 如果这个节点存在且没有过期，那么把这个节点找出来，更新过期时间，塞到最后</span><br><span class="line">    def renew(self, tokenId: str, currentTime: int) -&gt; None:</span><br><span class="line">        if tokenId in self.map and self.map[tokenId].expire &gt; currentTime:</span><br><span class="line">            # 从原来的地方取出来</span><br><span class="line">            node &#x3D; self.map[tokenId]</span><br><span class="line">            prev &#x3D; node.prev</span><br><span class="line">            nxt &#x3D; node.next</span><br><span class="line">            prev.next &#x3D; nxt</span><br><span class="line">            nxt.prev &#x3D; prev</span><br><span class="line">            # 更新过期时间</span><br><span class="line">            node.expire &#x3D; currentTime + self.ttl</span><br><span class="line">            # 塞到最后</span><br><span class="line">            last &#x3D; self.tail.prev</span><br><span class="line">            last.next &#x3D; node</span><br><span class="line">            node.prev &#x3D; last</span><br><span class="line">            self.tail.prev &#x3D; node</span><br><span class="line">            node.next &#x3D; self.tail</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # 在双向链表里把所有过期的节点删了，在哈希表里也删掉，返回长度</span><br><span class="line">    def countUnexpiredTokens(self, currentTime: int) -&gt; int:</span><br><span class="line">        while self.head.next.expire !&#x3D; -1 and self.head.next.expire &lt;&#x3D; currentTime:</span><br><span class="line">            node &#x3D; self.head.next</span><br><span class="line">            self.map.pop(node.key)</span><br><span class="line">            self.head.next &#x3D; node.next</span><br><span class="line">            node.next.prev &#x3D; self.head</span><br><span class="line">        return len(self.map)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>第三题是个有点脑筋急转弯+动态规划的题，这题竞赛的时候居然思考复杂化了，题目要求求的没读清楚，这个只要求从0开始的，最大整数，看清楚题目好么。<br>当思考陷入困局的时候，回头看一遍题目需求和条件！   </p>
<h3 id="你能构造出连续值的最大数目"><a href="#你能构造出连续值的最大数目" class="headerlink" title="你能构造出连续值的最大数目"></a>你能构造出连续值的最大数目</h3><p>给你一个长度为 n 的整数数组 coins ，它代表你拥有的 n 个硬币。第 i 个硬币的值为 coins[i] 。如果你从这些硬币中选出一部分硬币，它们的和为 x ，那么称，你可以 构造 出 x 。   </p>
<p>请返回从 0 开始（包括 0 ），你最多能 构造 出多少个连续整数。     </p>
<p>你可能有多个相同值的硬币。   </p>
<p> </p>
<p>示例 1：   </p>
<p>输入：coins = [1,3]<br>输出：2<br>解释：你可以得到以下这些值：   </p>
<ul>
<li>0：什么都不取 []</li>
<li>1：取 [1]<br>从 0 开始，你可以构造出 2 个连续整数。<br>示例 2：</li>
</ul>
<p>输入：coins = [1,1,1,4]<br>输出：8<br>解释：你可以得到以下这些值：  </p>
<ul>
<li>0：什么都不取 [] </li>
<li>1：取 [1]     </li>
<li>2：取 [1,1]  </li>
<li>3：取 [1,1,1]   </li>
<li>4：取 [4]</li>
<li>5：取 [4,1]   </li>
<li>6：取 [4,1,1]</li>
<li>7：取 [4,1,1,1]<br>从 0 开始，你可以构造出 8 个连续整数。<br>示例 3：  </li>
</ul>
<p>输入：nums = [1,4,10,3,1]<br>输出：20 
    </p>
<p>提示：   </p>
<p>coins.length == n<br>1 &lt;= n &lt;= 4 * 104<br>1 &lt;= coins[i] &lt;= 4 * 104   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def getMaximumConsecutive(self, coins: List[int]) -&gt; int:</span><br><span class="line">        coins.sort()</span><br><span class="line">        count &#x3D; 1</span><br><span class="line">        for coin in coins:</span><br><span class="line">            if coin &lt;&#x3D; count:</span><br><span class="line">                count +&#x3D; coin</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line">        return count</span><br></pre></td></tr></table></figure>

<h2 id="名次：-1032-4996-（AC-3道）-Bug-3次"><a href="#名次：-1032-4996-（AC-3道）-Bug-3次" class="headerlink" title="名次： 1032/4996  （AC 3道） Bug 3次"></a><em>名次： 1032/4996  （AC 3道） Bug 3次</em></h2><h2 id="反思：-2"><a href="#反思：-2" class="headerlink" title="反思："></a>反思：</h2><p>第2道题直接想走捷径，瞎蒙一个，结果1分钟bug三次还是老老实实写的ac，这种就告诉我们欲速则不达，不要靠蒙，除非思路已经很清晰，明确答案确实是个脑筋急转弯。第四道题是实力没有思路就在那里硬写，其实不好，还是要想一想，大概可能的思路，不能硬暴力求解啊。纯浪费时间了。     </p>
<ol>
<li>字符串中不同整数的数目<br>给你一个字符串 word ，该字符串由数字和小写英文字母组成。<br>请你用空格替换每个不是数字的字符。例如，”a123bc34d8ef34” 将会变成 “ 123  34 8  34” 。注意，剩下的这<br>些整数间至少要用一个空格隔开：”123”、”34”、”8” 和 “34” 。<br>返回对 word 完成替换后形成的 不同 整数的数目。<br>如果两个整数的 不含前导零 的十进制表示不同，则认为这两个整数也不同。<br>示例 1：<br>输入：word = “a123bc34d8ef34”<br>输出：3<br>解释：不同的整数有 “123”、”34” 和 “8” 。注意，”34” 只计数一次。<br>示例 2：<br>输入：word = “leet1234code234”<br>输出：2<br>示例 3：<br>输入：word = “a1b01c001”<br>输出：1<br>解释：”1”、”01” 和 “001” 视为同一个整数的十进制表示，因为在比较十进制值时会忽略前导零的存在。<br>提示：<br>1 &lt;= word.length &lt;= 1000<br>word 由数字和小写英文字母组成 </li>
</ol>
<h3 id="这题就是一个字符串提取有用信息的问题，不涉及什么算法，主要是一些正常操作，解法也很多。对于python而言可以用re模块的正则表达式直接split提取，也可以正常的符合条件的扫描入一个去重的集合。有个小坑就是-001-和01这种-是一个数，不过示例中也给了所以可以规避。注意审题。"><a href="#这题就是一个字符串提取有用信息的问题，不涉及什么算法，主要是一些正常操作，解法也很多。对于python而言可以用re模块的正则表达式直接split提取，也可以正常的符合条件的扫描入一个去重的集合。有个小坑就是-001-和01这种-是一个数，不过示例中也给了所以可以规避。注意审题。" class="headerlink" title="这题就是一个字符串提取有用信息的问题，不涉及什么算法，主要是一些正常操作，解法也很多。对于python而言可以用re模块的正则表达式直接split提取，也可以正常的符合条件的扫描入一个去重的集合。有个小坑就是 001 和01这种 是一个数，不过示例中也给了所以可以规避。注意审题。"></a>这题就是一个字符串提取有用信息的问题，不涉及什么算法，主要是一些正常操作，解法也很多。对于python而言可以用re模块的正则表达式直接split提取，也可以正常的符合条件的扫描入一个去重的集合。有个小坑就是 001 和01这种 是一个数，不过示例中也给了所以可以规避。注意审题。</h3><p>这种字符串提取，while一般都更好用一些</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def numDifferentIntegers(self, word: str) -&gt; int:</span><br><span class="line">        aset &#x3D; set()</span><br><span class="line">        i &#x3D; 0</span><br><span class="line">        while i &lt; len(word):</span><br><span class="line">            if word[i].isdigit():</span><br><span class="line">                idx, i &#x3D; i, i + 1</span><br><span class="line">                while i &lt; len(word) and word[i].isdigit():</span><br><span class="line">                    i +&#x3D; 1</span><br><span class="line">                else:</span><br><span class="line">                    aset.add(int(word[idx:i]))</span><br><span class="line">            i +&#x3D; 1</span><br><span class="line">        return len(aset)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def numDifferentIntegers(self, word: str) -&gt; int:</span><br><span class="line">        lst &#x3D; list(word)</span><br><span class="line">        table &#x3D; set()</span><br><span class="line">        mystr &#x3D; &quot;&quot;</span><br><span class="line">        for i in lst:</span><br><span class="line">            if i.isdigit():</span><br><span class="line">                mystr +&#x3D; i</span><br><span class="line">            else:</span><br><span class="line">                if mystr:</span><br><span class="line">                    table.add(int(mystr))</span><br><span class="line">                    mystr &#x3D; &quot;&quot;</span><br><span class="line">        if mystr:</span><br><span class="line">            table.add(int(mystr))  </span><br><span class="line">        return len(table)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">class Solution:</span><br><span class="line">    def numDifferentIntegers(self, word: str) -&gt; int:</span><br><span class="line">        res &#x3D; re.split(r&#39;[a-z]+&#39;, word)</span><br><span class="line">        return len(set(int(i) for i in res if i !&#x3D; &#39;&#39;))</span><br></pre></td></tr></table></figure>


<p>2.还原排列的最少操作步数<br>给你一个偶数 n​​​​​​ ，已知存在一个长度为 n 的排列 perm ，其中 perm[i] == i​（下标 从 0 开始 计数）。<br>一步操作中，你将创建一个新数组 arr ，对于每个 i ：<br>如果 i % 2 == 0 ，那么 arr[i] = perm[i / 2]<br>如果 i % 2 == 1 ，那么 arr[i] = perm[n / 2 + (i - 1) / 2]<br>然后将 arr​​ 赋值​​给 perm 。<br>要想使 perm 回到排列初始值，至少需要执行多少步操作？返回最小的 非零 操作步数。<br>示例 1：<br>输入：n = 2<br>输出：1<br>解释：最初，perm = [0,1]<br>第 1 步操作后，perm = [0,1]<br>所以，仅需执行 1 步操作<br>示例 2：<br>输入：n = 4<br>输出：2<br>解释：最初，perm = [0,1,2,3]<br>第 1 步操作后，perm = [0,2,1,3]<br>第 2 步操作后，perm = [0,1,2,3]<br>所以，仅需执行 2 步操作<br>示例 3：<br>输入：n = 6<br>输出：4<br>提示：<br>2 &lt;= n &lt;= 1000<br>n​​​​​​ 是一个偶数   </p>
<p>无脑模拟     有很多神牛的解法  数学方法我就先不学习了 有点难理解。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reinitializePermutation(self, n: int) -&gt; int:</span><br><span class="line">        count &#x3D; 1</span><br><span class="line">        lst &#x3D; list(range(n))</span><br><span class="line">        tmp &#x3D; lst.copy()</span><br><span class="line">        alst &#x3D; lst.copy()</span><br><span class="line">        for i in range(n):</span><br><span class="line">            if i ^ 1:</span><br><span class="line">                alst[i] &#x3D; tmp[n &#x2F;&#x2F; 2 + (i - 1) &#x2F;&#x2F; 2]</span><br><span class="line">                continue</span><br><span class="line">            alst[i] &#x3D; tmp[i &#x2F;&#x2F; 2]</span><br><span class="line">        while alst !&#x3D; lst:</span><br><span class="line">            tmp &#x3D; alst.copy()</span><br><span class="line">            for i in range(n):</span><br><span class="line">                if i ^ 1:</span><br><span class="line">                    alst[i] &#x3D; tmp[n &#x2F;&#x2F; 2 + (i - 1) &#x2F;&#x2F; 2]</span><br><span class="line">                else:</span><br><span class="line">                    alst[i] &#x3D; tmp[i &#x2F;&#x2F; 2]</span><br><span class="line">            count +&#x3D; 1</span><br><span class="line">        return count</span><br></pre></td></tr></table></figure>
<p>如果两倍在n以内，就到两倍的位置，否则就到乘2-n+1（奇数）位置。 反过来看。。。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def reinitializePermutation(self, n):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type n: int</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        ans &#x3D; 1</span><br><span class="line">        mid &#x3D; n &#x2F;&#x2F; 2</span><br><span class="line">        track &#x3D; 1</span><br><span class="line">        while track !&#x3D; mid:</span><br><span class="line">            if track * 2 &lt; n:</span><br><span class="line">                track *&#x3D; 2</span><br><span class="line">            else:</span><br><span class="line">                track &#x3D; track * 2 + 1 - n</span><br><span class="line">            ans +&#x3D; 1</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>


<ol start="3">
<li>替换字符串中的括号内容<br>给你一个字符串 s ，它包含一些括号对，每个括号中包含一个 非空 的键。  </li>
</ol>
<p>比方说，字符串 “(name)is(age)yearsold” 中，有 两个 括号对，分别包含键 “name” 和 “age” 。<br>你知道许多键对应的值，这些关系由二维字符串数组 knowledge 表示，其中 knowledge[i] = [keyi, valuei] ，表示键 keyi 对应的值为 valuei 。<br>你需要替换 所有 的括号对。当你替换一个括号对，且它包含的键为 keyi 时，你需要：<br>将 keyi 和括号用对应的值 valuei 替换。<br>如果从 knowledge 中无法得知某个键对应的值，你需要将 keyi 和括号用问号 “?” 替换（不需要引号）。<br>knowledge 中每个键最多只会出现一次。s 中不会有嵌套的括号。<br>请你返回替换 所有 括号对后的结果字符串。  </p>
<p>示例 1：<br>输入：s = “(name)is(age)yearsold”, knowledge = [[“name”,”bob”],[“age”,”two”]]<br>输出：”bobistwoyearsold”<br>解释：<br>键 “name” 对应的值为 “bob” ，所以将 “(name)” 替换为 “bob” 。<br>键 “age” 对应的值为 “two” ，所以将 “(age)” 替换为 “two” 。<br>示例 2：<br>输入：s = “hi(name)”, knowledge = [[“a”,”b”]]<br>输出：”hi?”<br>解释：由于不知道键 “name” 对应的值，所以用 “?” 替换 “(name)” 。<br>示例 3：<br>输入：s = “(a)(a)(a)aaa”, knowledge = [[“a”,”yes”]]<br>输出：”yesyesyesaaa”<br>解释：相同的键在 s 中可能会出现多次。<br>键 “a” 对应的值为 “yes” ，所以将所有的 “(a)” 替换为 “yes” 。<br>注意，不在括号里的 “a” 不需要被替换。<br>示例 4：<br>输入：s = “(a)(b)”, knowledge = [[“a”,”b”],[“b”,”a”]]<br>输出：”ba”<br>提示：<br>1 &lt;= s.length &lt;= 105<br>0 &lt;= knowledge.length &lt;= 105<br>knowledge[i].length == 2<br>1 &lt;= keyi.length, valuei.length &lt;= 10<br>s 只包含小写英文字母和圆括号 ‘(‘ 和 ‘)’ 。<br>s 中每一个左圆括号 ‘(‘ 都有对应的右圆括号 ‘)’ 。<br>s 中每对括号内的键都不会为空。<br>s 中不会有嵌套括号对。<br>keyi 和 valuei 只包含小写英文字母。<br>knowledge 中的 keyi 不会重复。    </p>
<p>还是一个字符串替换的问题。不涉及什么算法，不过可以用一个比较不错的字符串替换的方式就是replace然后加空格再split</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def evaluate(self, s: str, knowledge) -&gt; str:</span><br><span class="line">        table &#x3D; dict()</span><br><span class="line">        table.update(knowledge)</span><br><span class="line">        res &#x3D; s.replace(&quot;(&quot;, &quot; (&quot;).replace(&quot;)&quot;, &quot;) &quot;).split()</span><br><span class="line">        print(res)</span><br><span class="line">        for i in range(len(res)):</span><br><span class="line">            if res[i][-1] &#x3D;&#x3D; &quot;)&quot;:</span><br><span class="line">                res[i] &#x3D; table.get(res[i][1:-1], &#39;?&#39;)</span><br><span class="line">        return &#39;&#39;.join(res)</span><br></pre></td></tr></table></figure>
<p>直接遍历判断也行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def evaluate(self, s: str, knowledge) -&gt; str:</span><br><span class="line">        table &#x3D; &#123;&#125;</span><br><span class="line">        for key, val in knowledge:</span><br><span class="line">            table[key] &#x3D; val</span><br><span class="line">        res &#x3D; []</span><br><span class="line">        i &#x3D; 0</span><br><span class="line">        while i &lt; len(s):</span><br><span class="line">            if s[i].isalnum():</span><br><span class="line">                res.append(s[i])</span><br><span class="line">                i +&#x3D; 1</span><br><span class="line">                continue</span><br><span class="line">            if s[i] &#x3D;&#x3D; &#39;(&#39;:</span><br><span class="line">                idx &#x3D; i</span><br><span class="line">                i +&#x3D; 1</span><br><span class="line">                while s[i] !&#x3D; &#39;)&#39;:</span><br><span class="line">                    i +&#x3D; 1</span><br><span class="line">                res.append(table.get(s[idx+1:i], &#39;?&#39;))</span><br><span class="line">                i +&#x3D; 1</span><br><span class="line">        return &#39;&#39;.join(res)</span><br></pre></td></tr></table></figure>
<p>2021-4-4—235周赛</p>
<h2 id="名次：-350-4493-（AC-3道）-Bug-1次"><a href="#名次：-350-4493-（AC-3道）-Bug-1次" class="headerlink" title="名次： 350/4493  （AC 3道） Bug 1次"></a><em>名次： 350/4493  （AC 3道） Bug 1次</em></h2><h2 id="反思：-3"><a href="#反思：-3" class="headerlink" title="反思："></a>反思：</h2><p>这次总体正常发挥，但是水平和码速度太慢了 要加强<br>还有老毛病 又忘了求余%10^9+7 下次遇到这种题先写return</p>
<h2 id="第一题-截断句子"><a href="#第一题-截断句子" class="headerlink" title="第一题  截断句子"></a>第一题  截断句子</h2><p>句子 是一个单词列表，列表中的单词之间用单个空格隔开，且不存在前导或尾随空格。每个单词仅由大小写英文字母组成（不含标点符号）。</p>
<p>例如，”Hello World”、”HELLO” 和 “hello world hello world” 都是句子。<br>给你一个句子 s​​​​​​ 和一个整数 k​​​​​​ ，请你将 s​​ 截断 ​，​​​使截断后的句子仅含 前 k​​​​​​ 个单词。返回 截断 s​​​​​​ 后得到的句子。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：s = “Hello how are you Contestant”, k = 4<br>输出：”Hello how are you”<br>解释：<br>s 中的单词为 [“Hello”, “how” “are”, “you”, “Contestant”]<br>前 4 个单词为 [“Hello”, “how”, “are”, “you”]<br>因此，应当返回 “Hello how are you”<br>示例 2：</p>
<p>输入：s = “What is the solution to this problem”, k = 4<br>输出：”What is the solution”<br>解释：<br>s 中的单词为 [“What”, “is” “the”, “solution”, “to”, “this”, “problem”]<br>前 4 个单词为 [“What”, “is”, “the”, “solution”]<br>因此，应当返回 “What is the solution”<br>示例 3：</p>
<p>输入：s = “chopper is not a tanuki”, k = 5<br>输出：”chopper is not a tanuki”
 </p>
<p>提示：</p>
<p>1 &lt;= s.length &lt;= 500<br>k 的取值范围是 [1,  s 中单词的数目]<br>s 仅由大小写英文字母和空格组成<br>s 中的单词之间由单个空格隔开<br>不存在前导或尾随空格</p>
<h3 id="考察字符串处理api接口"><a href="#考察字符串处理api接口" class="headerlink" title="考察字符串处理api接口"></a>考察字符串处理api接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def truncateSentence(self, s: str, k: int) -&gt; str:</span><br><span class="line">        return &quot; &quot;.join(s.split()[:k])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 写也可以写</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def truncateSentence(self, s: str, k: int) -&gt; str:</span><br><span class="line">        lst &#x3D; []</span><br><span class="line">        left &#x3D; 0</span><br><span class="line">        for i in range(len(s)):</span><br><span class="line">            if s[i] &#x3D;&#x3D; &quot; &quot;:</span><br><span class="line">                lst.append(s[left:i])</span><br><span class="line">                if len(lst) &#x3D;&#x3D; k:</span><br><span class="line">                    return &quot; &quot;.join(lst)</span><br><span class="line">                left &#x3D; False</span><br><span class="line">            else:</span><br><span class="line">                if isinstance(left, bool):</span><br><span class="line">                    left &#x3D; i</span><br><span class="line">        return s</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="第二题-查找用户活跃分钟数"><a href="#第二题-查找用户活跃分钟数" class="headerlink" title="第二题 查找用户活跃分钟数"></a>第二题 查找用户活跃分钟数</h2><p>给你用户在 LeetCode 的操作日志，和一个整数 k 。日志用一个二维整数数组 logs 表示，其中每个 logs[i] = [IDi, timei] 表示 ID 为 IDi 的用户在 timei 分钟时执行了某个操作。</p>
<p>多个用户 可以同时执行操作，单个用户可以在同一分钟内执行 多个操作 。</p>
<p>指定用户的 用户活跃分钟数（user active minutes，UAM） 定义为用户对 LeetCode 执行操作的 唯一分钟数 。 即使一分钟内执行多个操作，也只能按一分钟计数。</p>
<p>请你统计用户活跃分钟数的分布情况，统计结果是一个长度为 k 且 下标从 1 开始计数 的数组 answer ，对于每个 j（1 &lt;= j &lt;= k），answer[j] 表示 用户活跃分钟数 等于 j 的用户数。</p>
<p>返回上面描述的答案数组 answer 。</p>
<p> </p>
<p>示例 1：</p>
<p>输入：logs = [[0,5],[1,2],[0,2],[0,5],[1,3]], k = 5<br>输出：[0,2,0,0,0]<br>解释：<br>ID=0 的用户执行操作的分钟分别是：5 、2 和 5 。因此，该用户的用户活跃分钟数为 2（分钟 5 只计数一次）<br>ID=1 的用户执行操作的分钟分别是：2 和 3 。因此，该用户的用户活跃分钟数为 2<br>2 个用户的用户活跃分钟数都是 2 ，answer[2] 为 2 ，其余 answer[j] 的值都是 0<br>示例 2：</p>
<p>输入：logs = [[1,1],[2,2],[2,3]], k = 4<br>输出：[1,1,0,0]<br>解释：<br>ID=1 的用户仅在分钟 1 执行单个操作。因此，该用户的用户活跃分钟数为 1<br>ID=2 的用户执行操作的分钟分别是：2 和 3 。因此，该用户的用户活跃分钟数为 2<br>1 个用户的用户活跃分钟数是 1 ，1 个用户的用户活跃分钟数是 2<br>因此，answer[1] = 1 ，answer[2] = 1 ，其余的值都是 0
 </p>
<p>提示：</p>
<p>1 &lt;= logs.length &lt;= 104<br>0 &lt;= IDi &lt;= 109<br>1 &lt;= timei &lt;= 105<br>k 的取值范围是 [用户的最大用户活跃分钟数, 105]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def findingUsersActiveMinutes(self, logs: List[List[int]], k: int) -&gt; List[int]:</span><br><span class="line">        res &#x3D; list(0 for _ in range(k))</span><br><span class="line">        dic &#x3D; dict()</span><br><span class="line">        for log in logs:</span><br><span class="line">            dic[log[0]] &#x3D; dic.get(log[0], set())|&#123;log[1]&#125;</span><br><span class="line">        for key in dic:</span><br><span class="line">            res[len(dic[key]) - 1] +&#x3D; 1</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>


<h2 id="第三题-绝对差值和"><a href="#第三题-绝对差值和" class="headerlink" title="第三题  绝对差值和"></a>第三题  绝对差值和</h2><p>给你两个正整数数组 nums1 和 nums2 ，数组的长度都是 n 。</p>
<p>数组 nums1 和 nums2 的 绝对差值和 定义为所有 |nums1[i] - nums2[i]|（0 &lt;= i &lt; n）的 总和（下标从 0 开始）。</p>
<p>你可以选用 nums1 中的 任意一个 元素来替换 nums1 中的 至多 一个元素，以 最小化 绝对差值和。</p>
<p>在替换数组 nums1 中最多一个元素 之后 ，返回最小绝对差值和。因为答案可能很大，所以需要对 109 + 7 取余 后返回。</p>
<p>|x| 定义为：</p>
<p>如果 x &gt;= 0 ，值为 x ，或者<br>如果 x &lt;= 0 ，值为 -x
 </p>
<p>示例 1：</p>
<p>输入：nums1 = [1,7,5], nums2 = [2,3,5]<br>输出：3<br>解释：有两种可能的最优方案：</p>
<ul>
<li>将第二个元素替换为第一个元素：[1,7,5] =&gt; [1,1,5] ，或者</li>
<li>将第二个元素替换为第三个元素：[1,7,5] =&gt; [1,5,5]<br>两种方案的绝对差值和都是 |1-2| + (|1-3| 或者 |5-3|) + |5-5| = 3<br>示例 2：</li>
</ul>
<p>输入：nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]<br>输出：0<br>解释：nums1 和 nums2 相等，所以不用替换元素。绝对差值和为 0<br>示例 3：</p>
<p>输入：nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]<br>输出：20<br>解释：将第一个元素替换为第二个元素：[1,10,4,4,2,7] =&gt; [10,10,4,4,2,7]<br>绝对差值和为 |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20
 </p>
<p>提示：</p>
<p>n == nums1.length<br>n == nums2.length<br>1 &lt;= n &lt;= 105<br>1 &lt;= nums1[i], nums2[i] &lt;= 105</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def minAbsoluteSumDiff(self, nums1: List[int], nums2: List[int]) -&gt; int:</span><br><span class="line">        n &#x3D; len(nums1)</span><br><span class="line">        dlst &#x3D; []</span><br><span class="line">        res &#x3D; 0</span><br><span class="line">        for i in range(n):</span><br><span class="line">            tmp &#x3D; abs(nums1[i] - nums2[i])</span><br><span class="line">            dlst.append((tmp, i))</span><br><span class="line">            res +&#x3D; tmp</span><br><span class="line">        dlst.sort(reverse&#x3D;True)</span><br><span class="line">        max_up &#x3D; 0</span><br><span class="line">        copy_1 &#x3D; sorted(nums1)</span><br><span class="line"></span><br><span class="line">        for item in dlst:</span><br><span class="line">            if max_up &gt;&#x3D; item[0]:</span><br><span class="line">                break</span><br><span class="line">            idx &#x3D; bisect.bisect_left(copy_1, nums2[item[1]])</span><br><span class="line">            if 0 &lt; idx &lt; n:</span><br><span class="line">                tmp &#x3D; max(item[0] - abs(copy_1[idx] - nums2[item[1]]), item[0] - abs(copy_1[idx - 1] - nums2[item[1]]))</span><br><span class="line">            elif idx &#x3D;&#x3D; 0:</span><br><span class="line">                tmp &#x3D; item[0] - abs(copy_1[0] - nums2[item[1]])</span><br><span class="line">            else:</span><br><span class="line">                tmp &#x3D; item[0] - abs(copy_1[-1] - nums2[item[1]])</span><br><span class="line">            max_up &#x3D; max(max_up, tmp)</span><br><span class="line">        return (res - max_up) %(10**9 + 7)</span><br></pre></td></tr></table></figure>

<h2 id="名次：-273-10000-（AC-3道）-Bug-2次"><a href="#名次：-273-10000-（AC-3道）-Bug-2次" class="headerlink" title="名次： 273/10000  （AC 3道） Bug 2次"></a><em>名次： 273/10000  （AC 3道） Bug 2次</em></h2><h3 id="反思：-4"><a href="#反思：-4" class="headerlink" title="反思："></a>反思：</h3><p>这次是转变编程以来，成绩最好的一次，可惜没有进一步突破，第四道题确实太有挑战性了。<br>前面出现了两次bug都是非常容易避免的，依次是数据规模太大要求10^9 + 7求余，真实白白扣时间啊；第二题的bug也是非常容易规避的，因为偷懒不想求一个等差数列，这告诉我们不要偷懒，不要觉得复杂度足够低了就偷个懒，也许这题复杂度要求不是10^7呢，就要把你卡死呢？ 所以不要放松警惕。  </p>
<ol>
<li>下次遇到求余，先写return</li>
<li>不要偷懒</li>
<li>不要沾沾自喜，写完遇到第四题也要认真思考，在哪里聊天浪费时间，浮躁！万一能做出来呢？这不是亲手捏死自己的可能性吗？？？    </li>
</ol>
<h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><ol>
<li>采购方案<br>小力将 N 个零件的报价存于数组 nums。小力预算为 target，假定小力仅购买两个零件，要求购买零件的花费不超过预算，请问他有多少种采购方案。</li>
</ol>
<p>注意：答案需要以 1e9 + 7 (1000000007) 为底取模，如：计算初始结果为：1000000008，请返回 1</p>
<p>示例 1：</p>
<p>输入：nums = [2,5,3,5], target = 6</p>
<p>输出：1</p>
<p>解释：预算内仅能购买 nums[0] 与 nums[2]。</p>
<p>示例 2：</p>
<p>输入：nums = [2,2,1,9], target = 10</p>
<p>输出：4</p>
<p>解释：符合预算的采购方案如下：<br>nums[0] + nums[1] = 4<br>nums[0] + nums[2] = 3<br>nums[1] + nums[2] = 3<br>nums[2] + nums[3] = 10</p>
<p>提示：</p>
<p>2 &lt;= nums.length &lt;= 10^5<br>1 &lt;= nums[i], target &lt;= 10^5</p>
<h3 id="抽象成为数学模型就是-在一个数组内寻找两个数之和小于指定数，返回能找到多少个这样的两数组合。"><a href="#抽象成为数学模型就是-在一个数组内寻找两个数之和小于指定数，返回能找到多少个这样的两数组合。" class="headerlink" title="抽象成为数学模型就是 在一个数组内寻找两个数之和小于指定数，返回能找到多少个这样的两数组合。"></a>抽象成为数学模型就是 在一个数组内寻找两个数之和小于指定数，返回能找到多少个这样的两数组合。</h3><p>思路还是这样，我们可以暴力穷举所有的数字对 比较是否大于，但是明显我们就知道这样比较会超时，而且可以优化。  如果将数字排序，那么确定一个数字，那么另一个数字范围就确定了，不需要一个个比较就将比较的时间复杂度降到了o(n),当然排序开销是nlogn。<br>当然感觉还是可以继续降低复杂度，就是计数统计，然后排序键值这样排序复杂度降到klogk然后用键对应val用前缀和。但是中间多了两次o(n)的遍历，所以总遍历应该还是差不太多，但是数据量很大而且重复数字很多的时候可能会有点用？不过重复数字很多的排序sort也会接近o(n)   </p>
<h3 id="排序-双指针"><a href="#排序-双指针" class="headerlink" title="排序+双指针"></a>排序+双指针</h3><pre><code>class Solution:
    def purchasePlans(self, nums: List[int], target: int) -&gt; int:
        nums.sort()
        left, right = 0, len(nums) - 1
        res = 0
        while left &lt; right:
            while left &lt; right and nums[left] + nums[right] &gt; target:
                right -= 1
            res += right - left
            left += 1
        return res %(10**9 + 7)
</code></pre>
<p>在寻找右做表的时候可以用bisect二分查找  </p>
<h2 id="第二题："><a href="#第二题：" class="headerlink" title="第二题："></a>第二题：</h2><p>某乐团的演出场地可视作 num * num 的二维矩阵 grid（左上角坐标为 [0,0])，每个位置站有一位成员。乐团共有 9 种乐器，乐器编号为 1~9，每位成员持有 1 个乐器。</p>
<p>为保证声乐混合效果，成员站位规则为：自 grid 左上角开始顺时针螺旋形向内循环以 1，2，…，9 循环重复排列。例如当 num = 5 时，站位如图所示</p>
<p>image.png</p>
<p>请返回位于场地坐标 [Xpos,Ypos] 的成员所持乐器编号。</p>
<p>示例 1：</p>
<p>输入：num = 3, Xpos = 0, Ypos = 2</p>
<p>输出：3</p>
<p>解释：</p>
<p>示例 2：</p>
<p>输入：num = 4, Xpos = 1, Ypos = 2</p>
<p>输出：5</p>
<p>提示：</p>
<p>1 &lt;= num &lt;= 10^9<br>0 &lt;= Xpos, Ypos &lt; num </p>
<h3 id="第二题因为数据项的限制，显然模拟是不可能过的，-这题关键是要找到数学方法，就是用数学方法确定指定坐标是第多少个数，然后求余数-需要-心细。就是多少圈，按照圈来找对应是第多少个。"><a href="#第二题因为数据项的限制，显然模拟是不可能过的，-这题关键是要找到数学方法，就是用数学方法确定指定坐标是第多少个数，然后求余数-需要-心细。就是多少圈，按照圈来找对应是第多少个。" class="headerlink" title="第二题因为数据项的限制，显然模拟是不可能过的， 这题关键是要找到数学方法，就是用数学方法确定指定坐标是第多少个数，然后求余数   需要 心细。就是多少圈，按照圈来找对应是第多少个。"></a>第二题因为数据项的限制，显然模拟是不可能过的， 这题关键是要找到数学方法，就是用数学方法确定指定坐标是第多少个数，然后求余数   需要 心细。就是多少圈，按照圈来找对应是第多少个。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def orchestraLayout(self, num: int, xPos: int, yPos: int) -&gt; int:</span><br><span class="line">        quan &#x3D; min((xPos + 1, yPos + 1, num - xPos, num - yPos))</span><br><span class="line">        # print(quan)</span><br><span class="line">        if xPos &#x3D;&#x3D; quan - 1:</span><br><span class="line">            tmp &#x3D; yPos - quan + 2</span><br><span class="line">        elif xPos &#x3D;&#x3D; num - quan:</span><br><span class="line">            tmp &#x3D; num - (quan - 1) * 2 + num - (quan - 1) * 2 - 1 + (num - quan - yPos)</span><br><span class="line">        elif yPos &#x3D;&#x3D; quan - 1:</span><br><span class="line">            tmp &#x3D; 4 * num - 4 - 8 * (quan - 1) - (xPos - quan)</span><br><span class="line">        else:</span><br><span class="line">            tmp &#x3D; num - (quan - 1) * 2 + xPos - (quan - 1)</span><br><span class="line">        res &#x3D; (4*num + 8 - 8*quan + 4*num) * (quan - 1) &#x2F;&#x2F; 2</span><br><span class="line">        res +&#x3D; tmp</span><br><span class="line">        return (res - 1) % 9 + 1</span><br></pre></td></tr></table></figure>


<h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><ol start="3">
<li>魔塔游戏<br>题目难度Medium<br>小扣当前位于魔塔游戏第一层，共有 N 个房间，编号为 0 ~ N-1。每个房间的补血道具/怪物对于血量影响记于数组 nums，其中正数表示道具补血数值，即血量增加对应数值；负数表示怪物造成伤害值，即血量减少对应数值；0 表示房间对血量无影响。</li>
</ol>
<p>小扣初始血量为 1，且无上限。假定小扣原计划按房间编号升序访问所有房间补血/打怪，为保证血量始终为正值，小扣需对房间访问顺序进行调整，每次仅能将一个怪物房间（负数的房间）调整至访问顺序末尾。请返回小扣最少需要调整几次，才能顺利访问所有房间。若调整顺序也无法访问完全部房间，请返回 -1。</p>
<p>示例 1：</p>
<p>输入：nums = [100,100,100,-250,-60,-140,-50,-50,100,150]</p>
<p>输出：1</p>
<p>解释：初始血量为 1。至少需要将 nums[3] 调整至访问顺序末尾以满足要求。</p>
<p>示例 2：</p>
<p>输入：nums = [-200,-300,400,0]</p>
<p>输出：-1</p>
<p>解释：调整访问顺序也无法完成全部房间的访问。</p>
<p>提示：</p>
<p>1 &lt;= nums.length &lt;= 10^5<br>-10^5 &lt;= nums[i] &lt;= 10^5</p>
<h3 id="这题看上去就是模拟起手就好了每次贪心算法，那走扣血做多的那个-放到最后就可以了。-可以用一个堆来维护扣血的这些房间集合。最小堆即可，每次弹出扣血最多也就是数最小的那个数。"><a href="#这题看上去就是模拟起手就好了每次贪心算法，那走扣血做多的那个-放到最后就可以了。-可以用一个堆来维护扣血的这些房间集合。最小堆即可，每次弹出扣血最多也就是数最小的那个数。" class="headerlink" title="这题看上去就是模拟起手就好了每次贪心算法，那走扣血做多的那个 放到最后就可以了。  可以用一个堆来维护扣血的这些房间集合。最小堆即可，每次弹出扣血最多也就是数最小的那个数。"></a>这题看上去就是模拟起手就好了每次贪心算法，那走扣血做多的那个 放到最后就可以了。  可以用一个堆来维护扣血的这些房间集合。最小堆即可，每次弹出扣血最多也就是数最小的那个数。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def magicTower(self, nums: List[int]) -&gt; int:</span><br><span class="line">        if sum(nums) &lt; 0:</span><br><span class="line">            return -1</span><br><span class="line">        res &#x3D; 1</span><br><span class="line">        q &#x3D; []</span><br><span class="line">        count &#x3D; 0</span><br><span class="line">        for i in range(len(nums)):</span><br><span class="line">            res +&#x3D; nums[i]</span><br><span class="line">            if nums[i] &lt; 0:</span><br><span class="line">                heapq.heappush(q, nums[i])</span><br><span class="line">                if res &lt;&#x3D; 0:</span><br><span class="line">                    tmp &#x3D; heapq.heappop(q)</span><br><span class="line">                    res -&#x3D; tmp</span><br><span class="line">                    count +&#x3D; 1</span><br><span class="line">        return count</span><br></pre></td></tr></table></figure>

<h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><p>很难带状态转移的dfs<br>4. 变换的迷宫<br>某解密游戏中，有一个 N*M 的迷宫，迷宫地形会随时间变化而改变，迷宫出口一直位于 (n-1,m-1) 位置。迷宫变化规律记录于 maze 中，maze[i] 表示 i 时刻迷宫的地形状态，”.” 表示可通行空地，”#” 表示陷阱。</p>
<p>地形图初始状态记作 maze[0]，此时小力位于起点 (0,0)。此后每一时刻可选择往上、下、左、右其一方向走一步，或者停留在原地。</p>
<p>小力背包有以下两个魔法卷轴（卷轴使用一次后消失）：</p>
<p>临时消除术：将指定位置在下一个时刻变为空地；<br>永久消除术：将指定位置永久变为空地。<br>请判断在迷宫变化结束前（含最后时刻），小力能否在不经过任意陷阱的情况下到达迷宫出口呢？</p>
<p>注意： 输入数据保证起点和终点在所有时刻均为空地。</p>
<p>示例 1：</p>
<p>输入：maze = [[“.#.”,”#..”],[“…”,”.#.”],[“.##”,”.#.”],[“..#”,”.#.”]]</p>
<p>输出：true</p>
<p>解释：<br>maze.gif</p>
<p>示例 2：</p>
<p>输入：maze = [[“.#.”,”…”],[“…”,”…”]]</p>
<p>输出：false</p>
<p>解释：由于时间不够，小力无法到达终点逃出迷宫。</p>
<p>示例 3：</p>
<p>输入：maze = [[“…”,”…”,”…”],[“.##”,”###”,”##.”],[“.##”,”###”,”##.”],[“.##”,”###”,”##.”],[“.##”,”###”,”##.”],[“.##”,”###”,”##.”],[“.##”,”###”,”##.”]]</p>
<p>输出：false</p>
<p>解释：由于道路不通，小力无法到达终点逃出迷宫。</p>
<p>提示：</p>
<p>1 &lt;= maze.length &lt;= 100<br>1 &lt;= maze[i].length, maze[i][j].length &lt;= 50<br>maze[i][j] 仅包含 “.”、”#”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def escapeMaze(self, maze):</span><br><span class="line">        T &#x3D; len(maze)</span><br><span class="line">        r, c &#x3D; len(maze[0]), len(maze[0][0])</span><br><span class="line">        available &#x3D; defaultdict(bool)</span><br><span class="line">        for t, mz in enumerate(maze):</span><br><span class="line">            for x, line in enumerate(mz):</span><br><span class="line">                for y, s in enumerate(line):</span><br><span class="line">                    available[t, x, y] &#x3D; (s &#x3D;&#x3D; &#39;.&#39;)</span><br><span class="line">        directions &#x3D; [(1, 0), (-1, 0), (0, 1), (0, -1), (0, 0)]</span><br><span class="line">        def valid(x, y):</span><br><span class="line">            return 0 &lt;&#x3D; x &lt; r and 0 &lt;&#x3D; y &lt; c</span><br><span class="line"></span><br><span class="line">        @lru_cache(None)</span><br><span class="line">        def dp(t, x, y, status):</span><br><span class="line">            &#39;&#39;&#39;</span><br><span class="line">                status:</span><br><span class="line">                    0: 0</span><br><span class="line">                    1: 存在临时</span><br><span class="line">                    2: 存在永久</span><br><span class="line">                    3: 都存在</span><br><span class="line">            &#39;&#39;&#39;</span><br><span class="line">            # print(t, x, y, status, px, py)</span><br><span class="line">            if r + c - x - y &gt; T + 1 - t:</span><br><span class="line">                return False</span><br><span class="line">            if x &#x3D;&#x3D; r - 1 and y &#x3D;&#x3D; c - 1:</span><br><span class="line">                return True</span><br><span class="line">            for dx, dy in directions:</span><br><span class="line">                nx, ny &#x3D; x + dx, y + dy</span><br><span class="line">                if valid(nx, ny):  # 如果不越界</span><br><span class="line">                    if available[t+1, nx, ny]:  # 如果可以访问</span><br><span class="line">                        if dp(t+1, nx, ny, status):</span><br><span class="line">                            return True</span><br><span class="line">                    else:  # 如果不可访问</span><br><span class="line">                        if status &#x3D;&#x3D; 1:</span><br><span class="line">                            # 只有临时, 用临时</span><br><span class="line">                            if dp(t+1, nx, ny, 0):</span><br><span class="line">                                return True</span><br><span class="line">                        if status &#x3D;&#x3D; 2:</span><br><span class="line">                            # 用永久</span><br><span class="line">                            for nt in range(t+1, T):</span><br><span class="line">                                if dp(nt, nx, ny, 0):</span><br><span class="line">                                    return True</span><br><span class="line">                        if status &#x3D;&#x3D; 3:</span><br><span class="line">                            # 用临时;用永久</span><br><span class="line">                            # px, py: 永久空地</span><br><span class="line">                            if dp(t+1, nx, ny, 2):</span><br><span class="line">                                return True</span><br><span class="line">                            for nt in range(t+1, T):</span><br><span class="line">                                if dp(nt, nx, ny, 1):</span><br><span class="line">                                    return True</span><br><span class="line">            return False</span><br><span class="line">        return dp(0, 0, 0, 3)</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://andrekuu.github.io/2021/04/22/LeetCode-%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/" data-id="cknscjo0q0005egvedc87f7li" data-title="LeetCode 周赛总结" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2021-04-21T19:39:25.000Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="存储层次结构"><a href="#存储层次结构" class="headerlink" title="存储层次结构"></a>存储层次结构</h2><p>除了存储器和外部记录介质以外，运算器也是存储结构中的一员，因为CPU中的通用寄存器包含在运算器中，所以运算器也算含有存储功能的部件。  </p>
<h3 id="存储器的特性："><a href="#存储器的特性：" class="headerlink" title="存储器的特性："></a>存储器的特性：</h3><ul>
<li>非易失性</li>
<li>可读可写</li>
<li>随机访问</li>
<li>访问时间</li>
<li>容量</li>
<li>价格</li>
<li>功耗</li>
</ul>
<h3 id="易失性："><a href="#易失性：" class="headerlink" title="易失性："></a>易失性：</h3><p>通电后就会丢失数据的存储器我们称其为易失性存储器，反之则为非易失性存储器。CPU内的通用存储器和内存都是易失性的，而BIOS芯片（Basic Input Output System，基本输入输出系统，是用于计算机开机过程中各种硬件设备的初始化和检测的芯片）和硬盘则是非易失性的。</p>
<h3 id="开机后的程序是CPU从BIOS芯片开始执行程序，把硬盘初始化配置好以后，再把硬盘数据搬运到内存，之后CPU才可以在内存中运行程序。"><a href="#开机后的程序是CPU从BIOS芯片开始执行程序，把硬盘初始化配置好以后，再把硬盘数据搬运到内存，之后CPU才可以在内存中运行程序。" class="headerlink" title="开机后的程序是CPU从BIOS芯片开始执行程序，把硬盘初始化配置好以后，再把硬盘数据搬运到内存，之后CPU才可以在内存中运行程序。"></a>开机后的程序是CPU从BIOS芯片开始执行程序，把硬盘初始化配置好以后，再把硬盘数据搬运到内存，之后CPU才可以在内存中运行程序。</h3><h3 id="可读可写："><a href="#可读可写：" class="headerlink" title="可读可写："></a>可读可写：</h3><p>BIOS只可读（要借助专用设备才可写），其他存储器基本都支持可读可写。</p>
<h3 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h3><p>对存储器中的数据访问所花费的时间与这个数据所在的位置没有关系。（非随机访问的典型就是磁带）<br>内存和BIOS都是支持随机访问的，而硬盘不支持，硬盘是多个盘片构成的，盘片处于高速旋转状态，并有一个机械读写头去寻找需要访问数据的位置，这就是非随机访问的模式。</p>
<h3 id="为什么需要一个cache高速缓存？"><a href="#为什么需要一个cache高速缓存？" class="headerlink" title="为什么需要一个cache高速缓存？"></a>为什么需要一个cache高速缓存？</h3><p>因为随着硬件的发展，CPU的运行速度得到了巨幅的提升，而主存DRAM的数据读取速度的提升则远不及此。导致，cpu运行效率和DRAM主存的运行效率差距过大，这严重影响了CPU的性能。</p>
<h3 id="层次化的存储结构-CPU通用寄存器Byte量级–SRAM高速缓存KB-MB量级–DRAM主存MB-GB量级–DISK磁盘GB-TB量级-容量越来越大但是速度更慢，但单位字节成本更低"><a href="#层次化的存储结构-CPU通用寄存器Byte量级–SRAM高速缓存KB-MB量级–DRAM主存MB-GB量级–DISK磁盘GB-TB量级-容量越来越大但是速度更慢，但单位字节成本更低" class="headerlink" title="层次化的存储结构 CPU通用寄存器Byte量级–SRAM高速缓存KB\MB量级–DRAM主存MB\GB量级–DISK磁盘GB\TB量级  容量越来越大但是速度更慢，但单位字节成本更低"></a>层次化的存储结构 CPU通用寄存器Byte量级–SRAM高速缓存KB\MB量级–DRAM主存MB\GB量级–DISK磁盘GB\TB量级  容量越来越大但是速度更慢，但单位字节成本更低</h3><h3 id="内存条即内存模组是由若干个DRAM芯片和电路组成的。"><a href="#内存条即内存模组是由若干个DRAM芯片和电路组成的。" class="headerlink" title="内存条即内存模组是由若干个DRAM芯片和电路组成的。"></a>内存条即内存模组是由若干个DRAM芯片和电路组成的。</h3><h3 id="DRAM芯片内部核心的就是一个存储阵列，还有一个行译码器、列译码器、缓冲区-。"><a href="#DRAM芯片内部核心的就是一个存储阵列，还有一个行译码器、列译码器、缓冲区-。" class="headerlink" title="DRAM芯片内部核心的就是一个存储阵列，还有一个行译码器、列译码器、缓冲区 。"></a>DRAM芯片内部核心的就是一个存储阵列，还有一个行译码器、列译码器、缓冲区 。</h3><h3 id="DRAM组成："><a href="#DRAM组成：" class="headerlink" title="DRAM组成："></a>DRAM组成：</h3><p>DRAM的存储信息存储在存储阵列中，由一个行坐标和列坐标可以选中一个存储单元，通常包含4bit或者8bit。基本单元通过一个电容实现1bit存储信息。</p>
<h3 id="DRAM-基础存储单元1bit构成："><a href="#DRAM-基础存储单元1bit构成：" class="headerlink" title="DRAM 基础存储单元1bit构成："></a>DRAM 基础存储单元1bit构成：</h3><p>1个电容，一个行选择信号介入的NMOS和列选择信号NMOS还有一个刷新放大器，因为电容会漏电，所以要定时刷新电容值。写入就是给电容充电，读就是电容放电。</p>
<h3 id="DRAM的特点："><a href="#DRAM的特点：" class="headerlink" title="DRAM的特点："></a>DRAM的特点：</h3><p>优点：  </p>
<ul>
<li>集成度高</li>
<li>功耗低</li>
<li>价格低<br>缺点：</li>
<li>速度较慢</li>
<li>定时刷新</li>
</ul>
<p>当前常用的是DDR4 SDRAM</p>
<h3 id="SRAM的基本存储单位（1bit）："><a href="#SRAM的基本存储单位（1bit）：" class="headerlink" title="SRAM的基本存储单位（1bit）："></a>SRAM的基本存储单位（1bit）：</h3><p>双稳态触发器。由6个晶体管构成其中有两个PMOS，4个NMOS，信号输入输出端，和电源接地。 当读出和写入结束后，利用晶体管组成的结构，加上外接电源可以保持内部存储信息不变，这也是为什么突然断电就会丢失SRAM的信息。</p>
<h3 id="SRAM基本结构："><a href="#SRAM基本结构：" class="headerlink" title="SRAM基本结构："></a>SRAM基本结构：</h3><p>数据存储在存储矩阵里，此外有地址线连接译码驱动，这里的实现不同与DRAM，不是通过行列选择的。而且选择的存储矩阵单位可能是8bit也可能是16,64bit，另外通过读写控制连接着读写控制线和数据线，实现指定读还是写什么数据的过程。</p>
<h3 id="SRAM的特点："><a href="#SRAM的特点：" class="headerlink" title="SRAM的特点："></a>SRAM的特点：</h3><p>优点：</p>
<ul>
<li>速度较快<br>缺点：</li>
<li>集成度低</li>
<li>功耗较高</li>
<li>价格较高</li>
</ul>
<p>现代CPU中高速缓存都是用SRAM实现的，主存用DRAM实现</p>
<h3 id="主存工作原理（SDRAM）"><a href="#主存工作原理（SDRAM）" class="headerlink" title="主存工作原理（SDRAM）"></a>主存工作原理（SDRAM）</h3><pre><code>1.CPU会申请总线控制权，Bus Request,然后发送内存控制器32位地址。内存控制器会将这个地址分解形成行地址和列地址，然后内存控制器就会像内存发起访存操作。
2.[precharge]and row Access 通过存储总线发出行地址，会被行译码器row decoder接受，会在存储阵列中选取全部这一行，然后经过一个放大器，放大后放在一个缓冲区当中。（这个过程就叫行访问或者激活）
3.tRCD后就会发出列地址，Column Access会被列译码器接受。列译码器Column decoder接收到然后在缓冲区中选择对应的列。然后把对应存储单元数据放到数据接口处。（这一过程叫列访问）
4.Bus Transmission 数据传输回CPU
</code></pre>
<h3 id="tRCD（row-to-column-delay）-：从行选择到列选择的延迟-2-3个时钟-（15-23ns-PC133标准）"><a href="#tRCD（row-to-column-delay）-：从行选择到列选择的延迟-2-3个时钟-（15-23ns-PC133标准）" class="headerlink" title="tRCD（row to column delay） ：从行选择到列选择的延迟 2-3个时钟 （15-23ns PC133标准）"></a>tRCD（row to column delay） ：从行选择到列选择的延迟 2-3个时钟 （15-23ns PC133标准）</h3><h3 id="CL-（CAS-latency）-从列选到数据输出的延迟-（15-23ns-PC133标准）"><a href="#CL-（CAS-latency）-从列选到数据输出的延迟-（15-23ns-PC133标准）" class="headerlink" title="CL （CAS latency） 从列选到数据输出的延迟 （15-23ns PC133标准）"></a>CL （CAS latency） 从列选到数据输出的延迟 （15-23ns PC133标准）</h3><h3 id="tRP：-行预充电（关闭行）的延迟时间-（15-23ns-PC133标准）"><a href="#tRP：-行预充电（关闭行）的延迟时间-（15-23ns-PC133标准）" class="headerlink" title="tRP： 行预充电（关闭行）的延迟时间  （15-23ns PC133标准）"></a>tRP： 行预充电（关闭行）的延迟时间  （15-23ns PC133标准）</h3><h3 id="为什么一下子取一行？"><a href="#为什么一下子取一行？" class="headerlink" title="为什么一下子取一行？"></a>为什么一下子取一行？</h3><p>因为通常情况下，访问内存都不会只读一个数，而是会连续读出多个数，将一行连接到缓冲区中和连接一个并没有什么时间上的差异，而且如果下一次访存还在同一行，则可以跳过行选择阶段，大大缩短访存的时间。</p>
<h3 id="预充电是什么？"><a href="#预充电是什么？" class="headerlink" title="预充电是什么？"></a>预充电是什么？</h3><p>如果下一次CPU访问内存对应的行地址不是上一次的行地址，则需要对缓存区也就是激活的这一行关闭，这就叫预充电。预充电有两种方式，第一种是传输结束后就开始预充电，另一种是下一次接受访存指令后如果非同一行再预充电。</p>
<p>亿PC133标准下，SDRAM为例，时钟周期是7.5ns tRCD,CL,tRP均为3个周期，则大约一次访存需要12个周期，90ns</p>
<h3 id="SDRAM为什么很难性能提升？"><a href="#SDRAM为什么很难性能提升？" class="headerlink" title="SDRAM为什么很难性能提升？"></a>SDRAM为什么很难性能提升？</h3><p>因为SDRAM的读写根本还是对电容的充放电，而这部分时间很难被优化。</p>
<h3 id="DDR？是什么"><a href="#DDR？是什么" class="headerlink" title="DDR？是什么"></a>DDR？是什么</h3><p>DDR就是DOUBLE DATA RATE ，双倍数据率，是一种传递数据的方式，不止用于内存数据传输上，是一种时钟频率上升或者下降沿都传输数据的<br>后续DDR-200 DDR2-400 DDR2-800就是在双倍数据率基础上提高翻倍核心频率，和主频率不同了。</p>
<h3 id="Cache的原理："><a href="#Cache的原理：" class="headerlink" title="Cache的原理："></a>Cache的原理：</h3><p>Cache的工作原理是基于程序访问的局部性原理（通俗说就是把经常用到的数据放在一个高速的cache里面）。即时间程序性和空间程序性。时间程序性就是被访问的存储器单元（指令或者数据）很快还会被再次访问。空间局限性，就是正在被访问的存储器单元附近的单元很快会被再次访问。</p>
<p>所以cache在去主存中取回带访问数据的同时，还会同时取回与位置相邻的主存单位的数据，<strong>以数据块为单位和主存进行数据交换</strong>。并保存最近被主存数据频繁访问的主存单元的数据。</p>
<h3 id="cache访问过程"><a href="#cache访问过程" class="headerlink" title="cache访问过程"></a>cache访问过程</h3><p>CPU向cache发出读请求，cache判断是否在cache中，如果在，就叫做cache hit cache命中，从cache中读数据并返回。如果这个数据不再cache中，则称为cache miss cache失效，则继续向主存发出读请求，读出数据并返回，返回的数据块返回cache，cache会更新数据块内容，并把CPU指定内容返回给CPU。</p>
<h3 id="cache的写策略："><a href="#cache的写策略：" class="headerlink" title="cache的写策略："></a>cache的写策略：</h3><ul>
<li>Cache命中时的写策略：1.写穿透 write through 数据同时写入cache和内存<pre><code>              2.写返回 write back 数据值写入cache仅当数据块被替换的时候才将数据写会主存。
</code></pre>
</li>
<li>Cache失效时的写策略：1.写不分配 直接将数据写入内存<pre><code>               2.写分配 将该数据所在的块读入cache后，再将数据写入cache。
</code></pre>
</li>
</ul>
<p>写穿透和写不分配这套组合适合设计简单但是对性能要求不高的系统。</p>
<p>写分配和写返回适用于高性能。</p>
<h3 id="平均访问时间：-hittime-miss-penalty-miss-rate"><a href="#平均访问时间：-hittime-miss-penalty-miss-rate" class="headerlink" title="平均访问时间： = hittime + miss penalty* miss rate"></a>平均访问时间： = hittime + miss penalty* miss rate</h3><p>提高一点点命中率都会带来性能很大程度上的提升</p>
<p>cache失效的原因：</p>
<h3 id="义务失效："><a href="#义务失效：" class="headerlink" title="义务失效："></a>义务失效：</h3><p>第一次访问某数据块也称为冷启失效。无法有效避免。</p>
<h3 id="容量失效"><a href="#容量失效" class="headerlink" title="容量失效"></a>容量失效</h3><p>cache无法保存程序访问的所需要的所有数据块  —- 可以通过增加cache容量缓解</p>
<h3 id="冲突失效"><a href="#冲突失效" class="headerlink" title="冲突失效"></a>冲突失效</h3><p>多个存储器位置映射到同一个cache位置，而导致冲突带来的失效。—使用多路组相连cache</p>
<h3 id="cache的替换算法："><a href="#cache的替换算法：" class="headerlink" title="cache的替换算法："></a>cache的替换算法：</h3><ul>
<li>random 随机替换算法，硬件随机选择一个cache数据块替换</li>
<li>轮转 round robin 按照设定顺序依次选择cache数据块替换</li>
<li>最近最少使用LRU算法，用硬件记录访问历史信息，然后选择距离现在最长时间未被访问的cache数据块选择替换。</li>
</ul>
<p>core i7 的多级高速缓存：<br>L1 cache 指令和数据分离 各32KB 8路组相连 命中周期为4个周期</p>
<h3 id="输入输出接口（I-O接口-的基本功能"><a href="#输入输出接口（I-O接口-的基本功能" class="headerlink" title="输入输出接口（I/O接口)的基本功能"></a>输入输出接口（I/O接口)的基本功能</h3><ul>
<li>1.数据缓冲 解决CPU与外设之间的速度差距</li>
<li>2.提供联络信息  协调与同步数据交换过程</li>
<li>3.信号与信息格式地转换  模/数  数/模转换 串/并转换  电平转换</li>
<li>4.设备选择 同一个I/O接口可能接着几个I/O设备所以需要选择是哪个设备</li>
<li>5.中断管理</li>
<li>6.可编程功能</li>
</ul>
<p>I/O接口可能是主板上的一个插卡 也可能是主板上的一个芯片。</p>
<h3 id="I-O接口组成："><a href="#I-O接口组成：" class="headerlink" title="I/O接口组成："></a>I/O接口组成：</h3><p>内部有数据输入寄存器、数据输出寄存器、状态寄存器、控制寄存器、中断控制逻辑、和连接三个线的接口 数据总线 地址总线 控制总线通过并行接口电路接进来。并行接口电路是I/O接口的一种，一般有两种常见的物理实现形式，一种是独立的芯片，一种是包含在多功能芯片中。</p>
<h3 id="并行接口电路连接较为复杂设备的工作方式："><a href="#并行接口电路连接较为复杂设备的工作方式：" class="headerlink" title="并行接口电路连接较为复杂设备的工作方式："></a>并行接口电路连接较为复杂设备的工作方式：</h3><p>除了连接了并行输出数据的8根数据线，还要有两根通讯联络信号，又称为握手信号。当设备准备好以后，就会发出输出/输入请求，而接口接收到信号后也要返回一个回答信号，这样才能保证数据既不会重复也不会遗漏。现代个人计算机中会和其他很多输入输出设备的接口集成在南桥芯片中。部分性能要求搞得或者用途特殊的输入输出接口采用独立芯片或者板卡的形式。</p>
<h3 id="握手信号："><a href="#握手信号：" class="headerlink" title="握手信号："></a>握手信号：</h3><p>总是成对出现，在数据传输中启着定时协调和联络的作用，采用握手方式数据传输，每一过程必须都有应答，彼时进行确认。</p>
<p>I/O接口:I/O接口内部包含一组称为I/O端口的寄存器，每个端口都有自己的端口号（端口地址）。</p>
<h3 id="I-O端口编址："><a href="#I-O端口编址：" class="headerlink" title="I/O端口编址："></a>I/O端口编址：</h3><ol>
<li>I/O端口和存储器分开编址。(I/O映像的I/O方式)直接寻址：用一个字节立即数指定端口地址，间接寻址就是用DX的内容指定端口地址（端口地址小于256）。端口地址（&gt;255）只能用间接寻址（因为指令字节长度的限制）分开编址会出现存储器和I/O接口同址的情况，所以要用一个M/IO信号指定是访问存储器还是I/O接口。</li>
<li>I/O端口和存储器统一编址。（存储器映像的I/O方式）</li>
</ol>
<h3 id="统一编址和分开编址优缺点："><a href="#统一编址和分开编址优缺点：" class="headerlink" title="统一编址和分开编址优缺点："></a>统一编址和分开编址优缺点：</h3><p>统一编址：<br>1.优点：</p>
<ul>
<li>可以用访问存储器的指令来访问I/O端口，访问存储器的指令功能比较齐全，可以实现对I/O端口内的数据进行处理</li>
<li>可以将CPU中I/O操作和访问存储器操作统一设计为一套控制逻辑，简化内部结构，cpu无需产生区别访问内存操作和I/O操作的控制信号，从而可减少引脚。</li>
</ul>
<p>2.缺点：</p>
<ul>
<li>由于I/O设备占用了一部分存储器地址，所以存储地址变小了。</li>
<li>由于利用访问存储器的指令来进行I/O操作，所以指令长度通常比单独的I/O指令长，所以执行指令的执行时间也比较长。</li>
</ul>
<p>分开编址：<br>优点：</p>
<ol>
<li>I/O端口不占用存储器地址，不会减少用户的存储器地址空间</li>
<li>I/O指令编码短，执行快</li>
<li>I/O指令的地址码短，地址译码方便</li>
<li>采用单独的I/O指令，使得程序中I/O操作和其他操作层次清晰，便于理解<br>缺点：</li>
<li>只能用专门的I/O指令，访问端口的方法不如访问存储器的方法多。</li>
<li>需要专门的区分内存操作还是I/O操作。</li>
</ol>
<h3 id="输入输出控制方式："><a href="#输入输出控制方式：" class="headerlink" title="输入输出控制方式："></a>输入输出控制方式：</h3><p>输入输出控制方式就是指CPU如何控制外设的数据传送的，I/O控制方式的分类：<br>1.程序控制方式<br>2.中断控制方式<br>3.直接存储器访问(DMA)方式</p>
<h3 id="程序控制方式："><a href="#程序控制方式：" class="headerlink" title="程序控制方式："></a>程序控制方式：</h3><p>1.无条件控制方式 </p>
<pre><code>1.适用于简单外设 总是假设外设已经准备好了
2.CPU直接使用指令和外设传送数据
3.不查询外设的工作状态
</code></pre>
<p>2.程序查询传送方式：</p>
<pre><code>CPU通过执行一段程序，不断查询外设的工作状态，在确定外设已经准备就绪的时候才传输数据
</code></pre>
<h3 id="程序查询传送方式流程："><a href="#程序查询传送方式流程：" class="headerlink" title="程序查询传送方式流程："></a>程序查询传送方式流程：</h3><p>1.CPU执行指令，将控制字写入接口的控制寄存器，从而设置接口的工作模式。<br>2.CPU执行指令，将数据写入接口的“输出缓冲寄存器”<br>3.接口将数据发到“并行数据输出”信号线上，并将“输出准备好”信号置为有效（亦可以由CPU写控制字将该信号置为有效）<br>4.外设发现“输出准备好”信号有效后，从“并行数据输出”信号线上接受数据，并将“输出回答”信号置为有效<br>5.接口发现“输出回答”信号置为有效以后就会从状态寄存器中的状态位“输出缓冲空”置为有效<br>6.在这个过程中，CPU反复执行指令从“状态寄存器”中读出状态字，直到“输出缓冲空”，然后开始下一个输出过程，继续输出新数据。</p>
<p>输入过程就是（状态字等待识别“输入缓冲满”）（同时是外设发送输入准备好信号，接口返回输入准备好信号）</p>
<h3 id="程序控制方式的优缺点："><a href="#程序控制方式的优缺点：" class="headerlink" title="程序控制方式的优缺点："></a>程序控制方式的优缺点：</h3><ol>
<li>无条件传送方式</li>
</ol>
<ul>
<li>优点： 控制程序简单</li>
<li>缺点：只适用于简单外设的操作</li>
</ul>
<ol start="2">
<li>程序查询传送方式</li>
</ol>
<ul>
<li>优点：比无条件传送方式更加准确和可靠 ，</li>
<li>缺点：查询外设状态占用了大量时间，降低了CPU运行效率<br>共同优缺点：<br>优点：对外设的要求比较低，操作流程清晰<br>缺点：要靠CPU进行数据的传送操作，占用了宝贵的运算资源，外设和存储器之间的数据交换任然由CPU承担，使用数据传送指令 占用了宝贵的CPU运算资源，而且数据传输过程还是要先存储到CPU的通用寄存器中中转，过程冗长。</li>
</ul>
<h3 id="中断控制方式："><a href="#中断控制方式：" class="headerlink" title="中断控制方式："></a>中断控制方式：</h3><ol>
<li>系统初始化时，CPU执行指令，将控制字写入接口的控制寄存器里，设置接口的工作模式。</li>
<li>外设将数据发送到并行数据输入信号，并将数据输入准备好信号置为有效</li>
<li>接口发现输入准备好信号有效后，从并行数据输入信号接收数据，放入输入缓冲寄存器，并将输入回答信号置为有效，组织外设进一步输入新数据。</li>
<li>接口通过中断控制逻辑像CPU发出中断请求信号，并将状态寄存器中的状态位”输入缓冲满“置为有效（因为中断后CPU不知道外设为啥中断，所以要设置状态寄存器的信息）</li>
<li>CPU收到中断请求后，进入中断服务程序，执行指令从状态寄存器中读出状态字，发现输入缓冲满，因此执行指令，从输入缓冲寄存器中读入数据</li>
<li>接口将输入回答信号置为无效，等待外设输入新数据</li>
</ol>
<h3 id="中断控制方式的特点："><a href="#中断控制方式的特点：" class="headerlink" title="中断控制方式的特点："></a>中断控制方式的特点：</h3><ul>
<li>优点：</li>
</ul>
<ol>
<li>CPU 可以和外设并行工作，提高了工作效率    </li>
<li>外围设备具有申请服务的主动权    </li>
<li>一定程度上满足了I/O处理的实时性要求    </li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>外设和存储器之间的数据交换任然由CPU承担</li>
<li>使用数据传送指令 占用了宝贵的CPU运算资源</li>
<li>而且数据传输过程还是要先存储到CPU的通用寄存器中中转，过程冗长。</li>
<li>进入和退出中断需要额外的指令，增加了一些开销。</li>
</ol>
<h3 id="中断控制方式和程序查询方式比较："><a href="#中断控制方式和程序查询方式比较：" class="headerlink" title="中断控制方式和程序查询方式比较："></a>中断控制方式和程序查询方式比较：</h3><p>虽然大部分时间中断控制方式都有明显的系统性能提升的优势，但是关键时刻还得用程序查询方式，比如数据很重要和响应数据速度要求很高的时候，这时候中断就比较慢了。</p>
<h2 id="外部中断："><a href="#外部中断：" class="headerlink" title="外部中断："></a>外部中断：</h2><p>外部中断也称为硬件中断 ：由CPU外部设备中断请求信号启动的中断<br>X86提供了两个引脚  NMI非可屏蔽中断  INTR 可屏蔽中断 </p>
<p>非屏蔽中断不受中断允许标志IF的影响<br>CPU的可屏蔽中断通过一个中断控制器连接进cpu不同的外设连接到这个中断控制器上，可屏蔽中断的类型码由中断控制器提供，中断允许标志IF用于屏蔽此类中断</p>
<p>可编程中断控制器PIC，中断控制器的接口也是有限的， 所以要更多输入输出设备接口就得串一些PIC，组成层级的中断控制器。现在的PC已经把大部分I/O接口集成到了南桥中，所以南桥内实现一个叫APIC的高级可编程中断控制器，用于发送中断控制信号，南桥外部的I/O接口的中断请求信号也要通过他来实现。CPU中也有APIC，因为现在的多核体系，不但要接受CPU也需要发出中断请求用来和其他CPU来交互。</p>
<h3 id="中断嵌套："><a href="#中断嵌套：" class="headerlink" title="中断嵌套："></a>中断嵌套：</h3><ol>
<li>当CPU正在执行中断服务程序，发生优先级更高的中断请求</li>
<li>CPU响应优先级更高的中断请求，而将正在处理的中断暂时挂起</li>
<li>CPU完成优先级更高的中断服务后，返回此前优先级较低的终端服务程序继续执行。</li>
</ol>
<h3 id="为什么需要中断来进行I-O操作："><a href="#为什么需要中断来进行I-O操作：" class="headerlink" title="为什么需要中断来进行I/O操作："></a>为什么需要中断来进行I/O操作：</h3><p>依托CPU来完成I/O输入输出的信号是不现实的，因为这中间不断地查询输入输出完成的信号中产生的等待的漫长时间会巨大的拖累CPU的性能。简单的来说就是不能让CPU一直这么干等着。</p>
<h3 id="DMA方式："><a href="#DMA方式：" class="headerlink" title="DMA方式："></a>DMA方式：</h3><p>因为现代计算机连接的外设越来越多，而且比如显示器、网络等不但传输数据量大，而且对速率要求也很高，这些数据如果都是通过CPU搬运到寄存器在搬运到对应内存就是非常浪费时间的一种方式，所以就需要一个DMA方式。DMA direct memory access（DMA）直接存储器访问，这部分工作是由专门硬件电路控制，进行外设与存储器直接数据传送。也设置了专门硬件控制电路DMA控制器简称DMAC。DMAC既有MASTER接口也有Slave接口。</p>
<h3 id="DMAC的基本工作步骤："><a href="#DMAC的基本工作步骤：" class="headerlink" title="DMAC的基本工作步骤："></a>DMAC的基本工作步骤：</h3><ol>
<li>CPU设置DMAC内部配置寄存器：源地址的初始值以及传送时地址增减 以及目的地址的初始值和传送时的地址增减方式、以及传送数据的长度（可以不设置）</li>
<li>DMAC处于空闲等待状态</li>
<li>I/O接口会通过一个信号线向DMAC发出DMA传送申请</li>
<li>DMAC收到响应以后会通过另一根线响应I/O的申请</li>
<li>DMAC向I/O接口发起总线读传输</li>
<li>DMAC向存储器发起总线写传输 然后写到存储器中</li>
<li>重复5-6直到本次DMA传送完成</li>
<li>然后返回第2步等待下一次DMA传送申请</li>
</ol>
<h3 id="自带DMAC的I-O接口-："><a href="#自带DMAC的I-O接口-：" class="headerlink" title="自带DMAC的I/O接口 ："></a>自带DMAC的I/O接口 ：</h3><p>显卡、网卡都有自带，只为这个I/O服务，可以更好地根据数据的特点来定制，更好的完成数据传输</p>
<h2 id="流水线处理器"><a href="#流水线处理器" class="headerlink" title="流水线处理器"></a>流水线处理器</h2><h3 id="流水线技术定义："><a href="#流水线技术定义：" class="headerlink" title="流水线技术定义："></a>流水线技术定义：</h3><p>流水线技术是一种将每条指令分解为多步，并让各步操作重叠，从而实现几条指令并行处理的技术。程序中的指令仍是一条条顺序执行，但可以预先取若干条指令，并在当前指令尚未执行完时，提前启动后续指令的另一些操作步骤。这样显然可加速一段程序的运行过程。流水线技术是通过增加计算机硬件来实现的。<br>流水线的本质实际上是利用了时间的并行性，让原来应该先后执行的指令在时间上一定程度上并行起来。</p>
<p>划分流水线的时候尽量做到每一级的时间尽量相等。   </p>
<h3 id="超级流水线技术（super-pipelining）："><a href="#超级流水线技术（super-pipelining）：" class="headerlink" title="超级流水线技术（super pipelining）："></a>超级流水线技术（super pipelining）：</h3><p>将五级流水线细分为更多阶段，增加流水线的深度，这样的流水线，就会被称为超级流水线。</p>
<p>超级流水线技术提升了时钟频率，从而提高了指令吞吐率。但是超级流水线也面临着不是级数越多，深度越深越好。流水线的级数越多，单条指令的执行越长，还面临更多冒险的风险。现在的主流处理器平均在15级左右。</p>
<h3 id="超标量流水线："><a href="#超标量流水线：" class="headerlink" title="超标量流水线："></a>超标量流水线：</h3><p>是指在CPU中有一条以上的流水线，并且每时钟周期内可以完成一条以上的指令，这种设计就叫超标量技术。超级标量是指cpu内一般能有多条流水线,这些流水线能够并行处理。在单流水线结构中，指令虽然能够重叠执行，但仍然是顺序的,每个周期只能发射(issue)或退休(retire)一条指令。超级标量结构的cpu支持指令级并行，每个周期可以发射多条指令(2-4条居多)。可以使得cpu的IPC(InstructionPerClock)&gt;，从而提高cpu处理速度。</p>
<h3 id="超标量流水线和CPU："><a href="#超标量流水线和CPU：" class="headerlink" title="超标量流水线和CPU："></a>超标量流水线和CPU：</h3><p>现代多核CPU通常是在CPU的芯片内部中集成了多个超标量处理器核 </p>
<h3 id="超标量技术和超级流水线技术"><a href="#超标量技术和超级流水线技术" class="headerlink" title="超标量技术和超级流水线技术"></a>超标量技术和超级流水线技术</h3><p>并不相关。超级流水线技术是时间换空间，超标量技术是空间换时间。</p>
<h3 id="冒险-风险（hazard）："><a href="#冒险-风险（hazard）：" class="headerlink" title="冒险/风险（hazard）："></a>冒险/风险（hazard）：</h3><p>是指在计算机CPU的结构中，指令流水线乱序执行中的一些问题可能会导致得到不正确的计算结果，或阻止下一条指令在以下各时钟周期开始执行的情况。有3类典型的冒险：<br>结构冒险 、数据冒险、控制冒险。</p>
<p>结构冒险：所需要的的硬件部分正在为之前的指令工作。<br>数据冒险：需要等待之前的指令完成数据的读写。<br>控制冒险：需要根据之前指令的结果决定下一步的行为。  </p>
<h3 id="解决冒险通用方案："><a href="#解决冒险通用方案：" class="headerlink" title="解决冒险通用方案："></a>解决冒险通用方案：</h3><p>是流水线停顿（stall），产生空泡（bubble）。但是这种解决方案使得整个流水线效率降低。</p>
<h3 id="解决结构冒险："><a href="#解决结构冒险：" class="headerlink" title="解决结构冒险："></a>解决结构冒险：</h3><p>解决方案1： 通用方案。<br>解决方案2： 指令和数据不存放在相同的存储器中。在处理器中设定指令高速缓存和数据高速缓存来实现的。只是在cpu中一级高速缓存是采用这种分开存放的，而冯诺依曼机构中内存存储数据和指令的思维不变。<br>解决方案3：对于读寄存器和回写寄存器同时发生的情况：把一个时钟周期分为两个部分，前半部分用来作为寄存器堆的写入，后半部分时间用来作为寄存器堆的读出，并且在寄存器堆上实现独立的读写口。这是因为寄存器堆的读写相对要快很多，一般是ALU等部件的一半延迟。</p>
<h3 id="解决数据冒险：（寄存器类和存储器类）"><a href="#解决数据冒险：（寄存器类和存储器类）" class="headerlink" title="解决数据冒险：（寄存器类和存储器类）"></a>解决数据冒险：（寄存器类和存储器类）</h3><ul>
<li><p>一条指令需要使用之前指令的运算结果，但是结果还没有写回：</p>
<p>  1.软件解决方案： 插入nop指令（就是空指令，但占用指令时间）<br>  2.硬件解决方案： 流水线停顿stall，产生空泡bubble。检查当前需要读的寄存器是否和前面指令要写的寄存器相同，如果有相同就说明有数据冒险，就插入空泡。<br>  3.数据前递（Forwarding）\旁路（Bypass） 我们可以搭建一个旁路，实现数据绕过寄存器堆，直接进入下一条指令的执行阶段</p>
</li>
<li><p>load-use冒险：就是一条指令需要使用之前的访存结果。</p>
<p>  数据前递是无法实现的，所以只能通过流水线停顿，插入bubble来停顿一个时间周期，然后在通过数据前递实现。</p>
</li>
</ul>
<h3 id="控制冒险："><a href="#控制冒险：" class="headerlink" title="控制冒险："></a>控制冒险：</h3><p>转移指令改变指令流向，破坏流水模式。转移指令是非常常见的指令，每隔4-7条指令就会产生一条转移指令，转移指令会带来若干个不需要执行的指令进入流水线。而现代都是超标量深度流水线，比如4发射16级，就是同时有64条指令在处理器中，流水线越深，超标量越多，则带来的影响越大。  </p>
<h3 id="转移开销："><a href="#转移开销：" class="headerlink" title="转移开销："></a>转移开销：</h3><p>当执行了转移指令，并确实发生了转移时，产生如下的开销则称为转移开销：1.将按顺序预取的指令废除（即排空流水线）2.从转移目标地址重新取指令。转移开销有两部分组成，一个是转移条件判定引起的开销，一个是重新计算转移目标地址引起的开销。</p>
<p>转移指令分为无条件转移和有条件转移，而无条件和有条件也分为直接转移指令，就是直接给出了目标转移的地址，和间接转移地址，即目标转移地址不直接给出，而是在指定寄存器中存储。</p>
<h3 id="解决控制冒险："><a href="#解决控制冒险：" class="headerlink" title="解决控制冒险："></a>解决控制冒险：</h3><p>无条件直接转移J指令的转移目标地址可以在取址阶段就获得，流水线可以不停顿。<br>无条件间接转移JR指令的转移目标地址可以在译码阶段获得，流水线停顿了一个周期。<br>有条件直接转移beq指令，可以在寄存器堆的输出端增加一个比较电路，这样在译码阶段就可以得到条件判断的结果，所以流水线停顿了一个周期。</p>
<p>延迟转移技术：就是修改条件转移后的那条指令，那条指令是无论条件判断结果都一定会执行的，这样就可以实现流水线不停顿了。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41832850/article/details/98856042">CPU流水线技术 数据冒险和结构冒险</a></p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>运算发生了溢出，硬件是很容易检测到的，用硬件处理溢出会导致系统设计不灵活，设计出来以后就没法改变电路，从而没有办法改变处理溢出的方式。所以采用软件方式处理异常。从ALU在这里连一条线到PC更新部件，转移目标地址为比如说0到pc计数器，下面就会从指令存储器中取出对应地址的应对中断程序。可以统称为中断，分为内部中断和外部中断，有些地方会吧内部中断叫异常。</p>
<p>pc计数器中指令序列从一个指令地址切到给出下一个控制地址的过程，叫做控制转移，control transfer,这样控制转移序列叫做控制流 control flow。</p>
<h3 id="异常控制流ECF："><a href="#异常控制流ECF：" class="headerlink" title="异常控制流ECF："></a>异常控制流ECF：</h3><p>现代系统通过控制流的突变来对系统状态做出反应。程序计数器在通常情况下会依次加载这些相邻的指令交给CPU执行，但是在某些情况下可能会发生突变，从而打破cpu本应该顺序执行这些指令序列的预期行为，这种突变就叫做控制流的异常，简称为ECF（Exception Control Flow）</p>
<h3 id="异常："><a href="#异常：" class="headerlink" title="异常："></a>异常：</h3><p>异常是指在程序运行过程中发生的异常事件，就是控制流的突变，用来响应处理器状态中某些部分发生的变化。</p>
<h3 id="存储器中保留两个专用区域，一个是中断向量表区。一个是初始化程序区。初始化指向向量表区，向量表区发出对应终端应用程序地址。"><a href="#存储器中保留两个专用区域，一个是中断向量表区。一个是初始化程序区。初始化指向向量表区，向量表区发出对应终端应用程序地址。" class="headerlink" title="存储器中保留两个专用区域，一个是中断向量表区。一个是初始化程序区。初始化指向向量表区，向量表区发出对应终端应用程序地址。"></a>存储器中保留两个专用区域，一个是中断向量表区。一个是初始化程序区。初始化指向向量表区，向量表区发出对应终端应用程序地址。</h3><h3 id="中断向量表："><a href="#中断向量表：" class="headerlink" title="中断向量表："></a>中断向量表：</h3><p>存放的是中断服务程序的入口地址，也称为中断向量，每个入口地址占4个字节。前两个字节单元存放中断服务程序入口的偏移量IP（指令指针寄存器），低字节在前高字节在后，而后两个字节单元存放中断服务程序入口地址的段基址(cs)也是低字节在前，高字节在后。<br>具体不同系统芯片设计向量表不同，8086是256个中断向量，5个专用中断，27个保留中断，224个供用户自定义的中断。</p>
<p>系统响应中断先会发出一个转移指令，INT 1（INT+数字的形式）指向对应几号中断向量，然后中断向量发出段地址和偏移地址运算器计算地址并取出对应中断服务程序。</p>
<p>每次开机启动的时候，bios芯片初始化各个部件的时候，有一项工作就是去主存0地址的地方去构建中断向量表。</p>
<h3 id="中断处理过程："><a href="#中断处理过程：" class="headerlink" title="中断处理过程："></a>中断处理过程：</h3><ul>
<li>1.关闭中断：CPU关闭中断响应以后，就不再接受其他外部中断请求</li>
<li>2.保存断点：把原来将要执行的指令地址压入堆栈，以使中断处理完成后能正确地返回。</li>
<li>3.识别中断源：CPU识别中断的来源，确定中断类型号，从而找到对应的中断服务程序的入口地址。</li>
<li>4.保存现场：将发生中断处有关的寄存器以及标志寄存器的内容压入栈中。</li>
<li>5.执行中断服务程序：转到中断服务程序入口开始执行，可以适当时刻开放中断，以允许响应较高优先级的外部中断。标志寄存器FLAGS中IF标志位，来在中断中优先处理更高级中断。标志寄存器属于控制标志，就是软件设置值，硬件实现改变电路。</li>
<li>6.恢复现场并返回：把保护现场时压入栈中的信息弹回原寄存器（cs\ip\psw），然后执行中断返回指令，从而返回主程序继续运行。<br>前三步由应将实现，后三部分由软件实现。<br>CPU执行某条指令</li>
</ul>
<p>发生中断，CPU内部产生中断信号，CPU内部判断中断来源，产生中断类型码N（对应前者3）<br>，当前CS/IP/PSW压栈（对应前者2、4），清除IF和TF（对应前者1），取CS/IP新值，转入中断服务程序（对应前者5），开放中断（可选），IRET指令使旧的CS/IP/PSW弹出堆栈（对应前者6）其实1,2,3,是硬件一起实现的，所以具体顺序无伤大雅。</p>
<h3 id="中断标志IF："><a href="#中断标志IF：" class="headerlink" title="中断标志IF："></a>中断标志IF：</h3><p>控制可屏蔽中断的响应。如果IF 为1，则允许CPU响应可屏蔽中断请求，反之则不允许。指令STI 把IF置1，CLI把IF清零。IF对非屏蔽中断和内部中断不起作用。</p>
<h3 id="单步中断："><a href="#单步中断：" class="headerlink" title="单步中断："></a>单步中断：</h3><p>常用于系统调试的，把标志寄存器TF置为1后，cpu便处于单步工作方式。在单步工作方式下，CPU没执行完一条指令，就会自动产生一个类型1的中断，进入类型1中断服务程序。<br>类型1中断服务程序通常显示CPU内部个寄存器的内容和一些其他信息，以便调试和检查错误  </p>
<h3 id="断点中断："><a href="#断点中断：" class="headerlink" title="断点中断："></a>断点中断：</h3><p>与单步中断类似，也是调试程序的一种手段，并且常常与单步中断结合使用，对于一个大程序，通常通过设置断点，确定程序在哪个大的一段里在慢慢切分找到问题缩在，这样比单步中断更有效率。</p>
<h3 id="内部中断特点："><a href="#内部中断特点：" class="headerlink" title="内部中断特点："></a>内部中断特点：</h3><p>内部中断的类型号由CPU内部产生，外部中断则需要从外部设备读取中断类型号。<br>除此以外，除了单步中断外，所有内部中断都不可以用软件方法来屏蔽和禁止。单步中断可以通过软件，将TF标志标志置为1，或者清0来允许。<br>除了单步中断外，优先级也是内部中断优先级比外部中断高</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://andrekuu.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" data-id="cknscjo0m0002egve6uwi94sf" data-title="计算机基础" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-算法经验" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/22/%E7%AE%97%E6%B3%95%E7%BB%8F%E9%AA%8C/" class="article-date">
  <time class="dt-published" datetime="2021-04-21T19:37:32.000Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/22/%E7%AE%97%E6%B3%95%E7%BB%8F%E9%AA%8C/">算法经验</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="抽象和实现"><a href="#抽象和实现" class="headerlink" title="抽象和实现"></a>抽象和实现</h2><p>算法 + 数据结构 = 程序<br>程序执行三步骤：</p>
<ol>
<li>compile 编译到机器码</li>
<li>link 到各种库</li>
<li>Execute 执行目标程序</li>
</ol>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>解释型的脚本语言</p>
<h3 id="注意维护算法本身特性和代码可读性-鲁棒性"><a href="#注意维护算法本身特性和代码可读性-鲁棒性" class="headerlink" title="注意维护算法本身特性和代码可读性 鲁棒性"></a>注意维护算法本身特性和代码可读性 鲁棒性</h3><h2 id="算法的复杂度"><a href="#算法的复杂度" class="headerlink" title="算法的复杂度"></a>算法的复杂度</h2><p>当随着输入的增大，算法时间、空间复杂度是个什么规模的增加，就可以大概看得出来算法的复杂度是个什么级别。n，10<em>n，100</em>n<br>赋值语句是衡量算法的一个很好的选择，因为赋值语句包含了表达式的计算和变量的存储两个基本的资源利用。<br>某些具体的数据也会影响算法运行时间，分为最好，最差和平均的情况。平均性能提现了算法的主流功能。<br>大O表示法表示所有上限中最小的那个上限。<br>大Ω表示法所有下限中最大的那个下限。<br>算法设计中时间空间的权衡非常常见。<br>算法设计应该符合80-20准则，让80%最常用的操作性能最好，不用牺牲太多操作。<br>特别注意：python的 “+”和append复杂度，再 alst += blst 复杂度是O(na+nb)和for 循环B 来alst.append(i)是差距极大的！！！！后者只有O(nb) 因为前者本质是新生成了一个。<br>自创列表首选 list(range(number))  其次列表推导时[xxxx for i in range(number)]  不行在用append 最差最差才是 “+” 性能差太多了  </p>
<h2 id="使用timeit模块对函数计时"><a href="#使用timeit模块对函数计时" class="headerlink" title="使用timeit模块对函数计时"></a>使用timeit模块对函数计时</h2><p>该模块定义了三个实用函数和一个公共类。</p>
<pre><code>timeit.timeit(stmt=&#39;pass&#39;, setup=&#39;pass&#39;, timer=&lt;default timer&gt;, number=1000000)
</code></pre>
<p>可以先创建一个Timer对象（输入两个字符串，一个是函数，一个是函数调用来源如果是引用函数就是函数从哪里来，如果是表达式，就是变量数据从哪里初始化数据） 然后调用这个对象的timeit函数来实现求时：</p>
<pre><code>    # 方法1：Timer内都要以字符串形式输入
    from timeit import Timer
    t1 = Timer(&quot;test1()&quot;, &quot;from __main__ import test1&quot;)
    print(&quot;comprehension: %f seconds\n&quot;% t1.timeit(number=1000)) 
    
    # 方法2：变量设置 适用于简单规模
    import timeit
    t1 = timeit.Timer(&quot;a = a + b&quot;, &quot;a = 100;b=100&quot;)
    print(t1.timeit(1000))
    
    # 方法3： timeit函数直接调用timeit.timeit(stmt= , setup= , timer= , number= ,globals=)
    import timeit
    print(timeit.timeit(stmt=&quot;test1()&quot;,setup=&quot;from __main__ import test1&quot;,number=10000))
</code></pre>
<p>同样发现set的in要比dict的in性能要好一点点 10%吧。   </p>
<h2 id="前缀表达式-中缀表达式-后缀表达式"><a href="#前缀表达式-中缀表达式-后缀表达式" class="headerlink" title="前缀表达式 中缀表达式 后缀表达式"></a>前缀表达式 中缀表达式 后缀表达式</h2><p>无论表达式有多复杂，需要转换成前缀或后缀，只需要两个步骤：将中缀表达式改成全括号的模式，然后前缀表达式就是把那一层的符号放到那一层的左括号位置，后缀表达式就是把那一层的符号放到那一层的右括号位置。计算机内部通常用后缀表达式来计算，因为这样可以先把两个数扫描进来，扫到操作符就可以直接计算了。    </p>
<p>中缀表达式是最常用的算术表达式,运算符在运算数中间,运算需要考虑运算符优先级.<br>后缀表达式是计算机容易运算的表达式,运算符在运算数后面,从左到右进行运算,无需考虑优先级,运算呈线性结构。</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>FIFO，有次序的线性数据集合，可以用两个栈实现队列  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.stack_in = []</span><br><span class="line">        self.stack_out = []</span><br><span class="line"></span><br><span class="line">	<span class="comment"># enquene</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendTail</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.stack_in.append(value)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># dequeue</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stack_out:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.stack_in:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.stack_in)):</span><br><span class="line">                self.stack_out.append(self.stack_in.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack_out.pop()</span><br></pre></td></tr></table></figure>
<p>在操作系统中核心就采用了多个队列来对系统中同时运行的进程进行调度<br>进程数远多于CPU核心数   </p>
<h2 id="链表："><a href="#链表：" class="headerlink" title="链表："></a>链表：</h2><p>节点Node<br>链表实现的最基本元素是节点Node<br>每个节点至少要包含两个信息，数据项本身，以及指向下一个节点的信息<br>指向节点为None则是没有下一个节点<br>链表中第一个和最后一个节点最重要<br>可以初始化一个节点永远指向第一个节点<br>随着数据项的加入，无序表list其实本身不包含任何数据项，数据项在节点中<br>链表中size代价为O（n）<br><img src="1.png"><br>链表的操作问题，一般而言面试（机试）的时候不允许我们修改节点的值，而只能修改节点的指向操作。      </p>
<p>思路通常都不难，写对链表问题的技巧是：一定要先想清楚思路，并且必要的时候在草稿纸上画图，理清「穿针引线」的先后步骤，然后再编码。       </p>
<p>!另外在反转列表等等列表操作可能涉及head变动的时候，设置一个不变的dummyNode 指向头结点 是常用做法  </p>
<pre><code>    dummy_node = ListNode(-1)
    dummy_node.next = head
</code></pre>
<h3 id="基础的翻转链表"><a href="#基础的翻转链表" class="headerlink" title="基础的翻转链表"></a>基础的翻转链表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        if head &#x3D;&#x3D; None: </span><br><span class="line">            return None</span><br><span class="line">        dummynode &#x3D; ListNode(-1)</span><br><span class="line">        dummynode.next &#x3D; head</span><br><span class="line">        while head.next:</span><br><span class="line">            temp &#x3D; head.next</span><br><span class="line">            head.next &#x3D; temp.next</span><br><span class="line">            temp.next &#x3D; dummynode.next</span><br><span class="line">            dummynode.next &#x3D; temp</span><br><span class="line">            </span><br><span class="line">        return dummynode.next</span><br></pre></td></tr></table></figure>
<p>当然这种比较好理解但是其实复杂了，更优质的做法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        cur, pre &#x3D; head, None</span><br><span class="line">        while cur:</span><br><span class="line">            tmp &#x3D; cur.next # 暂存后继节点 cur.next</span><br><span class="line">            cur.next &#x3D; pre # 修改 next 引用指向</span><br><span class="line">            pre &#x3D; cur      # pre 暂存 cur</span><br><span class="line">            cur &#x3D; tmp      # cur 访问下一节点</span><br><span class="line">        return pre</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 练习一下递归</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def reverseList(self, head: ListNode) -&gt; ListNode:</span><br><span class="line">        if not head or not head.next:</span><br><span class="line">            return head</span><br><span class="line">        node &#x3D; self.reverseList(head.next)</span><br><span class="line">        head.next.next &#x3D; head</span><br><span class="line">        head.next &#x3D; None</span><br><span class="line">        return node</span><br></pre></td></tr></table></figure>

<h2 id="递归三要素："><a href="#递归三要素：" class="headerlink" title="递归三要素："></a>递归三要素：</h2><ol>
<li>递归终止条件（最小规模问题的直接解决）  </li>
<li>利用递归不断缩小或扩大问题规模至终止条件（将小问题规模）</li>
<li>递归算法必须调用自身</li>
</ol>
<p>当一个函数被调用的时候，系统会把调用的现场数据压入系统调用栈，每次调用，压入栈的现场数据被称为栈帧；当系统返回的时候，要从调用栈的栈顶取得返回地址，恢复现场，弹出栈帧，按地址返回。</p>
<p>RecursionError:递归层数有限，爆了，要么是无线递归，要么就是往基准条件演化太慢了，就会溢出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.getrecursionlimit()</span><br><span class="line">sys.setrecursionlimit(3000)</span><br></pre></td></tr></table></figure>
<p>递归算法最致命的问题就是可能会出现大量的重复调用递归的情况，这个时候就需要记忆化递归来消除重复计算。</p>
<h2 id="探索迷宫-东南西北方向递归-并记录走过的位置"><a href="#探索迷宫-东南西北方向递归-并记录走过的位置" class="headerlink" title="探索迷宫 东南西北方向递归  并记录走过的位置"></a>探索迷宫 东南西北方向递归  并记录走过的位置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">def searchFrom(maze, startrow, startcol):</span><br><span class="line">    maze.updatePosition(startrow, startcol)</span><br><span class="line">    # 碰到墙壁，面包（走过），越界 返回失败</span><br><span class="line">    if maze[startrow][startcol] in (OBSTRACLE, TRIED, DEAD_END):</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">    # 碰到了出口就返回成功</span><br><span class="line">    if maze.isExit(startrow, startcol):</span><br><span class="line">        maze.updatePosition(startrow, startcol, part_of_path)</span><br><span class="line">        return True</span><br><span class="line"></span><br><span class="line">    # 撒下面包 继续探索</span><br><span class="line">    maze.updatePosition(startrow, startcol, TRIED)</span><br><span class="line"></span><br><span class="line">    # 向东南西北四个方向依次探索 or有短路的效应</span><br><span class="line">    found &#x3D; searchFrom(maze, startrow-1, startcol) or searchFrom(maze, startrow, startcol-1)\</span><br><span class="line">            searchFrom(maze, startrow+1, startcol) or searchFrom(maze, startrow, startcol+1)</span><br><span class="line"></span><br><span class="line">    # 如果探索成功，标记当前点，失败则标记为死胡同</span><br><span class="line">    if found:</span><br><span class="line">        maze.updatePosition(startrow, startcol, part_of_path)</span><br><span class="line">    else:</span><br><span class="line">        maze.updatePosition(startrow, startcol, DEAD_end)</span><br><span class="line">    return found</span><br><span class="line"></span><br><span class="line">    # 啥的发送</span><br></pre></td></tr></table></figure>

<h2 id="分治策略"><a href="#分治策略" class="headerlink" title="分治策略"></a>分治策略</h2><p>将问题分成若干个更小规模的部分，通过解决每一个小规模部分问题，并将结果汇总得到原问题的解。     </p>
<h2 id="贪心策略Greedy-Method"><a href="#贪心策略Greedy-Method" class="headerlink" title="贪心策略Greedy Method"></a>贪心策略Greedy Method</h2><p>我们每次都试图解决问题的尽量大的一部分。   </p>
<h2 id="找零问题的最优解法"><a href="#找零问题的最优解法" class="headerlink" title="找零问题的最优解法"></a>找零问题的最优解法</h2><p>当然贪心策略在当前100/50/20/10/5/1得到的是最优解，但是如果币值变换呢，比如有个币值21，怎么处理呢？其实本质还是要去使用递归来实现。或者动态规划。  </p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>记忆化递归和函数值缓存递归不是动态规划。问题的最优解包含更小规模的最优解，这是一个使用动态规划的必要条件。<br>动态规划从最贱的情况开始倒带所需找零的循环<br>每一步都依靠以前的最优解来得到本步骤的最优解，直到得到答案。  </p>
<h3 id="动态规划经典题：硬币找零问题和博物馆大盗问题"><a href="#动态规划经典题：硬币找零问题和博物馆大盗问题" class="headerlink" title="动态规划经典题：硬币找零问题和博物馆大盗问题"></a>动态规划经典题：硬币找零问题和博物馆大盗问题</h3><p>博物馆大盗问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def theif_of_museum(items, maxWeight):</span><br><span class="line">    dp &#x3D; [[0] * (maxWeight + 1) for _ in range(len(items))]</span><br><span class="line">    for i in range(items[0][0], maxWeight + 1):</span><br><span class="line">        dp[0][i] &#x3D; items[0][1]</span><br><span class="line">    for row in range(1, len(dp)):</span><br><span class="line">        for col in range(1, maxWeight + 1):</span><br><span class="line">            if col - items[row][0] &lt; 0:</span><br><span class="line">                dp[row][col] &#x3D; dp[row - 1][col]</span><br><span class="line">            else:</span><br><span class="line">                dp[row][col] &#x3D; max(dp[row - 1][col], dp[row-1][col - items[row][0]] + items[row][1])</span><br><span class="line">    return dp[-1][-1]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">items &#x3D; [(2, 3), (3, 4), (4, 8), (5, 8), (9, 10)]</span><br><span class="line">print(theif_of_museum(items, 20))</span><br></pre></td></tr></table></figure>
<p>如果要跟踪解法，可以这样实现。就是新设一个和dp一样大的，如果发生改变则维护变动的那一个值，然后遍历得到全部取的宝物序号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">def theif_of_museum(items, maxWeight):</span><br><span class="line">    dp &#x3D; [[0] * (maxWeight + 1) for _ in range(len(items))]</span><br><span class="line">    newitem &#x3D; [[-1] * (maxWeight + 1) for _ in range(len(items))]</span><br><span class="line">    for i in range(items[0][0], maxWeight + 1):</span><br><span class="line">        dp[0][i] &#x3D; items[0][1]</span><br><span class="line">        newitem[0][i] &#x3D; 0</span><br><span class="line">    for row in range(1, len(dp)):</span><br><span class="line">        for col in range(1, maxWeight + 1):</span><br><span class="line">            if col - items[row][0] &lt; 0:</span><br><span class="line">                dp[row][col] &#x3D; dp[row - 1][col]</span><br><span class="line">            else:</span><br><span class="line">                if dp[row - 1][col] &lt; dp[row-1][col - items[row][0]] + items[row][1]:</span><br><span class="line">                    dp[row][col] &#x3D; dp[row-1][col - items[row][0]] + items[row][1]</span><br><span class="line">                    newitem[row][col] &#x3D; row</span><br><span class="line">    res &#x3D; []</span><br><span class="line">    row, col &#x3D; len(items) - 1, maxWeight</span><br><span class="line">    while row &gt;&#x3D; 0 and col &gt;&#x3D; 0:</span><br><span class="line">        if newitem[row][col] !&#x3D; -1:</span><br><span class="line">            res.append(newitem[row][col])</span><br><span class="line">            col -&#x3D; items[row][0]</span><br><span class="line">            row -&#x3D; 1</span><br><span class="line">        else:</span><br><span class="line">            row -&#x3D; 1</span><br><span class="line">    return dp[-1][-1], res</span><br></pre></td></tr></table></figure>

<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>二分查找容易陷入死循环，但千万记住，核心是：<strong>left 必须 mid + 1</strong> 否则 容易死循环，因为，最后就剩两个元素， //整除会得到那个左坐标的数，必然死循环。还有一定要注意，需要把mid = (left + right)//2 写在while left &lt; right里面 。<br>此外记住，如果二封插入需要插在右边，记住一定要right =len()不能-1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 求左坐标就要用 &gt;&#x3D;  右坐标用 &lt;&#x3D;  因为我们相当于是吧 &#x3D;&#x3D; 的情况是挪动左坐标还是右坐标</span><br><span class="line">def bisect_left(s, t):</span><br><span class="line">    left, right &#x3D; 0, len(s)</span><br><span class="line">    while left &lt; right:</span><br><span class="line">        mid &#x3D; (right + left) &#x2F;&#x2F; 2</span><br><span class="line">        if s[mid] &gt;&#x3D; t:</span><br><span class="line">            right &#x3D; mid - 1</span><br><span class="line">        else:</span><br><span class="line">            left &#x3D; mid + 1</span><br><span class="line">    return left</span><br><span class="line"></span><br><span class="line">def bisect_right(s, t):</span><br><span class="line">    left, right &#x3D; 0, len(s)</span><br><span class="line">    while left &lt; right:</span><br><span class="line">        mid &#x3D; (right + left) &#x2F;&#x2F; 2</span><br><span class="line">        if s[mid] &lt;&#x3D; t:</span><br><span class="line">            left &#x3D; mid + 1</span><br><span class="line">        else:</span><br><span class="line">            right &#x3D; mid - 1</span><br><span class="line">    return right</span><br></pre></td></tr></table></figure>


<h2 id="冒泡排序Bubble-sort"><a href="#冒泡排序Bubble-sort" class="headerlink" title="冒泡排序Bubble sort"></a>冒泡排序Bubble sort</h2><p>两个两个相邻比较，如果逆序，就交换位置，这样每一轮就吧最大值挪到最后了。比对是n-1+…+1所以是o(n^2)。冒泡排序直观，而且没有额外的空间开销，其次很多数据结构都能实现，比如链表。因为只要两两相邻对比。<br>此外冒泡排序如果一轮循环下来，没有发生任意交换，意味着两个相邻之间都是后者大于前者，列表已经排好序了所以这个时候就可以提前终止循环。一种优化。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def bubbleSort(alist):</span><br><span class="line">    exchanges &#x3D; True</span><br><span class="line">    passnum &#x3D; len(alist) - 1</span><br><span class="line">    while passnum &gt; 0 and exchanges:</span><br><span class="line">        exchanges &#x3D; False</span><br><span class="line">        for i in range(passnum):</span><br><span class="line">            if alist[i]&gt;alist[i+1]:</span><br><span class="line">                exchanges &#x3D; True</span><br><span class="line">                temp &#x3D; alist[i]</span><br><span class="line">                alist[i] &#x3D; alist[i+1]</span><br><span class="line">                alist[i+1] &#x3D; temp</span><br><span class="line">        passnum &#x3D; passnum -1</span><br><span class="line">    return alist</span><br></pre></td></tr></table></figure>
<p>改进并没有减少复杂度。  </p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序是在冒泡排序的基础上，把O(N^2)的交换的复杂度降为了o(n)因为他只交换一次，但是比对还是o(n^2)级别 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def selectionSort(alist):</span><br><span class="line">    for fillslot in range(len(alist) - 1, 0, -1):</span><br><span class="line">        positionOfMax &#x3D; 0</span><br><span class="line">        for location in range(1, fillslot + 1):</span><br><span class="line">            if alist[location] &gt; alist[positionOfMax]:</span><br><span class="line">                positionOfMax &#x3D; location</span><br><span class="line"></span><br><span class="line">        alist[fillslot], alist[positionOfMax] &#x3D; alist[positionOfMax], alist[fillslot]</span><br><span class="line">    return alist</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>维护一个排好序的前缀单调序列，每一项和前一项比，如果比前一项小，就前一项向后挪一位，直到比到比前一项目大的时候，就插入在这个位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def insertionSort(alist):</span><br><span class="line">    for index in range(1,len(alist)):</span><br><span class="line">        </span><br><span class="line">        currentvalue &#x3D;alist[index]</span><br><span class="line">        position &#x3D; index</span><br><span class="line">        </span><br><span class="line">        while position&gt;0 and alist[position-1]&gt;currentvalue:</span><br><span class="line">            alist[position] &#x3D; alist[position-1]</span><br><span class="line">            position &#x3D; position -1</span><br><span class="line">            </span><br><span class="line">        alist[position] &#x3D; currentvalue</span><br><span class="line"># 其实也可以不用赋值position 因为for循环不受循环内部影响变量i</span><br><span class="line">def insertSort(lst):</span><br><span class="line">    for i in range(1,len(lst)):</span><br><span class="line">        temp &#x3D; lst[i]</span><br><span class="line">        while i &gt; 0 and temp &lt; lst[i - 1]:</span><br><span class="line">            lst[i] &#x3D; lst[i - 1]</span><br><span class="line">            i -&#x3D; 1</span><br><span class="line">        lst[i] &#x3D; temp</span><br><span class="line">    return lst</span><br></pre></td></tr></table></figure>
<p>当然插入排序还是O（n^2）次比较，但是利用了已经维护好的一个单调区间，所以这样比对次数可以提前停止比对，从而降低比对次数。<br>对于这个本身也可以利用二分插入，实现更低的比较次数。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 自己想法。。。没有教材支持</span><br><span class="line">def insertSort(lst):</span><br><span class="line">    sortlist &#x3D; [lst[0]]</span><br><span class="line">    for i in range(1, len(lst)):</span><br><span class="line">        temp &#x3D; lst[i]</span><br><span class="line">        left, right &#x3D; 0, i </span><br><span class="line">        while left &lt; right:</span><br><span class="line">            mid &#x3D; (left + right) &#x2F;&#x2F; 2</span><br><span class="line">            if sortlist[mid] &lt;&#x3D; temp:</span><br><span class="line">                left &#x3D; mid + 1</span><br><span class="line">            else:</span><br><span class="line">                right &#x3D; mid</span><br><span class="line">        sortlist.insert(left, temp)</span><br><span class="line">    return sortlist</span><br></pre></td></tr></table></figure>
<p>性能比较：时间复杂度降低，空间复杂度拉高。多了一个额外的数组方便插入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import random, time</span><br><span class="line">lst &#x3D; [random.randint(1, 10000) for _ in range(10000)]</span><br><span class="line">t1 &#x3D; time.time()</span><br><span class="line">s1 &#x3D; insertSort1(lst)</span><br><span class="line">t2 &#x3D; time.time()</span><br><span class="line">s2 &#x3D;insertSort2(lst)</span><br><span class="line">t3 &#x3D; time.time()</span><br><span class="line">print(&quot;NormalInsertSort takes %.5f seconds\nBinaryInsertSort takes %.5f seconds&quot; % (t3 - t2, t2 - t1))</span><br><span class="line"># NormalInsertSort takes 3.93286 seconds</span><br><span class="line"># BinaryInsertSort takes 0.03095 seconds</span><br></pre></td></tr></table></figure>

<h2 id="谢尔排序（希尔排序-shell-sort）O-n-1-5-不稳定算法"><a href="#谢尔排序（希尔排序-shell-sort）O-n-1-5-不稳定算法" class="headerlink" title="谢尔排序（希尔排序 shell sort）O(n^1.5) 不稳定算法"></a>谢尔排序（希尔排序 shell sort）O(n^1.5) 不稳定算法</h2><p>在插入排序基础上，设置间隔去排，也就是<strong>分组</strong>。先分组组内实现排序，逐步降低分组间隔，让整个序列越来越接近有序，最后一轮就是插入排序，这样降低很多无效比对。介于o(n)、o(n^2)之间 可以看成o(n^1.5)  shellsort实在插入排序基础上实现的，是先分组，再插入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def shellsort(lst):</span><br><span class="line">    n &#x3D; len(lst)</span><br><span class="line">    gap &#x3D; n &#x2F;&#x2F; 2</span><br><span class="line">    while gap &gt; 0:</span><br><span class="line">        for start in range(gap):  # 记住循环体循环的是什么，是多少组，所以一定是gap个啊  不是n - gap</span><br><span class="line">            for i in range(start + gap, n, gap):</span><br><span class="line">                temp &#x3D; lst[i]</span><br><span class="line">                while i &gt; start and temp &lt; lst[i - gap]:  # 这里容易错 这里得是temp比 容易写成lst[i]记住我们要插入到正确位置的是temp</span><br><span class="line">                    lst[i] &#x3D; lst[i - gap]</span><br><span class="line">                    i -&#x3D; gap</span><br><span class="line">                lst[i] &#x3D; temp</span><br><span class="line">        gap &#x3D; gap &#x2F;&#x2F; 2</span><br><span class="line">    return lst</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="归并排序-merge-sort-O-nlogn-稳定算法-但是O-n-的空间复杂度"><a href="#归并排序-merge-sort-O-nlogn-稳定算法-但是O-n-的空间复杂度" class="headerlink" title="归并排序 merge sort O(nlogn) 稳定算法 但是O(n)的空间复杂度"></a>归并排序 merge sort O(nlogn) 稳定算法 但是O(n)的空间复杂度</h2><p>递归来实现排序，持续将数据表分裂成两半，对两半分别排序。排序完合并起来，合并起来的时候拉链式比较后回填。核心是递归和合并。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># 简化写法</span><br><span class="line">def mergesort(lst):</span><br><span class="line">    if len(lst) &lt;&#x3D; 1:  # 递归方法 先写递归结束条件</span><br><span class="line">        return lst</span><br><span class="line">    mid &#x3D; len(lst) &#x2F;&#x2F; 2</span><br><span class="line">    left &#x3D; mergesort(lst[:mid])</span><br><span class="line">    right &#x3D; mergesort(lst[mid:])</span><br><span class="line">    merge &#x3D; []</span><br><span class="line">    while left and right:</span><br><span class="line">        if left[0] &lt;&#x3D; right[0]:</span><br><span class="line">            merge.append(left.pop(0))</span><br><span class="line">        else:</span><br><span class="line">            merge.append(right.pop(0))</span><br><span class="line">    merge.extend(left)</span><br><span class="line">    merge.extend(right)</span><br><span class="line">    return merge</span><br><span class="line"></span><br><span class="line"># 当然pop(0)复杂度太高，而且新增空间 其实这里切片操作也是提高复杂度了，可以通过直接传输起始点和终止点 而不是整个切片数据</span><br><span class="line"></span><br><span class="line">def mergeSort(alist):</span><br><span class="line">    if len(alist) &gt; 1:   #技术条件</span><br><span class="line">        mid &#x3D; len(alist)&#x2F;&#x2F;2</span><br><span class="line">        lefthalf &#x3D; alist[:mid]</span><br><span class="line">        righthalf &#x3D; alist[mid:]</span><br><span class="line">        mergeSort(lefthalf)</span><br><span class="line">        mergeSort(righthalf)   #递归调用 左半边右半边分别排序</span><br><span class="line">        </span><br><span class="line">        i &#x3D; j &#x3D; k &#x3D; 0</span><br><span class="line">        while i &lt; len(lefthalf) and j &lt; len(righthalf):</span><br><span class="line">            if lefthalf[i] &lt; righthalf[j]:</span><br><span class="line">                alist[k] &#x3D; lefthalf[i]    #拉链式交错吧左右半部从小到大归并到结果列表中</span><br><span class="line">                i &#x3D; i + 1</span><br><span class="line">            else:</span><br><span class="line">                alist[k] &#x3D; righthalf[j]</span><br><span class="line">                j &#x3D; j + 1</span><br><span class="line">            k &#x3D; k + 1</span><br><span class="line">        while i &lt; len(lefthalf):</span><br><span class="line">            alist[k] &#x3D; lefthalf[i]       #归并左半部剩余项</span><br><span class="line">            i &#x3D; i + 1</span><br><span class="line">            k &#x3D; k + 1</span><br><span class="line">        </span><br><span class="line">        while j &lt; len(righthalf):</span><br><span class="line">            alist[k] &#x3D; righthalf[j]      #归并右半部剩余项</span><br><span class="line">            j &#x3D; j + 1</span><br><span class="line">            k &#x3D; k + 1</span><br><span class="line">    return alist</span><br></pre></td></tr></table></figure>

<h2 id="快速排序-Quick-Sort-O-nlogn"><a href="#快速排序-Quick-Sort-O-nlogn" class="headerlink" title="快速排序 Quick Sort O(nlogn)"></a>快速排序 Quick Sort O(nlogn)</h2><p>快速排序的思路是一句一个中值，把数据表分成两半，小于中值的一般和大于中值的一半，然后每部分分别进行快速排序（递归）<br>快速排序是不稳定的排序方法，中值点取得不好就容易出现n^2的复杂度，不需要额外的存储空间。中值如何选取很重要，所以对数据的了解，能很大程度上改进算法。当不确定数据的情况，可以选择三点取样，头尾中间取一个然后选择一个中值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 完全图省事的算法 复杂度增加了很多 也增加了额外的存储空间</span><br><span class="line">def quicksort(alist):</span><br><span class="line">    if len(alist) &lt; 2:</span><br><span class="line">        return alist</span><br><span class="line">    idx &#x3D; 0</span><br><span class="line">    less_part &#x3D; [i for i in alist[1:] if i &lt;&#x3D; alist[idx]]</span><br><span class="line">    more_part &#x3D; [i for i in alist[1:] if i &gt; alist[idx]]</span><br><span class="line">    return quicksort(less_part) + [alist[idx]] + quicksort(more_part)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 完整实现</span><br><span class="line">def quick_sort(array):</span><br><span class="line">    return quick_sort_inplace(array, 0, len(array) - 1)</span><br><span class="line"></span><br><span class="line">def quick_sort_inplace(array, beg, end):</span><br><span class="line">    if beg &lt; end:</span><br><span class="line">        pivot &#x3D; partition(array, beg, end)</span><br><span class="line">        quick_sort_inplace(array, beg, pivot - 1)</span><br><span class="line">        quick_sort_inplace(array, pivot + 1, end)</span><br><span class="line">    return array</span><br><span class="line"></span><br><span class="line">def partition(array, beg, end):</span><br><span class="line">    pivot &#x3D; array[beg]</span><br><span class="line">    left, right &#x3D; beg + 1, end</span><br><span class="line">    while True:</span><br><span class="line">        while left &lt;&#x3D; right and array[left] &lt;&#x3D; pivot:</span><br><span class="line">            left +&#x3D; 1</span><br><span class="line">        while left &lt;&#x3D; right and array[right] &gt;&#x3D; pivot:</span><br><span class="line">            right -&#x3D; 1</span><br><span class="line">        if left &gt; right:</span><br><span class="line">            break</span><br><span class="line">        else:</span><br><span class="line">            array[left], array[right] &#x3D; array[right], array[left]</span><br><span class="line">            left, right &#x3D; left + 1, right - 1</span><br><span class="line">    array[right], array[beg] &#x3D; pivot, array[right]</span><br><span class="line">    return right</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="C-、JAVA、-python-里的sort怎么实现的用什么算法"><a href="#C-、JAVA、-python-里的sort怎么实现的用什么算法" class="headerlink" title="C++、JAVA、 python 里的sort怎么实现的用什么算法"></a>C++、JAVA、 python 里的sort怎么实现的用什么算法</h2><p>C++毫无疑问用到了快速排序，但不仅仅使用了快速排序，还结合了插入排序和堆排序。STL的sort算法数据量大的时候使用QuickSort快速排序，分段归并排序。一旦分段后的数据量小于某个门槛比如16个，为了避免快排的递归调用深度过深，就改用heapsort 堆排序，如果递归调用带来过大负荷就改用insertion sort插入排序。流程是：原始数据快速排序分段，如果数据量小，就插入排序，递归深，就堆排序。里面有个__lg函数用来计算递归深度，如果深度达到该值，就改为堆排序。因为堆排序时间复杂度很定O(nlogn).而负载过大的时候使用插入排序，因为在已经接近有序的情况下，插入排序的比对次数很少，性能很不错。核心原因都在于快速排序是需要选择一个中间值的，如果中间值选择的不好，没有将数据化分开，则很有可能将自己的快速排序的时间复杂度变成了 n^2。这种混合式排序能稳定在nlog(n)又比一上来就堆排序要好。总结：当数据量比较大的时候先用的快排，当数据量小的时候用直接插入，因为当数据量变小时，快排中的每个部分基本有序，接近直接插入的最好情况的时间复杂度O(n)，就比快排要好一点了。如果是数据量过大，递归深度过深超过阙值，就改为堆排序。      </p>
<p>java内部用的都是归并排序， 因为C++模板有很强的inline优化机制，比较操作相对于赋值（移动）操作要快的多（尤其是元素较大时），而java中的情况正好相反，移动（赋值）一般比比较快；另一方面，一般情况下，归并排序的比较次数小于快速排序的比较次数，而移动次数一般多于快速排序的移动次数，二者大约都是2~3倍的差距。因为这样，java标准库中的一般排序使用的归并排序的一种变种。     </p>
<p>python内部的sort采用的是混合（hybrid）排序，规模小的时候采用binary insertion，规模大的时候采用samplesort。首先检查数据是否已经排序(或reverse sorted)了，O(N)，如果有，那么就直接返回了如果已经基本排序了，就使用binary insertion sort算法如果数据集很小（小于100个），那么就使用binary insertion sort算法；如果数据集很大，就会使用samplesort。<br><img src="2.png" alt="排序算法"></p>
<h2 id="散列"><a href="#散列" class="headerlink" title="散列"></a>散列</h2><p>如果一个数据结构数据项之间是已经大小排好序的，就可以利用二分查找来降低算法复杂度。而散列Hashing则可以将查找复杂度降为O（1）。就需要用到散列函数，散列函数是实现数据项到存储槽名称之间转换的。一种常用的设计散列函数的方式就是求余数，将数据项除以散列表的大小，作为存储槽的槽号。<br>负载因子： 存储空间/总槽位<br>冲突：不同值求散列函数得到相同槽位<br>散列函数： 1. 冲突越少 2. 计算难度越低（额外开销小） 3. 充分分散数据项（节约空间） 就越完美</p>
<p>近似完美散列函数MD5和SHA。 MD5将任何长度的数据变换为固定长为128位（16字节）的摘要</p>
<p>python自带MD5和SHA系列的散列函数库，hashlib<br>除了对单个字符串进行散列计算外，还可以用update方法对任意长度的数据分部分计算。完美散列函数可以用于数据一致性校验，为每个文件计算其散列值，如果相等则两个文件内容相同。用于网络文件下载完整性校验；用于文件分享系统，网盘中相同的文件可以无需存储多次；加密形式保存密码，客户端只发送输入密码的散列值，服务器端也存储的是散列值，相比较；防文件篡改。  </p>
<h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>区块链是一种分布式数据库，通过网络连接各个节点，每个节点都存储这整个数据库的所有数据，任何地点存的输入，都会完成同步。最本质就是“去中心化”，所有节点都是平等的。<br>区块链由一个个区块block组成，区块分为头head 和 躯体body。区块头记录了一些元数据和连接前一个区块的信息。（生成时间、和前一个区块的散列值）<br>工作量证明 pow  因为区块链是大规模的分布式数据库，同步比较慢，新区块添加速度需要得到控制。   </p>
<h2 id="散列函数设计：折叠法"><a href="#散列函数设计：折叠法" class="headerlink" title="散列函数设计：折叠法"></a>散列函数设计：折叠法</h2><p>将数据项按照位数分成若干段，相加对散列表大小求余。   </p>
<h2 id="散列函数设计：平方取中法"><a href="#散列函数设计：平方取中法" class="headerlink" title="散列函数设计：平方取中法"></a>散列函数设计：平方取中法</h2><p>将数据项平方运算，然后去平方数的中间两位，在对散列表大小求余数。</p>
<h2 id="散列函数设计：非数据项"><a href="#散列函数设计：非数据项" class="headerlink" title="散列函数设计：非数据项"></a>散列函数设计：非数据项</h2><p>对非数字的数据项进行散列 把字符串中的每个字符看成ASCII码即可。同时为了方式变位词比如（has，sah）这样的影响，我们对每个字符所在的位置赋予权重因子，再加起来。<br>散列函数设计一定要设计的相对简单，否则无论是存储还是查找的时候都需要计算散列函数，那么就会浪费大量的计算，可能效率最终还不如顺序存取遍历查找。    </p>
<h2 id="散列函数冲突解决方案"><a href="#散列函数冲突解决方案" class="headerlink" title="散列函数冲突解决方案"></a>散列函数冲突解决方案</h2><p>为冲突数据项再找一个开放空槽来存放，这种技术被称为开放定址，向后逐个槽寻找的方法则是开放定址技术中的线性探测。+1的线性探测容易出现聚集的现象，我们可以跳跃式线性探测，比如 +3。在设计跳跃式线性存储方式下，注意skip的取值不能被散列表大小整除，否则会产生周期，造成很多槽永远填不到。一个技巧是把散列表的大小设计为素数。    </p>
<p>另一种解决冲突的办法时数据项链。就是把槽从容纳单个数据项变成容纳数据项的集合。</p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>非线性数据结构<br>树由节点和边组成  每个节点都具有名称或“键值”<br>边Edge是组成树的另一个基本部分，每个边恰好连接两个节点，表示两个节点关联，边具有出入性，每个节点除了根节点都有入边，有0条或者多条出边<br>根节点是没有入边的节点，叶节点是没有出边的节点<br>子节点就是入边均来自一个节点的若干节点，称为这个节点的子节点<br>父节点Parent 一个节点是其所有出边的父节点<br>兄弟节点 Sibling 具有相同一个父节点的节点称为兄弟节点<br>子树 Subtree 一个节点和气所有子孙节点以及边的集合<br>路径Path指的是由边一次连接一起的节点有序列表<br>一个节点的子节点和另一个节点的子节点是相互隔离、独立的<br>每个叶节点都具有唯一性<br>层级 Level  从根节点到大一个节点路径中所包含边的数量 就是层级 根节点层级为0<br>高度：树中所有节点最大层级称为数的高度<br>每个节点最多有两个节点的称为 二叉树<br>树是空集，或者由根节点以及0或多个子树构成的<br>一个完全二叉树一共是 2^k - 1个节点，而且叶节点比非叶节点多1个。</p>
<pre><code># 利用链表实现二叉树 
class BinaryTree:

    def __init__(self,rootObj):
        self.key = rootObj
        self.leftChild = None
        self.rightChild = None
    
    def insertLeft(self,newNode):
        if self.leftChild == None:
            self.leftChild = BinaryTree(newNode)
        else:
            t = BinaryTree(newNode)
            t.leftChild = self.leftChild   #把新的二叉树的左链接指向原左链接指向的地址，再把根指向新生成的二叉树
            self.leftChild = t
    
    def insertRight(self,newNode):
        if self.rightChild == None:
            self.rightChild = BinaryTree(newNode)
        else:
            t = BinaryTree(newNode)
            t.rightChild = self.rightChild
            self.rightChild = t
    
    def getRightChild(self):
        return self.rightChild
    
    def getLeftChild(self):
        return self.leftChild
    
    def setRootVal(self,obj):
        self.key = obj
        
    def getRootVal(self):
        return self.key
    
    def preorder(self):
        print(self.key)
        if self.leftChild:
            self.leftChild.preorder()
        if self.rightChild:
            self.rightChild.preorder()



# 嵌套列表实现二叉树 
def BinaryTree(r):
    return [r,[],[]]

def insertLeft(root,newBranch):
    t = root.pop(1)
    if len(t) &gt;1:
        root.insert(1,[newBranch,t,[]])  #以newBranch作为新左子树的根 原来的左子树作为新左子树的左子树
    else:
        root.insert(1,[newBranch,[],[]])  
    return root

def insertRight(root,newBranch):
    t = root.pop(2)
    if len(t) &gt;1:
        root.insert(2,[newBranch,t,[]])
    else:
        root.insert(2,[newBranch,[],[]])
    return root

def getRootVal(root):
    return root[0]

def setRootVal(root,newVal):
    root[0] = newVal

def getLeftChild(root):
    return root[1]

def getRightChild(root):
    return root[2]
</code></pre>
<h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>树是一种非线性的数据结构，所以遍历的时候利用递归调用来实现。<br>前序遍历 preorder 先访问根节点，在递归谦虚访问左子树，最后访问右子树 就好比看书，看书就是前序遍历，目录然后第一章，第一章的第一节，第一章的第二节，第一章的第二节的第一话。。。。。<br>中序遍历 inorder 先递归中序访问左子树，再访问根节点，最后中序访问右子树<br>后序遍历 postorder 先递归后续访问左子树，在后续访问右子树 最后访问根节点  </p>
<pre><code>def preorder(tree):  #前序遍历 根 左右
    if tree:
        print(tree.getRootVal())
        preorder(tree.getLeftChild())
        preorder(tree.getRightChild())

def postorder(tree):#后序遍历 左右根
    if tree != None:
        postorder(tree.getLeftChild())
        postorder(tree.getRightChild())
        print(tree.getRootVal())

def inorder(tree):#中序遍历  左根 右
    if tree != None:
        inorder(tree.getLeftChild())
        print(tree.getRootVal())
        inorder(tree.getRightChild())
</code></pre>
<h2 id="建立表达式解析树的过程（链表-栈）"><a href="#建立表达式解析树的过程（链表-栈）" class="headerlink" title="建立表达式解析树的过程（链表+栈）"></a>建立表达式解析树的过程（链表+栈）</h2><p>遇到左括号就生成并下降到左子节点，遇到操作数就写入当前节点的值然后返回父节点，遇到操作符就写入节点的值然后生成并下降到右子节点，遇到右括号，就上升到父节点。（上升父节点需要栈，下降的时候之前把当前节点push进入栈）<br>此外涉及表达式问题，各种if “+”,”/“这种影响整个代码可阅读性，可以考虑用operator模块，直接用个字典形式定义，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import operator</span><br><span class="line">oper &#x3D; &#123;&#39;+&#39;: operator.add, &#39;&#x2F;&#x2F;&#39;: operator.floordiv, &#39;&#x2F;&#39;: operator.truediv&#125;</span><br><span class="line">oper[&quot;+&quot;](a, b)</span><br></pre></td></tr></table></figure>

<h2 id="优先队列Priority-Queue-二叉堆（大根堆、小根堆）Binary-Heap"><a href="#优先队列Priority-Queue-二叉堆（大根堆、小根堆）Binary-Heap" class="headerlink" title="优先队列Priority Queue 二叉堆（大根堆、小根堆）Binary Heap"></a>优先队列Priority Queue 二叉堆（大根堆、小根堆）Binary Heap</h2><p>二叉堆有趣之处在于，其逻辑结构上象二叉堆，却是在用非嵌套的列表来实现的。最小的key排在队首，叫最小堆。反之最大堆。<br>为了使堆操作能保持在对数水平，就必须采用二叉树结构。如果要使操作始终保持在对数数量级上，就必须始终保持二叉树的平衡。<br>堆： 一种特殊的完全二叉树结构  </p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>叶节点只出现在最底层或者次底层，而且叶节点优先出现在最左边。每个内部节点都有两个子节点，最多一个内部节点例外。<br>完全二叉树的特殊性质，可以用非嵌套列表实现，因为一个节点的下标如果是P,则其左子节点一定是2P，右子节点是2P+1，父节点是P//2  （前提是根节点的索引是1而不是0开始的）<br>堆次序Heap order<br>为了维护堆次序，保证每个路径上的堆次序不受破坏，当新节点插入的时候，我们让他从列表的最后不断和父节点比较然后上浮。<br>当某个节点被移除时，我们选择从最后一个节点来填这个窟窿，然后，下沉这个节点，当然如果比左右子节点都大的时候，我们选择较小的子节点交换下沉。（因为如果选择较大的交换，那么较大这个节点比这个子节点大，还是交换）</p>
<p>一个无序表生成二叉堆，不需要一个个插入，直接用下沉法，就能吧总代价控制在o(n)。对每个叶节点的父节点，下沉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">class BinHeap:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.heaplist &#x3D; [0]</span><br><span class="line">        self.currentsize &#x3D; 0</span><br><span class="line"></span><br><span class="line">    def insert(self, val):</span><br><span class="line">        self.heaplist.append(val)</span><br><span class="line">        self.currentsize +&#x3D; 1</span><br><span class="line">        temp &#x3D; self.currentsize</span><br><span class="line">        while temp &#x2F;&#x2F; 2 &gt; 0:</span><br><span class="line">            if self.heaplist[temp &#x2F;&#x2F; 2] &lt; self.heaplist[temp]:</span><br><span class="line">                self.heaplist[temp &#x2F;&#x2F; 2], self.heaplist[temp] &#x3D; self.heaplist[temp], self.heaplist[temp &#x2F;&#x2F; 2]</span><br><span class="line">                temp &#x3D; temp &#x2F;&#x2F; 2</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">    def delMin(self):</span><br><span class="line">        self.heaplist[1], self.heaplist[-1] &#x3D; self.heaplist[-1], self.heaplist[1]</span><br><span class="line">        self.currentsize -&#x3D; 1</span><br><span class="line">        i &#x3D; 1</span><br><span class="line">        while i * 2 &lt;&#x3D; self.currentsize:</span><br><span class="line">            mc &#x3D; self.minChild(i)</span><br><span class="line">            if self.heaplist[i] &gt; self.heaplist[mc]:</span><br><span class="line">                self.heaplist[i], self.heaplist[mc] &#x3D; self.heaplist[mc], self.heaplist[i]</span><br><span class="line">            i &#x3D; mc</span><br><span class="line">        return self.heaplist.pop()</span><br><span class="line"></span><br><span class="line">    def minChild(self, i):</span><br><span class="line">        if i * 2 + 1 &gt; self.currentsize:</span><br><span class="line">            return i * 2</span><br><span class="line">        else:</span><br><span class="line">            if self.heaplist[i * 2] &lt; self.heaplist[i * 2 + 1]:</span><br><span class="line">                return i * 2</span><br><span class="line">            else:</span><br><span class="line">                return i * 2 + 1</span><br><span class="line"></span><br><span class="line">    def percdown(self, i):</span><br><span class="line">        while i * 2 &lt;&#x3D; self.currentsize:</span><br><span class="line">            mc &#x3D; self.minChild(i)</span><br><span class="line">            if self.heaplist[i] &gt; self.heaplist[mc]:</span><br><span class="line">                self.heaplist[i], self.heaplist[mc] &#x3D; self.heaplist[mc], self.heaplist[i]</span><br><span class="line">            i &#x3D; mc</span><br><span class="line"></span><br><span class="line">    def buildHeap(self, alist):</span><br><span class="line">        i &#x3D; len(alist) &#x2F;&#x2F; 2  # 叶节点不需要下沉</span><br><span class="line">        self.currentsize &#x3D; len(alist)</span><br><span class="line">        self.heaplist &#x3D; [0] + alist</span><br><span class="line">        while i &gt; 0:</span><br><span class="line">            self.percdown(i)</span><br><span class="line">            i &#x3D; i - 1</span><br></pre></td></tr></table></figure>



<h2 id="堆排序-稳定算法-o（nlogn）内置模块heapq"><a href="#堆排序-稳定算法-o（nlogn）内置模块heapq" class="headerlink" title="堆排序  稳定算法 o（nlogn）内置模块heapq"></a>堆排序  稳定算法 o（nlogn）内置模块heapq</h2><p>写堆排序 核心是写出下沉算法</p>
<ol>
<li>建立一个堆  </li>
<li>得到堆顶元素，为最大元素   </li>
<li>去掉堆顶，将堆最后一个元素放到堆顶，此时可以通过一次调整重新使堆有序   </li>
<li>堆顶元素为最第二大元素   </li>
<li>重复循环直至堆空    </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">def percdown(lst, lo, hi):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    :param lst: 排序的数组</span><br><span class="line">    :param lo: 下沉的节点位置</span><br><span class="line">    :param hi: 堆的最后一个节点的下标</span><br><span class="line">    :return: None  数组下沉inplace</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    i &#x3D; lo</span><br><span class="line">    j &#x3D; i * 2 + 1</span><br><span class="line">    temp &#x3D; lst[lo]</span><br><span class="line">    while j &lt;&#x3D; hi:  # 下沉的过程不就是个插入排序么</span><br><span class="line">        if j + 1 &lt;&#x3D; hi and lst[j + 1] &gt; lst[j]:</span><br><span class="line">            j +&#x3D; 1</span><br><span class="line">        if lst[j] &gt; temp:  # 注意这里是temp插入排序 所以不要一直搁这里两两交换 冒泡</span><br><span class="line">            lst[i] &#x3D; lst[j]</span><br><span class="line">            i &#x3D; j</span><br><span class="line">            j &#x3D; 2 * i + 1</span><br><span class="line">        else:</span><br><span class="line">            break</span><br><span class="line">    lst[i] &#x3D; temp</span><br><span class="line"></span><br><span class="line">def Heapsort(lst):</span><br><span class="line">    n &#x3D; len(lst)</span><br><span class="line">    for i in range((n - 2)&#x2F;&#x2F;2, -1, -1):</span><br><span class="line">        percdown(lst, i, n - 1)  # 对所有父节点 下沉 就可以得到堆 这个和所有父节点上浮 一个意义 完成堆建立 </span><br><span class="line">    for i in range(n - 1, -1, -1):</span><br><span class="line">        lst[i], lst[0] &#x3D; lst[0], lst[i]</span><br><span class="line">        percdown(lst, 0, i - 1)  # 注意这里要 -1 因为最后一个已经赋值最大值了</span><br></pre></td></tr></table></figure>

<h2 id="heapq模块-小根堆"><a href="#heapq模块-小根堆" class="headerlink" title="heapq模块 小根堆"></a>heapq模块 小根堆</h2><p>heapq # q -&gt; queue 优先队列<br>heapify(list) 建立一个小根堆 不返回值 inplace<br>heappop(heap) 堆结构弹出最小值<br>merge(lst1, lst2) 将<strong>已经排序好的list1和list2</strong>合并成一个排序好的值的<strong>生成器</strong><br>heapqreplace(heap, num) 将最小数弹出 并在堆中插入num<br>heapqheappushpop(heap, num)将最小数弹出 并在堆中插入num<br>heapq.nlargest(num, list)  获得最大的n个值降序排列的数组<br>heapq.nsmallest(num, list) 获得最小的n个值升序排序的数组<br>heappush(heap, item) 将item插入堆中</p>
<h2 id="Queue和deque"><a href="#Queue和deque" class="headerlink" title="Queue和deque"></a>Queue和deque</h2><p>队列python有两个模块，一个是queue模块的Queue() 单链表实现的pop(0)复杂度O（1），一个是collections里的deque用双链表实现的，pop()和pop(0)都是o(1)复杂度。<br>简单介绍一下Queue的方法<br>常用就是put， get 和empty，这里注意，直接判断 if q不能判断出是否为空，必须得q.empty()  put(item)就是队尾加入item节点，get就是弹出队首节点。qsize 是返回长度。  Queue（）括号呢是size指定长度，越界会block可以设定block后的操作不知道怎么解决。也不报错也不弹出。<br>collections里的deque实现方法多样基本和list类似，但是毕竟式双链表，建立连接开销肯定大一点。<br>deque(lst)可以直接把lst变成一个链表。list支持的这里基本功能和实现结果都类似，pop()也是弹出列表尾部，如果弹出队首是popleft(),append()、appendleft(),extend()insert()都支持  如果只是想用一个简单的队列，可能从名字上看上去“Queue”更合适。当然用是可以用的，不过，Queue相比deque有个坏处：慢不少。<br>在Python里，queue.Queue主要是为了线程间通信，作为“队列”只是附带的功能。而collections.deque就是个容器，和dict，list类似。   </p>
<h2 id="ADT-Map的实现方案"><a href="#ADT-Map的实现方案" class="headerlink" title="ADT Map的实现方案"></a>ADT Map的实现方案</h2><ol>
<li>有序表数据结构 + 二分搜索算法</li>
<li>散列表数据结构 + 散列以及冲突解决算法</li>
<li>二叉查找树 保存key</li>
</ol>
<h2 id="二叉查找树-BST"><a href="#二叉查找树-BST" class="headerlink" title="二叉查找树 BST"></a>二叉查找树 BST</h2><p>比父节点小的key都出现在左子树， 比父节点大的都出现在右子树<br>BST插入顺序 不同生成的BST也不不同<br>BST是一个递归的结构   </p>
<pre><code>    # __setitem__(self, k, v)实现索引赋值 :

    mytree = BinarySearchTree()
    mytree[3] = &quot;red&quot;
    mytree[4] = &quot;blue&quot;

    # __getitem__(self, key)实现索引取值
    # __contains__(self, key) 实现归属判断预算福 in 
    def __contains__(self, key):
        if self._get(key, self.root):
            return True
        else:
            return False
    # __iter__ 实现for循环迭代  也是递归实现 
    def __iter__(self):
        &quot;&quot;&quot;The standard inorder traversal of a binary tree.&quot;&quot;&quot;
        if self:
            if self.hasLeftChild():
                for elem in self.leftChild:
                    yield elem
            yield self.key
            if self.hasRightChild():
                for elem in self.rightChild:
                    yield elem
</code></pre>
<p>二叉查找树插入实现 插入项和根节点比KEY大小，决定插入在左子树还是右子树 再跟下一级父节点比决定往下一级左右哪个子树走。<br>二叉查找树remove方法最为复杂，有很多种情况要分类讨论。最复杂的是被删除的节点有左子树 也有右子树，这个时候我们就要找到这个删除节点的后继来替换这个节点。这个后继的选择是被删除节点的右子树的最小的那个节点。很好理解，右子树就是比被删除节点大的节点们，那肯定hold住左子树，同时又是右子树的最小的节点，所以所有其他右节点也都任然保持原样。所以其实他的后继只有两种情况，因为是右子树的最小的节点，所以必然是叶节点或者是只有右子树的父节点。   </p>
<p>二叉查找树的性能决定因素在于二叉搜索树的高度 最大层次，而且高度又收到数据项key插入顺序的影响。<br>极端情况可以退化成单列表，理想情况就是平衡二叉树 logn   </p>
<h2 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h2><p>搜索时间复杂度为logn AVL这样的平衡树就是在二叉查找树的基础上防止退化。<br>AVL树的实现过程中，需要对每个节点跟踪 平衡因子balance factor 。平衡因子是根据节点左右子树的高度差来定义的。   </p>
<pre><code>balanceFactor = height(leftsubtree) - height(rightsubtree)
</code></pre>
<p>如果平衡因子大于0，我们就称为  左重，反之右重，平衡因子等于0称为平衡。<br>如果平衡因子的每个节点的平衡因子都是[-1,1]之间则称为平衡树。<br>当子树插入一个节点时，会影响其父节点的平衡因子，这种影响会一直向上传递到根节点，除非路径中有父节点的平衡因子从非0变成0，因为平衡因子非0变成0，一定是这个树变成了平衡二叉树，那么这个树的父节点的这个子树高度没有变化，那么它的平衡因子也不会受到影响。<br>AVL树立实现不平衡子树的平衡是旋转，视“左重”还是“右重”进行不同方向的旋转，同时更新相关父节点引用，更新旋转后被影响节点的平衡因子。    </p>
<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>如果右重就左旋，把这个父节点作为其右子节点的左子节点，其右子节点作为新的父节点。而原来的这个右子节点如果原来就有左子树，那么就把这个左子树挂在原来父节点的右边，做右子树。<br>如果左重就右旋，原父节点的左子节点作为新根节点，父节点挂到新根节点的右边，做右子树，并将新根节点的右子树挂到旧跟节点的左边，做左子树。<br>旋转解决不了所有平衡因子不符合平衡树的情况，单纯的左旋和右旋无法解决和实现的平衡。<br>实现方法是：在旋转之前 先检查新根节点的旋转因子<br>左旋之前：检查右子节点的因子，如果右子节点左重的话，先对他进行右旋转，再实施原来的右旋转。<br>AVL数的插入put的时间复杂度是log(n),需要插入新节点是叶节点，则更新所有其父节点的和祖先节点的代价最多是logn ，旋转最多两次，所以o（1）,总体logn。</p>
<p><img src="3.png"><br><img src="4.png"></p>
<h3 id="二叉搜索树BST的中序遍历就是升序排序的列表"><a href="#二叉搜索树BST的中序遍历就是升序排序的列表" class="headerlink" title="二叉搜索树BST的中序遍历就是升序排序的列表"></a>二叉搜索树BST的中序遍历就是升序排序的列表</h3><h2 id="海象表达式"><a href="#海象表达式" class="headerlink" title="海象表达式"></a>海象表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (n :&#x3D; len(a)) &gt; 10:</span><br><span class="line">    print(f&quot;List is too long (&#123;n&#125; elements, expected &lt;&#x3D; 10)&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="图Graph"><a href="#图Graph" class="headerlink" title="图Graph"></a>图Graph</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">class  Graph:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.vertices &#x3D; &#123;&#125;</span><br><span class="line">        self.numVertices &#x3D; 0</span><br><span class="line">        </span><br><span class="line">    def addVertex(self,key):</span><br><span class="line">        self.numVertices &#x3D; self.numVertices + 1</span><br><span class="line">        newVertex &#x3D; Vertex(key)</span><br><span class="line">        self.vertices[key] &#x3D; newVertex</span><br><span class="line">        return newVertex</span><br><span class="line">    </span><br><span class="line">    def getVertex(self,n):</span><br><span class="line">        if n in self.vertices:</span><br><span class="line">            return self.vertices[n]</span><br><span class="line">        else:</span><br><span class="line">            return None</span><br><span class="line"></span><br><span class="line">    def __contains__(self,n):</span><br><span class="line">        return n in self.vertices</span><br><span class="line">    </span><br><span class="line">    def addEdge(self,f,t,cost&#x3D;0):</span><br><span class="line">            if f not in self.vertices:</span><br><span class="line">                nv &#x3D; self.addVertex(f)</span><br><span class="line">            if t not in self.vertices:</span><br><span class="line">                nv &#x3D; self.addVertex(t)</span><br><span class="line">            self.vertices[f].addNeighbor(self.vertices[t],cost)</span><br><span class="line">    </span><br><span class="line">    def getVertices(self):</span><br><span class="line">        return list(self.vertices.keys())</span><br><span class="line">        </span><br><span class="line">    def __iter__(self):</span><br><span class="line">        return iter(self.vertices.values())</span><br><span class="line">                </span><br><span class="line">class Vertex:</span><br><span class="line">    def __init__(self,num):</span><br><span class="line">        self.id &#x3D; num</span><br><span class="line">        self.connectedTo &#x3D; &#123;&#125;</span><br><span class="line">        self.color &#x3D; &#39;white&#39;</span><br><span class="line">        self.dist &#x3D; sys.maxsize</span><br><span class="line">        self.pred &#x3D; None</span><br><span class="line">        self.disc &#x3D; 0</span><br><span class="line">        self.fin &#x3D; 0</span><br><span class="line"></span><br><span class="line">    # def __lt__(self,o):</span><br><span class="line">    #     return self.id &lt; o.id</span><br><span class="line">    </span><br><span class="line">    def addNeighbor(self,nbr,weight&#x3D;0):</span><br><span class="line">        self.connectedTo[nbr] &#x3D; weight</span><br><span class="line">        </span><br><span class="line">    def setColor(self,color):</span><br><span class="line">        self.color &#x3D; color</span><br><span class="line">        </span><br><span class="line">    def setDistance(self,d):</span><br><span class="line">        self.dist &#x3D; d</span><br><span class="line"></span><br><span class="line">    def setPred(self,p):</span><br><span class="line">        self.pred &#x3D; p</span><br><span class="line"></span><br><span class="line">    def setDiscovery(self,dtime):</span><br><span class="line">        self.disc &#x3D; dtime</span><br><span class="line">        </span><br><span class="line">    def setFinish(self,ftime):</span><br><span class="line">        self.fin &#x3D; ftime</span><br><span class="line">        </span><br><span class="line">    def getFinish(self):</span><br><span class="line">        return self.fin</span><br><span class="line">        </span><br><span class="line">    def getDiscovery(self):</span><br><span class="line">        return self.disc</span><br><span class="line">        </span><br><span class="line">    def getPred(self):</span><br><span class="line">        return self.pred</span><br><span class="line">        </span><br><span class="line">    def getDistance(self):</span><br><span class="line">        return self.dist</span><br><span class="line">        </span><br><span class="line">    def getColor(self):</span><br><span class="line">        return self.color</span><br><span class="line">    </span><br><span class="line">    def getConnections(self):</span><br><span class="line">        return self.connectedTo.keys()</span><br><span class="line">        </span><br><span class="line">    def getWeight(self,nbr):</span><br><span class="line">        return self.connectedTo[nbr]</span><br><span class="line">                </span><br><span class="line">    def __str__(self):</span><br><span class="line">        return str(self.id) + &quot;:color &quot; + self.color + &quot;:disc &quot; + str(self.disc) + &quot;:fin &quot; + str(self.fin) + &quot;:dist &quot; + str(self.dist) + &quot;:pred \n\t[&quot; + str(self.pred)+ &quot;]\n&quot;</span><br><span class="line">    </span><br><span class="line">    def getId(self):</span><br><span class="line">        return self.id</span><br><span class="line"></span><br><span class="line">class adjGraphTests(unittest.TestCase):</span><br><span class="line">    def setUp(self):</span><br><span class="line">        self.tGraph &#x3D; Graph()</span><br><span class="line">        </span><br><span class="line">    def testMakeGraph(self):</span><br><span class="line">        gFile &#x3D; open(&quot;test.dat&quot;)</span><br><span class="line">        for line in gFile:</span><br><span class="line">            fVertex, tVertex &#x3D; line.split(&#39;|&#39;)</span><br><span class="line">            fVertex &#x3D; int(fVertex)</span><br><span class="line">            tVertex &#x3D; int(tVertex)</span><br><span class="line">            self.tGraph.addEdge(fVertex,tVertex)</span><br><span class="line">        for i in self.tGraph:</span><br><span class="line">            adj &#x3D; i.getAdj()</span><br><span class="line">            for k in adj:</span><br><span class="line">                print(i, k)</span><br></pre></td></tr></table></figure>

<h2 id="广度优先搜索BFS、深度优先搜索DFS"><a href="#广度优先搜索BFS、深度优先搜索DFS" class="headerlink" title="广度优先搜索BFS、深度优先搜索DFS"></a>广度优先搜索BFS、深度优先搜索DFS</h2><p>Breadth-First-Search,Depth-First-Search  就是图的一种遍历方法，树有4种遍历方法 前序pre中序in后序post还有层次遍历。图只有两种，因为图没有根节点之说，而且各个节点间连接更多和复杂。<br>广度优先搜索如果是树结构就是树的层次遍历，深度优先搜索就是树的前序遍历。<br>广度利用一个队列和一个数组，数组记录各个节点是否被访问过，辅助队列弹出一个节点，压入下一层节点，直至队列弹出完毕。<br>深度利用一个栈和一个数组，数组记录各个节点是否被访问，访问一个节点就压入栈中，不断访问最后一个压入节点的下一层节点，直至该顶点所有关联顶点都被访问过，无法继续访问则弹出。<br>广度优先搜索和深度优先搜索得到的遍历顺序和图选择的存取结构有关系，如果是邻接矩阵则遍历顺序是一定的，如果是邻接链表，则遍历的顺序是不一定的。<br>无向图如果是邻接表形势，则空间复杂度是o(|v| + 2|E|) 有向图o(|v| + |E|) 。而邻接矩阵固定o(|v|^2)适合存储稠密图。求无向图和有向图的邻接链表的时间复杂度是O(1), 求有向图的入读是o(E).而领接矩阵的时间复杂度为O(|V|)<br>如果是多联通分量的广度深度优先遍历，就用一个循环去检查是否有顶点没有被访问，然后在对这个顶点入队 入栈进行遍历。<br>同样如果是邻接矩阵，则生成树的的结果是唯一的，如果是邻接表则生成树是不唯一的。<br>对于有向图，如果是强连通图，则调用一次dfs或者bfs就能够实现遍历，但是如果是非强连通图，可能会需要几次的bfs和dfs </p>
<h2 id="图的问题解决思路"><a href="#图的问题解决思路" class="headerlink" title="图的问题解决思路"></a>图的问题解决思路</h2><p>先把所有顶点的关联顶点，全部建立边的关系。 然后选择dfs或者bfs。两个经典案例骑士周游问题dfs和词梯问题bfs。</p>
<h2 id="启发式规则heuristic"><a href="#启发式规则heuristic" class="headerlink" title="启发式规则heuristic"></a>启发式规则heuristic</h2><p>启发式规则是用先验的只是来改进算法性能的做法，称为启发式规则heuristic，常用于人工智能领域。可以有效的减小搜索范围，更快达到目标等等。</p>
<h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p>解决带权最短路径问题的经典算法，这是一个迭代算法，得出一个顶点到其余所有顶点的最短路径。具体实现是在顶点vertex类中的成员dist用于记录从开始顶点到本顶顶啊的代全路径长度，权重之和，算法对图的每个顶点迭代一次。<br>出队的顶点相关联的点一次遍历看看比不比之前的值小，如果小就更新。需要注意的是Dijkstra算法只能处理大于0的权重的问题，如果图中出现负数权重，则算法会陷入无限循环。虽然Dijkstra算法完美解决了带权图的最短路径问题，但是实际上Internet的路由器其实是采用其他的算法。其中的原因是Dijkstra算法需要具备整个图的数据，而对于Internet路由器来说他是无法做到将所有的Internet路由器的信息和连接的信息保存在本地，这不只是数据量的问题，internet的动态变化特性也会将保存全图缺乏现实性。路由器的选径算法，对互联网来说极其重要。“距离向量路由算法”。  </p>
<h2 id="最小生成树prim算法"><a href="#最小生成树prim算法" class="headerlink" title="最小生成树prim算法"></a>最小生成树prim算法</h2><p>算法主要是在互联网中网游设计者和网络收音机所面临的问题，信息广播问题。解决最小生成树的问题prim算法，属于贪心算法。就是每一步都沿着最小权重的边向前搜索。构造最小生成树的思路很简单，如果T还不是生成树，则反复做。找到一条最小权重的，可以安全添加的边，将边添加到树T。（可以安全添加：就是定义为一段顶点在树中，另一端不在树中的边，以保持树的无圈特性。）</p>
<h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><h2 id="最小子串-最小覆盖子串"><a href="#最小子串-最小覆盖子串" class="headerlink" title="最小子串 最小覆盖子串"></a>最小子串 最小覆盖子串</h2><p>涉及到字符串的问题，如果是极值问题，最小或者最大什么的，先别考虑最的问题，先考虑怎么找到符合条件的串，然后在思考怎么通过一个串去找别的串来简便查找流程。<br>递归、动态规划（设立起始、终止坐标的二维动态规划，注意每一层的遍历顺序）、双指针是常用的字符串问题处理的方式。   </p>
<h2 id="回文串问题"><a href="#回文串问题" class="headerlink" title="回文串问题"></a>回文串问题</h2><p>因为回文串的特性，轴对称，所以有两个特性，一个是最多只有一个元素是奇数，其他元素出现次数都是偶数；其次就是轴对称特性可以剪枝，所以可以通过中心扩散的方式模拟寻找子串。<br>中心扩散：每次假设中心是哪个元素或者哪两个，然后向外扩散判断是否符合回文条件。要考虑中心是一个字符还是两个字符，当然也可用两边遍历来完成。本质是动态规划~~~<br>中心扩散的方式是o(n**2)，涉及回文串问题有个Manacher 算法，可以降到o（n）。Manacher 算法是在线性时间内求解最长回文子串的算法</p>
<h2 id="链表问题"><a href="#链表问题" class="headerlink" title="链表问题"></a>链表问题</h2><p>设计到链表问题，设置哑结点dummynode。<br>设计到链表问题可以考虑几种方法：</p>
<ul>
<li>快慢指针（无论是找中点还是找倒数第N个节点还是什么）</li>
<li>哈希表+双链表 用Key存储val为Node的哈希表来实现遍历o(1)</li>
</ul>
<h2 id="树-1"><a href="#树-1" class="headerlink" title="树"></a>树</h2><p>树的问题 百分之八十都可以用递归来解决。   </p>
<h2 id="全排列的问题"><a href="#全排列的问题" class="headerlink" title="全排列的问题"></a>全排列的问题</h2><p>就是建树的问题  递归和回朔都可以实现  相同的元素则剪枝<br>回朔算法可以实现inplace 消除了递归的一些切片和列表相加的开销 更优化<br>求解所有可能通常回朔可以实现，记住trackback的输入选择坐标输入，这样当到末尾时弹出 输出函数外</p>
<pre><code>res = []
path = []

def backtrack(未探索区域, res, path):
if 未探索区域满足结束条件:
    res.add(path) # 深度拷贝
    return
for 选择 in 未探索区域当前可能的选择:
    if 当前选择符合要求:
        path.add(当前选择)
        backtrack(新的未探索区域, res, path)
        path.pop()
</code></pre>
<h2 id="递归问题"><a href="#递归问题" class="headerlink" title="递归问题"></a>递归问题</h2><p>递归先写递归终止条件<br>在想调用自身递归削减问题规模<br>在想返回啥  </p>
<h2 id="遍历："><a href="#遍历：" class="headerlink" title="遍历："></a>遍历：</h2><p>后序遍历如果要写迭代法 可以用stack 然后root left right的顺序遍历，入栈，最后得到path翻转一下就是。或者用个visited实现，检查是否遍历过了。也是深度遍历，回退。<br><strong>如果不用visited的set可以用isinstance判断该节点是不是treenode，因为我们压入栈的时候，如果对于根节点我们只压入val，这样none和val可以实现直接输出到path</strong><br>正常做法：先用指针找到每颗子树的最左下角，然后进行进出栈操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def inorderTraversal(self, root: TreeNode) -&gt; List[int]: </span><br><span class="line">        res &#x3D; []</span><br><span class="line">        stack &#x3D; []</span><br><span class="line">        cur &#x3D; root</span><br><span class="line">        # 中序，模板：先用指针找到每颗子树的最左下角，然后进行进出栈操作</span><br><span class="line">        while stack or cur:</span><br><span class="line">            while cur:</span><br><span class="line">                stack.append(cur)</span><br><span class="line">                cur &#x3D; cur.left</span><br><span class="line">            cur &#x3D; stack.pop()</span><br><span class="line">            res.append(cur.val)</span><br><span class="line">            cur &#x3D; cur.right</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 标记法</span><br><span class="line">class Solution:</span><br><span class="line">    def inorderTraversal(self, root: TreeNode) -&gt; List[int]:</span><br><span class="line">        if not root:</span><br><span class="line">            return list()</span><br><span class="line">        path &#x3D; []</span><br><span class="line">        stack &#x3D; [root]</span><br><span class="line">        while stack:</span><br><span class="line">            tmp &#x3D; stack.pop()</span><br><span class="line">            if isinstance(tmp, TreeNode):</span><br><span class="line">                stack.extend([tmp.right, tmp.val, tmp.left])</span><br><span class="line">            else:</span><br><span class="line">                if tmp:</span><br><span class="line">                    path.append(tmp)</span><br><span class="line">        return path</span><br></pre></td></tr></table></figure>


<h2 id="数组删除元素"><a href="#数组删除元素" class="headerlink" title="数组删除元素"></a>数组删除元素</h2><p>遇到数组中要删除多个元素，可以考虑双指针，一个指针指向需要插入的位置 另一个指针向后遍历，，，如果有些特性也可以直接丢到最后去</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://andrekuu.github.io/2021/04/22/%E7%AE%97%E6%B3%95%E7%BB%8F%E9%AA%8C/" data-id="cknscjo0s0006egveeilmclwh" data-title="算法经验" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Django框架细节纪实" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/22/Django%E6%A1%86%E6%9E%B6%E7%BB%86%E8%8A%82%E7%BA%AA%E5%AE%9E/" class="article-date">
  <time class="dt-published" datetime="2021-04-21T19:32:04.000Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/22/Django%E6%A1%86%E6%9E%B6%E7%BB%86%E8%8A%82%E7%BA%AA%E5%AE%9E/">Django框架细节纪实</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>C:\Users\user\Desktop\前端\venv\Scripts<br>非常优秀的第三方库  </p>
<p>可以让网站开发非常快，而且代码非常简洁   </p>
<p>Django是个Web框架 是一个产品级的框架 MTV模型框架 model template view  </p>
<p>框架就是半成品   </p>
<p>云端系统有三个业务需求，数据组织 web展示 控制逻辑 </p>
<p>用户可以通过浏览器来访问web后台，python支持WSGI的web服务器接口，这是个python语言对外部浏览器的接口，用户对云端的请求，经过WSGI转为URLS进入到web框架中。<br><img src="1.png"></p>
<p>定制路由、定制HTML/CSS/JS的展示文件 /设计我们的数据库格式，并将他们关联   </p>
<h2 id="全流程"><a href="#全流程" class="headerlink" title="全流程"></a>全流程</h2><ol>
<li><p>创建一个web框架工程<br>命令行</p>
<p> django-admin startproject mysite</p>
</li>
<li><p>修改工程创建一个具体应用的app python manage.py startapp xxxxxapp</p>
</li>
<li><p>修改工程 修改应用的views.py 对URL的具体响应功能   </p>
</li>
<li><p>修改工程修改URL路由 指定URL与响应之间的关系  </p>
</li>
<li><p>python manage.py runserver </p>
</li>
</ol>
<p>django-admin是对django框架全局管理的工具   修改和配置整个框架配置的工具  几十个子命令，包括建立并管理django工程，建立并管理django工程使用的数据库  控制调试或日志信息，运行并维护Django工程</p>
<pre><code>django-admin &lt;command&gt; [options]
</code></pre>
<p>在开发环境中下载好PyMySQL 安装完成后，在项目同名包下的__init__.py里面添加 </p>
<pre><code>import pymysql
pymysql.install_as_MySQLdb()
</code></pre>
<p>在settings.py里吧DATABASES里的内容换掉</p>
<pre><code>DATABASES = &#123;
    &#39;default&#39;: &#123;
        &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,   # 数据库引擎 这是django里自带的一个包
        &#39;NAME&#39;: &#39;&#39;,     # 所使用的的数据库名字
        &#39;USER&#39;: &#39;root&#39;,     # 数据库服务器的用户
        &#39;PASSWORD&#39;: &#39;&#39;,     # 密码
        &#39;HOST&#39;: &#39;127.0.0.1&#39;,    # 主机
        &#39;PORT&#39;: &#39;3306&#39;,     # 端口
    &#125;
&#125;
</code></pre>
<ol start="6">
<li><p>在mysql里创建一个数据库用来装我们要塞进去的东西  </p>
</li>
<li><p>输入迁移指令  </p>
<p> python manage.py migrate<br>这个是吧原来django自带的一些表在mysql里创建   可以通过刚才的创建的数据库查看这些表  </p>
</li>
<li><p>Django里创建一个超级管理员   </p>
<p> python manage.py createsuperuser</p>
</li>
<li><p>进入服务器。/admin/ 输入刚才创建的用户名和密码  就进入了一个django的后台</p>
</li>
<li><p>创建一个应用</p>
<p>python manage.py startapp appname</p>
</li>
<li><p>配置路由  在主路由下面添加到这个app的路由 include实现</p>
<p>path(‘polls/‘, include(‘polls.urls’))</p>
</li>
</ol>
<p>同时添加子路由：在app文件夹下创建urls.py，然后对应views创建函数<br>12. 在app下建立模板文件夹  templates 存放htmls等页面文件  并在主文件里的settings修改</p>
<pre><code>&#39;DIRS&#39;: [os.path.join(BASE_DIR, &#39;templates&#39;)],
</code></pre>
<ol start="13">
<li>在templates里创建一个html文件 完成页面设计  </li>
<li>在setting里的installed_apps 添加app名字</li>
<li> 用户名和密码一般不会用GET英文这样会暴露在浏览器地址栏里，改成post请求 </li>
<li> 如果用到post 得在html里加上</li>
</ol>
<pre><code>&#123;% csrf_token %&#125;
</code></pre>
<p>这样才能通过安全保证，因为django自带有个csrf中间件来确保安全性  </p>
<ol start="17">
<li>接数据库做一个登陆操作:</li>
</ol>
<ul>
<li><p>在model.py中添加数据模型  在django里是一个模型，在数据库里就是一张表  </p>
<p>  class StudentInfo(models.Model):</p>
<h1 id="创建表的字段"><a href="#创建表的字段" class="headerlink" title="创建表的字段"></a>创建表的字段</h1><p>  stu_id = models.CharField(primary_key=True,max_length=20)<br>  stu_name = models.CharField(max_length=20)<br>  stu_psw = models.CharField(max_length=20)</p>
</li>
<li><p>将数据模型迁移到数据库 </p>
<p>  python manage.py makemigrations stu  (stu是应用名)</p>
</li>
<li><p>创建完成后就会在migrations里创建一个0001_initial.py 然后运行迁移</p>
<p>  python manage.py migrate<br>数据库里就会出现这张表  </p>
</li>
<li><p>在这张表里插入一条数据 或几条作为测试  </p>
</li>
<li><p>在views里先把models文件import进来 然后重定义这里的u p 判断语句 这里使用filter函数来实现</p>
<p>  def Login_view(request):</p>
<pre><code>  u = request.POST.get(&quot;user&quot;, &#39;&#39;)
  p = request.POST.get(&quot;pwd&quot;, &#39;&#39;)

  if u and p:
      c = StudentInfo.objects.filter(stu_name=u, stu_psw=p).count()  # 这里通过filter函数去数据库里找匹配情况
      if c &gt;= 1:
          return HttpResponse(&quot;登陆成功！&quot;)
      else:
          return HttpResponse(&quot;账号密码错误！&quot;)
  return HttpResponse(&quot;登录失败！请输入正确的账号密码！&quot;)
</code></pre>
</li>
</ul>
<p>将数据库里的数据映射回django 项目 需要执行指令 ：</p>
<pre><code>python manage.py inspectdb&gt;lo/models.py     // lo是项目的名称 app名
</code></pre>
<h2 id="注册功能"><a href="#注册功能" class="headerlink" title="注册功能"></a>注册功能</h2><ol>
<li>templates模板里添加一个html页面  </li>
<li></li>
</ol>
<p>manage 也是个管理工具，但是只针对我们生成的这个工程   </p>
<h2 id="退出服务器连接是CTRL-break或者ctrl-c"><a href="#退出服务器连接是CTRL-break或者ctrl-c" class="headerlink" title="退出服务器连接是CTRL+break或者ctrl+c"></a>退出服务器连接是CTRL+break或者ctrl+c</h2><h2 id="工程和app"><a href="#工程和app" class="headerlink" title="工程和app"></a>工程和app</h2><p>工程对于一个网站是配置和应用的集合，引用对应于特定功能，是具体功能的载体，配置和功能分离是高度模块化的提现 </p>
<h2 id="修改引用的views-py"><a href="#修改引用的views-py" class="headerlink" title="修改引用的views.py"></a>修改引用的views.py</h2><p>views.py中包含对某个HTTP请求url的响应  </p>
<h2 id="修改URL路由"><a href="#修改URL路由" class="headerlink" title="修改URL路由"></a>修改URL路由</h2><p>在urls.py中指定URL与处理函数之间的路径关系<br>path是讲某个处理函数和某个URL进行关联 路由就是 URL与处理函数的关联的</p>
<p><strong>init</strong>_.py 意味着这是一个第三方包也是一个库，如果要生成一个库，就必须得有这个文件   </p>
<p>settings.py部署和整个工程的配置文件   </p>
<p>urls.py url路由器的声明文件(路由文件)</p>
<p>wsgi.pu WSGI的web服务器的配置文件  </p>
<p>manage.py 是一个与Django工程交互的命令工具  </p>
<h2 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h2><p>MVC 设计模式是 Web 设计模式的经典之作，MTV 模式也是在它的基础上衍生而来。</p>
<p>MVC 是 Model-View-Controller 的缩写，其中每个单词都有其不同的含义：<br>Modle 代表数据存储层，是对数据表的定义和数据的增删改查；<br>View 代表视图层，是系统前端显示部分，它负责显示什么和如何进行显示；<br>Controller 代表控制层，负责根据从 View 层输入的指令来检索 Model 层的数据，并在该层编写代码产生结果并输出。<br><img src="2.png"><br>MVC 设计模式的请求与响应过程描述如下：<br>用户通过浏览器向服务器发起 request 请求，Controller 层接受请求后，同时向 Model 层和 View 发送指令；<br>Model 层根据指令与数据库交互并选择相应业务数据，然后将数据发送给 Controller 层；<br>View 层接收到 Controller 的指令后，加载用户请求的页面，并将此页面发送给 Controller 层；<br>Controller 层接收到 Model 层和 View 层的数据后，将它们组织成响应格式发送给浏览器，浏览器通过解析后把页面展示出来。</p>
<p>MVC 的 3 层之间紧密相连，但又相互独立，每一层的修改都不会影响其它层，每一层都提供了各自独立的接口供其它层调用，MVC 的设计模式降低了代码之间的耦合性（即关联性），增加了模块的可重用性，这就是 MVC 的设计模式。    </p>
<h2 id="MTV模式"><a href="#MTV模式" class="headerlink" title="MTV模式"></a>MTV模式</h2><p>Django 借鉴了经典的 MVC 模式，它也将交互的过程分为了 3 个层次，也就是 MTV 设计模式；<br>Model：数据存储层，处理所有数据相关的业务，和数据库进行交互，并提供数据的增删改查；<br>Template：模板层（也叫表现层）具体来处理页面的显示；<br>View：业务逻辑层，处理具体的业务逻辑，它的作用是连通Model 层和 Template 。  </p>
<p>MTV 设计模式中，用 View 层取代了 Controller 层的位置，用 Template 层取代了原来 View 层的位置。</p>
<p>初次接触 Django 的设计模式的人，可能会对 Template 层产生疑问，其实 Template 英文的含义就是“模板”的意思，你可以简单理解成，它是一个 HTML 页面 ，HTML 页面的渲染在视图层完成。</p>
<p>用户通过浏览器对服务器发起 request 请求，服务器接收请求后，通过 View 的业务逻辑层进行分析，同时向 Model 层和 Template 层发送指令；<br>Model 层与数据库进行交互，将数据返回给 View 层；<br>Template 层接收到指令后，调用相应的模板，并返回给 View 层；<br>View 层接收到模板与数据后，首先对模板进行渲染（即将相应的数据赋值给模板），然后组织成响应格式返回给浏览器，浏览器进行解析后并最终呈现给用户。   </p>
<p>通过以上两种设计模式的比较， 我们可以得出 MTV 是 MVC 的一种细化，将原来 MVC 中的 V 层拿出来进行分离，视图的显示与如何显示交给 Template 层，而 View 层更专注于实现业务逻辑。其实在 Django 是有 Controller 层的，只不过它由框架本身来实现，所以我们不用关心它。Django 更关注于M、T 和 V。 </p>
<h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p>ORM （Object Realtional Mapping）即对象关系映射，它是一种基于关系型数据库的程序技术。ORM 允许你使用类和对象对数据库进行操作，这大大提高了对数据库的控制，避免了直接使用 SQL 语句对数据库进行操作。 这种程序技术的底层主要是通过映射机制实现的   </p>
<p>Web 开发中对数据库的操作是必不可少的，然而每种数据库的操作方式以及用法不尽相同。由于 Django 中 ORM 的存在，为我们操作不同种类的数据库提供了统一的方法，ORM 适配了多种常用的关系型数据库，例如 PostgreSQL、MySQL、Oracle、Sqlite3 等。   </p>
<p>Django 把表模型定义为 Model，他需要继承自django.db.models中的 Model 类，只要是与数据表相关的操作，都需要继承这个类。同时ORM 对于数据库的的增删改查，也提供了一些简单的 API，例如 F 查询、Q 查询。  </p>
<p>ORM 模块确实有诸多的优势，比如：<br>使用该模块只需要面向对象编程，不需要面向数据库编写代码，对数据库的操作转换为对类属性和方法的操作，不用我们编写各种数据库的 SQL 语句。<br>实现数据模型与数据库的解耦，屏蔽了不同数据库操作上的差异化，不在关注不同数据库内部的操作细节，通过简单更改配置就可以实现数据库的更换而无需更改代码。</p>
<p>与此同时 ORM 也存在一点不足之处：<br>相比直接用 SQL 语句操作数据库会有性能损失，因为在映射的过程中 ORM 需要与 SQL 之间进行转换，根据对象的操作转换成 SQL 语句，根据查询结果转换成对象，所以在映射的过程存在性能损失。</p>
<h2 id="创建一个页面"><a href="#创建一个页面" class="headerlink" title="创建一个页面"></a>创建一个页面</h2><p>建立摸板（T）对应特定请求 返回模板页面    </p>
<p>render 打包函数 第一个参数是request默认要求，第二个参数是反馈的页面的名字<br>在app文件里创建本地路由：新建一个urls.py    urlpatterns是个固定的变量名 表达路由信息<br>有了局部路由 则需要将工程全局路由增加对这个app本地路由的引用   include函数用来引入其他路由文件的    </p>
<p>设置摸板路径  settings文件 让django框架找到摸板所在目录  在TEMPLATES下的DIRS里这里是摸板存放的位置  </p>
<p>[os.path.join(BASE_DIR, ‘hello2app/templates’)]  这个是合并路径，在主路径下加入找templates的路径    </p>
<h2 id="Django的输入输出"><a href="#Django的输入输出" class="headerlink" title="Django的输入输出"></a>Django的输入输出</h2><p>Django的输入是用户请求的http协议  包括url 和对 url的动作<br>输出就是每次views对响应的输出</p>
<h2 id="URL路由配置"><a href="#URL路由配置" class="headerlink" title="URL路由配置"></a>URL路由配置</h2><p>settings.py文件里ROOT_URLCONF变量指定全局路由文件名称<br>这个通常指向&lt;工程名称&gt;.urls 这个路由文件，是默认对应工程目录下的urls.py文件，这个是这个项目的路由入口文件<br>Django使用urlpatterns变量表示路由（urls.py）该变量是列表类型  由path（）或re_path()作为元素组成  表示路由中的每个路由的定义关系 。其中path处理字符串类型的路由， re_path处理正则表达式路由  </p>
<pre><code>path(route, view, kwargs=None,name=None)   
</code></pre>
<p>Django有三种方式表达路径route ：</p>
<ol>
<li>精确字符串  article/2003/ </li>
<li>Django的转换格式   &lt;类型：变量名&gt; article/<a href="int:year">int:year</a>/</li>
<li>正则表达式的格式: article/(?P<year>[0-9]{4})  我们用正则表达式来表达一类的URLs</li>
</ol>
<p>精确字符串类型：  一个精确的URL匹配一个操作函数  最简单的形势，适合对静态URL的响应，URL字符串不以/开头，但要以 /结尾   </p>
<p>转换格式类型： 一个URL摸板，匹配URL同时在其中获得一批变量作为参数<br>目的是通过URL进行参数获取和传递  采用</p>
<pre><code>&lt;类型：变量名&gt; 格式获取参数  
</code></pre>
<p>五种Django的转换格式类型：</p>
<ol>
<li>s</li>
<li> 匹配除了分隔符以外/外  的非空字符串， 默认类型<year> 等价于<a href="str:year">str:year</a></li>
<li>int 匹配0和正整数 </li>
<li>slug 匹配字母、数字、横杠、下划线组成的字符串 是str的子集 </li>
<li>uuid 匹配格式化的uuid 如 075194d3-6840-417e-a8a8-6c93102e272f00   </li>
<li>path匹配任何非空字符串 包括路径分隔符 是全集</li>
</ol>
<p>Django查找全局urlpatterns变量(urls.py) 按照先后书序 对URL逐一匹配 urlpatterns的元素  当找到第一个匹配时，就停止查找 把其中的处理函数匹配出来，并执行，如果没有找到匹配或者出现异常，Django则负责错误处理<br>Django的路由不考虑HTTP请求方式，仅根据URL进行路由，只要URL相同，无论POST、GET等那种请求方式都指向同一个操作函数    </p>
<p>re_path()两种具体形式：简单形式pattern 不提取参数： article/（[0-9]{4}）<br>命名形式 (?P<name>pattern)提取参数 统一为str类型  articles/（？P<year>[0-9]{4}） python只能提取字符串类型   </p>
<p>空路径对应的就是根目录的处理函数  re_path里的正则表达式’^$’ 也表示空</p>
<h2 id="view的使用"><a href="#view的使用" class="headerlink" title="view的使用"></a>view的使用</h2><p>两种类型  一种就是处理函数 一种是include()函数<br>处理函数就是指定处理url的函数 URL处理的最终归宿<br>include()函数  包含其他路由信息的函数 分段路径组合形成总路径<br>include 可以实现路径去重  就是把相同部分的代码给提取出来，然后include指向更细化的路由，可以方便以后的业务整合和降低代码出错概率    </p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图函数接受HTTP请求 并返回响应，可以放在任何地方，可以是任何功能<br>视图函数可以返回web文本、页面、重定向、错误、图片等任何内容   </p>
<p>视图函数通过HttpResponse 、 JsonResponse等类表达 并返回响应   </p>
<p>按约定  视图函数放在对应app中的views.py文件里  </p>
<p>Django相应类型：</p>
<ol>
<li>HttpResponse类 以及其子类（共十个）主要反馈类型 父类  HTTP状态码默认为200</li>
<li>JsonResponse类  </li>
<li>StreamingHttpResponse类</li>
<li>FileResponce类</li>
</ol>
<p>HttpResponse(content, content_type=None,status=200, charset=None)  返回字符串<br>content_type MIME格式的返回内容类型<br>status  响应状态码<br>charset 响应字符  </p>
<p>JsonResponse类<br>返回Json格式的数据 返回一个data 是字典类型的数据，返回JSON类型数据     </p>
<p>云端和手机端很多都是采用的JSON的格式  尤其是交换的数据量比较小，尤其是交换一些信息量比较小，且具有一定参数属性的信息   </p>
<p>StreamingHttpResponse类<br>内容以迭代器形势一内容流的方式响应    </p>
<p>FileResponce类<br>反馈一个文件   stream以流形式打开的文件</p>
<p>Django请求类型的判断：<br>django.views.decorators.http<br>路由不能判断HTTP请求的类型，Django通过decorators在视图函数前进行基本判断，格式如下：</p>
<pre><code>from django.views.decorators.http import require_http_methods

@require_http_methods([&quot;GET&quot;,&quot;POST&quot;])
def my_view(request):
    
</code></pre>
<h2 id="Django的相应类型"><a href="#Django的相应类型" class="headerlink" title="Django的相应类型"></a>Django的相应类型</h2><p>HttpResponse类和子类  和JsonResponse类是一次性响应<br>StreamingHttpResponse类和FileResponse类是流式响应类型   适合大文本文件传输和大二进制文件传输    </p>
<p>文件较大则如果用一次性响应来实现则用户响应时间过长，用户体验差    </p>
<p>以文件下载为例，将文件分段，每次传输一部分，分段大小可调整   </p>
<p>python实现上是通过迭代器来产生分段，可以是文件，也可以是任何大规模的数据响应   </p>
<pre><code>from django.http import StreamingHttpResponse
def big_file_download(request):
    def file_iterator(file_name, chunk_size=512):
        with open(file_name) as f:
            while True:
                c = f.read(chunk_size)
                if c:
                    yield c
                else:
                    break
    
    fname = &quot;data.txt&quot;
    response = StreamingHttpResponse(file_iterator(fname))
    return response
</code></pre>
<p>FileResponce类是StreamingHttpResonse下的子类，能够很好地应用于文件的分段处理和下载 自动的将一个文章分段，自动实现一个迭代器 ，并且进行自动的文件传输   </p>
<pre><code>response[&#39;Content-Type&#39;] = &#39;application/octet-stream&#39;
response[&#39;Content-Disposition&#39;] = &#39;attatchment;filenae=&quot;pylogo.png&quot;&#39;
</code></pre>
<p>Content-Type用于指定文件的类型   Content-Disposition 用于指定下载文件的默认名称<br>MIME类型的标准定义  这是反馈给用户时候需要标记的  里面有这两个信息 则在用户端会体现为文件下载的格式</p>
<pre><code>def homeproc(request):
    cwd = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    response = FileResponse(open(cwd + &quot;/1.png&quot;, &quot;rb&quot;))
    response[&#39;Content-Type&#39;] = &#39;application/octet-stream&#39;
    response[&#39;Content-Disposition&#39;] = &#39;attachment;filename=&quot;pylogo.png&quot;&#39;
    return response   
</code></pre>
<h2 id="模板引擎-模板使用"><a href="#模板引擎-模板使用" class="headerlink" title="模板引擎 模板使用"></a>模板引擎 模板使用</h2><p>模板引擎是模板响应的后端，模板就是HTML5 CSS  JS的一些文件，模板引擎就是将这些表示层的文件和数据相整合的过程    </p>
<p>Django支撑两种引擎，一种是django引擎 一种是Jinja2引擎   </p>
<p>settings里的 templates里的backend  引擎配置  DIRS是目录  </p>
<pre><code>TEMPLATES = [
    &#123;
        &#39;BACKEND&#39;: &#39;django.template.backends.django.DjangoTemplates&#39;,
         &#39;DIRS&#39;: [os.path.join(BASE_DIR, &quot;msgapp/templates&quot;)],
</code></pre>
<p>摸板查找<br>get_template(template_name) -&gt; Template类   </p>
<p>template_name ：带查找模板的名称  在模板目录列表中，依次查找某个模板 直到找到并返回Template类<br>如果未找到模板，则抛出TemplateDoesNotExist异常  </p>
<p>select_template(template_name_list) -&gt; Template类<br>template_name_list 待查找模板的名称列表， 找到其中一个就返回然后结束   </p>
<p>template类用render渲染 然后生成HTML相关的字符串   </p>
<pre><code>Template.render(context, request)-&gt;HTML字符串
</code></pre>
<p>context：字典类型 用于加载到模板中的内容<br>request：HTTP请求   </p>
<p>渲染的过程就是将template类和contex用render来加工生成HTML的过程  </p>
<h2 id="模板语言"><a href="#模板语言" class="headerlink" title="模板语言"></a>模板语言</h2><p>指导模板加载数据方式的工具<br>DTL：Django Template Language </p>
<p>注释 comment<br>单行注释大括号加#号  </p>
<pre><code>    &#123;# 这是单行注释 #&#125;
</code></pre>
<p>多行注释： </p>
<pre><code>  &#123; %comment% &#125;
    这是多行注释第一行
  &#123; %endcomment% &#125;
</code></pre>
<p>变量 variable   一对大括号表示变量  如果变量本身是字典类型、列表类型或者对象，用.获取元素   </p>
<pre><code>&#123; &#123;name&#125; &#125;
&#123; &#123;adict.key&#125; &#125;
&#123; &#123;alist.0&#125; &#125; //列表这里用.来取值   
</code></pre>
<p>标签 tags   表达了一定的程序逻辑  采用一对大括号百分号来表示  { % 关键字引导的程序逻辑 % } 标签中的关键字包括 for，endfor, block, if等等循环判断</p>
<p>过滤器 filter<br>对变量值的修饰 增加竖线来过滤标签 ,过滤器对变量的值进行修饰</p>
<pre><code> &#123; % name|过滤标签 % &#125; &#123; % name|f1|f1 % &#125;
</code></pre>
<p>lower，可以小写变量里的所有字母，date可以修改date型的表达格式   </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://andrekuu.github.io/2021/04/22/Django%E6%A1%86%E6%9E%B6%E7%BB%86%E8%8A%82%E7%BA%AA%E5%AE%9E/" data-id="cknscjo0l0001egveelvt8ebl" data-title="Django框架细节纪实" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Python语言底层细节" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/22/Python%E8%AF%AD%E8%A8%80%E5%BA%95%E5%B1%82%E7%BB%86%E8%8A%82/" class="article-date">
  <time class="dt-published" datetime="2021-04-21T19:30:58.000Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/22/Python%E8%AF%AD%E8%A8%80%E5%BA%95%E5%B1%82%E7%BB%86%E8%8A%82/">Python语言底层细节</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="python的深层copy和浅层copy"><a href="#python的深层copy和浅层copy" class="headerlink" title="python的深层copy和浅层copy"></a>python的深层copy和浅层copy</h2><p>浅拷贝：在复制过程中，只复制一层变量。不会复制深层变量绑定的对象。（对象地址不变，引用的是同一个列表对象）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line">a &#x3D; 1  # 不可变数据类型</span><br><span class="line">copy_a &#x3D; copy.copy(a)</span><br><span class="line">print(id(a),id(copy_a))  # 内存地址相同</span><br><span class="line"> </span><br><span class="line">a &#x3D; [1,2]  # 可变数据类型</span><br><span class="line">copy_a &#x3D; copy.copy(a)</span><br><span class="line">print(id(a),id(copy_a))  # 内存地址不相同</span><br><span class="line"></span><br><span class="line">import copy</span><br><span class="line">a &#x3D; 1  # 不可变数据类型</span><br><span class="line">copy_a &#x3D; copy.deepcopy(a)</span><br><span class="line">print(id(a),id(copy_a))  # 内存地址相同</span><br><span class="line"> </span><br><span class="line">a &#x3D; [1,2]  # 可变数据类型</span><br><span class="line">copy_a &#x3D; copy.deepcopy(a)</span><br><span class="line">print(id(a),id(copy_a))  # 内存地址不相同</span><br></pre></td></tr></table></figure>
<p>不管深拷贝还是浅拷贝对不可变数据类型都是引用内存地址  </p>
<p>不管深拷贝还是浅拷贝对可变数据类型都是会重新创建新的内存空间   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 浅拷贝嵌套</span><br><span class="line"># -----------不可变数据类型---------</span><br><span class="line"># 情况一，内嵌可变数据类型</span><br><span class="line">import copy</span><br><span class="line">a &#x3D; ([1,2],(3,4))  # 不可变数据类型</span><br><span class="line">copy_a &#x3D; copy.copy(a)</span><br><span class="line">print(id(a),id(copy_a))  # 内存地址相同</span><br><span class="line"># 情况二，内嵌不可变数据类型</span><br><span class="line">a &#x3D; ((1,2),(3,4))  # 不可变数据类型</span><br><span class="line">copy_a &#x3D; copy.copy(a)</span><br><span class="line">print(id(a),id(copy_a))  # 内存地址相同</span><br><span class="line"> </span><br><span class="line">#-----------可变数据类型-------------</span><br><span class="line"># 情况一，内嵌可变数据类型</span><br><span class="line">import copy</span><br><span class="line">a &#x3D; [(1,2),[3,4]]  # 可变数据类型</span><br><span class="line">copy_a &#x3D; copy.copy(a)</span><br><span class="line">print(id(a),id(copy_a))  # 内存地址不相同</span><br><span class="line"> </span><br><span class="line"># 情况一， 可变数据类型 内嵌可变数据类型</span><br><span class="line">import copy</span><br><span class="line">a &#x3D; [(1,2),(3,4)]  # 可变数据类型</span><br><span class="line">copy_a &#x3D; copy.copy(a)</span><br><span class="line">print(id(a),id(copy_a))  # 内存地址不相同</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 深层拷贝嵌套</span><br><span class="line"># -----------不可变数据类型---------</span><br><span class="line"># 情况一，内嵌可变数据类型</span><br><span class="line">import copy</span><br><span class="line">a &#x3D; ([1,2],(3,4))  # 不可变数据类型</span><br><span class="line">copy_a &#x3D; copy.deepcopy(a)</span><br><span class="line">print(id(a),id(copy_a))  # 内存地址不相同</span><br><span class="line"># 情况二，内嵌不可变数据类型</span><br><span class="line">a &#x3D; ((1,2),(3,4))  # 不可变数据类型</span><br><span class="line">copy_a &#x3D; copy.deepcopy(a)</span><br><span class="line">print(id(a),id(copy_a))  # 内存地址相同</span><br><span class="line"> </span><br><span class="line">#-----------可变数据类型-------------</span><br><span class="line"># 情况一，内嵌可变数据类型</span><br><span class="line">import copy</span><br><span class="line">a &#x3D; [(1,2),[3,4]]  # 可变数据类型</span><br><span class="line">copy_a &#x3D; copy.deepcopy(a)</span><br><span class="line">print(id(a),id(copy_a))  # 内存地址不相同</span><br><span class="line">print(id(a[0]),id(copy_a[0]))  # 内存地址相同</span><br><span class="line">print(id(a[1]),id(copy_a[1]))  # 内存地址不相同</span><br><span class="line"> </span><br><span class="line"># 情况一， 可变数据类型 内嵌可变数据类型</span><br><span class="line">import copy</span><br><span class="line">a &#x3D; [(1,2),(3,4)]  # 可变数据类型</span><br><span class="line">copy_a &#x3D; copy.deepcopy(a)</span><br><span class="line">print(id(a),id(copy_a))  # 内存地址不相同</span><br><span class="line">print(id(a[0]),id(copy_a[0]))  # 内存地址相同</span><br></pre></td></tr></table></figure>
<p>浅拷贝：  </p>
<p>外层是不可变类型、不管内层是否可变都是引用拷贝<br>外层是可变类型，不管内层是否可变都会从新创建新的内存空间   </p>
<p>深拷贝：  </p>
<p>外层是不可变类型，会递归判断内层数据类型、如果可变则创建新的内存地址、都为不可变就是引用拷贝<br>外层是可变数据类型、不管内层是否可变都会创新新的内存地址、但是内部如果为可变则递归创建、不可变则为引用地址      </p>
<p>浅拷贝只做最顶层的数据类型判断<br>如果顶层是可变类型则创建新的内存空间<br>如果顶层是不可变数据类型就是引用拷贝<br>浅拷贝内层数据结构无论是什么都是引用拷贝 </p>
<p>深拷贝做递归拷贝，可以递归拷贝所有的内部嵌套数据（可以理解为循环遍历做浅拷贝判断）<br>深拷贝递归拷贝遇到可变类型则创建新的内存空间<br>深拷贝递归拷贝遇到不可变数据类型就是拷贝的引用    </p>
<p>对于数据类型来说，如果是非嵌套类型的数据结构，如果又是不可变类型，那么无论深拷贝还是浅拷贝都是引用拷贝，如果是非嵌套类型的数据结构，可变类型的话就都是创建新的内存空间，但是浅拷贝只管最外层， 如果内部数据嵌套出现可变类型他还是引用拷贝，深拷贝则会区分如果是不可变类型就引用拷贝，如果可变就创建新的内存空间。<br>例子:a = [11, 22, (33, [1])]  </p>
<p>如果最底层数据类型(元组(33, [1]))是不可变的,不可变类型里包含了可变的类型(列表[1])   </p>
<p>浅拷贝依然不会有自己的空间(元组id:139918749437064 和原来的id一致)    </p>
<p>深拷贝开辟自己的空间(元组id:139918749369672 开辟新空间)   </p>
<h2 id="python如何实现超长整数"><a href="#python如何实现超长整数" class="headerlink" title="python如何实现超长整数"></a>python如何实现超长整数</h2><p>python里整数是一个按以下方式定义的C结构。PyObject_VAR_HEAD是一个宏其他具有PyObject_VAR_HEAD的类型是：PyBytesObject，PyTupleObject，PyListObject这表明整数，就像tuple 或list一样，在长度上是可变的，PyObject结构中的一些元字段，用于引用计数(垃圾收集)于ob_digit是一个数组，所以它主要是一个digit *，是指向digit的指针，因此，如果需要的话，它可以被分配到任意长度。这使得python能够表示和处理巨大地长整数。ob_size保存ob_digit中的元素数目。为了在将内存分配给数组ob_digit时更高效，python进行了过度提供，然后依赖于ob_size的值来确定数组中所包含的元素的实际数量。1152921504606846976 = 1 * (230)2 + 0 * (230)1 + 0 * (230)0这个值的_longobject结构将保持：ob_size 为 3，ob_digit 位 [0, 0, 1]。你可以看到它会遍历数字并按数位顺序执行加法、计算和传递进位Python实现了Karatsuba算法，该算法会在O( nlog23)个基本步骤中乘以两个n数位数字。</p>
<h2 id="python函数初始化过程只初始化一次"><a href="#python函数初始化过程只初始化一次" class="headerlink" title="python函数初始化过程只初始化一次"></a>python函数初始化过程只初始化一次</h2><p>定义函数的时候 </p>
<ol>
<li>申请内存空间  保存函数体代码</li>
<li>将上述内存空间绑定函数名</li>
<li>定义函数不会执行函数体代码 但是会检查代码语法格式  </li>
</ol>
<p>调用函数时：</p>
<ol>
<li><p>通过函数名找到内存地址 </p>
</li>
<li><p>加括号则触发函数体代码执行<br>形参是不可变类型的时候，调用一次 出现一个新地址  默认形参值只在初始化的时候定义一次 后面调用不再初始化</p>
<p> def test(a=0, b=[]):</p>
<pre><code> b.append(a)
 print(id(a))
</code></pre>
<p> a = 1<br> test(1)<br> test(2)<br> test(3)</p>
<p> “””<br> 2930208041264<br> 2930208041296<br> 2930208041328<br> “””<br>函数定义的时候  就会初始化，如果写了默认值，则会初始化 并绑定一个内存空间。所以后续只要不传入参数，那么这个内存空间是一定的 也就是谨慎写入默认值，因为在定义的时候就被初始化了，如果后续绑定的这个值发生改变，则不显示在原函数里  </p>
<p> def test(a, b = []):</p>
<pre><code> b.append(a)
 print(b)
</code></pre>
<p> “””<br> [1]<br> [1, 2]<br> [1, 2, 3]<br> “””</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://andrekuu.github.io/2021/04/22/Python%E8%AF%AD%E8%A8%80%E5%BA%95%E5%B1%82%E7%BB%86%E8%8A%82/" data-id="cknscjo0e0000egvee6ggbtyd" data-title="Python语言底层细节" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C++学无止境" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/22/C++%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" class="article-date">
  <time class="dt-published" datetime="2021-04-21T18:47:14.000Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/22/C++%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/">C++学无止境</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="C-C-历史"><a href="#C-C-历史" class="headerlink" title="C/C++历史"></a>C/C++历史</h2><p>C++ 是什么都能干，干的很精细，python是干活糙快猛。<br>20世纪七十年代Bell实验室为了开发UNIX系统便携设计了C语言。C++是C语言的超集，既可以面向过程设计，又可以面向对象程序设计。C语言是一种结构化程序设计语言，侧重如何通过一个过程对输入进行运算处理得到输出。C++侧重如何构造一个与描述问题相对应的对象模型。C强调的算法和设计结构，后者融入了抽象设计的概念。</p>
<p>C++可以内嵌汇编语言 提高优化能力 </p>
<h2 id="C-编程范式"><a href="#C-编程范式" class="headerlink" title="C++ 编程范式"></a>C++ 编程范式</h2><ol>
<li>结构化编程   数据 暴露在所有函数下，所有函数都可以修改，在大型系统下，就有安全隐患。</li>
<li>OOP面向对象变成  使得开发和  维护程序变得更容易。  数据和处理数据的函数封装到一个特定的环境里，其他函数如果要访问这个数据，必须要通过这个对象object提供的接口。保护了数据。   </li>
<li>Generic Programming（GP,泛型编程）数据的类型变化的时候，编译器自动处理，使得代码本身更加通用。     </li>
<li>FP functional programming 函数式编程   函数式编程就是说你输入数据可能会对函数外的数据造成影响，函数式编程就是防止你对外面有影响。而且函数式编程可以接受一个函数作为输入，输出一个函数作为结果。   </li>
</ol>
<h2 id="C-版本"><a href="#C-版本" class="headerlink" title="C++ 版本"></a>C++ 版本</h2><p>有98版本，还有2011年的11版本 还有2020年刚发的20版本   </p>
<p>吸收了C和BASH的很多特性，形成了python, C++ 11也从python吸收了很多特性<br>C++基础之上发展了JAVA和C#  </p>
<h2 id="基本框架、语法要素"><a href="#基本框架、语法要素" class="headerlink" title="基本框架、语法要素"></a>基本框架、语法要素</h2><p>文件包含命令#include &lt;iostream&gt;因为调用了cout函数，相当于声明要把后面这个文件代码放到这里来，类似于python的import。有的要带.h有的不需要是不同的编译器造成的，VS C++是需要不要.h的   </p>
<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p>Editor、Compiler and Linker(编辑器、编译器和连接器)<br>VS Studio 这些属于继承开发环境 integrated developing Environment IDE<br>visual studio 选择工程 - 属性- c/c++-语言-可以选择使用C++哪种标准<br>#include&lt;&gt;直接从编译器自带的函数库中寻找文件<br>#include””是先从自定义的文件中找 ，如果找不到在从函数库中寻找文件<br>采用”&lt; &gt;”方式进行包含的头文件表示让编译器在编译器的预设标准路径下去搜索相应的头文件，如果找不到则报错。<br>特别要注意的是，如果是标准库头文件，那么既可以采用&lt;&gt;的方式，又可以采用” “的方式，而用户自定义的头文件只能采用” “的方式。<br>函数由函数头和函数体组成<br>system是系统提供的库函数，system(“pause”)是暂停系统运行，方便我们观察输出结果。cout&lt;&lt;s&lt;&lt;endl;<br>C/C++程序有一个或多个函数组成，不管位置怎么样，main有且只有一个，而且执行总是从main函数开始的。<br>书写形式自由，一行内可以一条或多条语句<br>C/C++是区分大小写字母的<br>系统已经定义过、有特殊含义、不能他用的专用单词：break int char break for define<br>标识符 是指用户自定义的标识符，用于程序中变量和常量、函数取名。取名只能用字母数字和下划线，必须以字母或者下划线开头。</p>
<h2 id="行注释、段注释"><a href="#行注释、段注释" class="headerlink" title="行注释、段注释"></a>行注释、段注释</h2><p>// 和 /*  */ 分号是语句结束的标志  </p>
<h2 id="vs编写调试C-程序步骤"><a href="#vs编写调试C-程序步骤" class="headerlink" title="vs编写调试C++程序步骤"></a>vs编写调试C++程序步骤</h2><ol>
<li>创建Win32控制台应用</li>
<li>添加C++文件(.cpp) 源文件的快捷菜单 添加 新建项目 选择cpp文件</li>
<li>输入源程序(源程序是机器无法理解的程序 必须要先通过编译、连接库函数、转为可执行程序)</li>
<li>运行程序 本地windows编译器。</li>
</ol>
<p>sln是解决方案文件，可以打开整个项目，cpp源文件 只能打开源文件，不能加载整个项目，修改源文件必须得点开sln文件 加载整个项目。exe文件是看可执行文件，但是只在控制台下才可以运行。<br>注意一个源文件下只能有一个main主函数。<br>.h 和 .hpp是头文件   .cpp和.cxx是源文件    </p>
<p>可以在解决方案处右键选择属性，选择启动项目设置，这样可以编译调试的时候不用在切换启动项目，直接点一下右边的项目点运行就可以了。   </p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>不建议使用 using namespace std;建议使用：using std::cin; using std::endl; using std::cout;</p>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>C++里整数相除任然是整数  必须要其中有个浮点数才能得到小数。</p>
<h2 id="float-和-double"><a href="#float-和-double" class="headerlink" title="float 和 double"></a>float 和 double</h2><p>double 和 float 的区别是double精度高，有效数字16位，float精度7位。但double消耗内存是float的两倍，double的运算速度比float慢得多，C语言中数学函数名称double 和 float不同，不要写错，能用单精度时不要用双精度（以省内存，加快运算速度）。<br>　　类型 比特数 有效数字 数值范围</p>
<p>　　float 32 6-7 -3.4<em>10(-38)～3.4</em>10(38)<br>　　double 64 15-16 -1.7<em>10(-308)～1.7</em>10(308)<br>　　long double 128 18-19 -1.2<em>10(-4932)～1.2</em>10(4932)</p>
<h2 id="C-程序创建修改源代码"><a href="#C-程序创建修改源代码" class="headerlink" title="C++程序创建修改源代码"></a>C++程序创建修改源代码</h2><p>源代码保存到磁盘；然后编译：compiler，预处理，然后编译；生成机器码，也就是目标文件.obj；最后Link连接，将目标文件外加库链接为一个可执行文件 Link 也就是.exe</p>
<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><ol>
<li>语法错误 syntax Error (写错关键字，遗漏分号、冒号、括号、未声明的标识符没有std)</li>
<li>运行错误 Runtime Error (比如除0操作、内存不足、打开不存在的文件)</li>
<li>逻辑错误 Logic Error </li>
</ol>
<h2 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h2><p>C语言是通过调用标准库函数里的scanf和printf实现输入输出的，C++是通过对两个标准流类对象cin和cout的操作来实现输入输出的。<br>C++保留了printf和scanf。<br>cout&lt;&lt;表达式1&lt;&lt;表达式2&lt;&lt;表达式n;<br>cout代表显示器，&lt;&lt;是插入运算符，意思是将各个表达式插入到显示器中。表达式之间必须用&lt;&lt;分割，而不能用逗号。cout的定义信息存放在C++输入输出流库中，所以使用cout必须使用如： </p>
<h2 id="输入输出的分类"><a href="#输入输出的分类" class="headerlink" title="输入输出的分类"></a>输入输出的分类</h2><p>除了键盘输入输出的标准输入输出以外，还有File I/O 文件I/O，网络I/O Network I/O；  </p>
<h2 id="cin-cout"><a href="#cin-cout" class="headerlink" title="cin/cout"></a>cin/cout</h2><p>cin.get()从流中读取并取走一个字符 cin.getline()从流中读取字符，直至行尾或指定的分隔符；cin.ignore()从流中读取并舍弃指定数量的字符；    </p>
<pre><code>char ch = cin.get();
// char ch; cin.get(ch);  //读取一个字符  
</code></pre>
<p>cout.put()将字符写到流中(无格式)<br>cout.flush()将流中缓存内容全部输出    </p>
<h2 id="引用-reference"><a href="#引用-reference" class="headerlink" title="引用 reference"></a>引用 reference</h2><pre><code>int x;
int&amp; rx = x;
</code></pre>
<p>就是给x取别名rx,通过引用所做的读写操作实际上是作用在原来变量上的。<br>&amp; 是取对应变量的地址，但是如果是在定义初始化的时候，这个是别名 引用的意思。使用的是同一块内存地址；<br>定义引用的时候需要绑定到一个已经定义的变量上，不能空着不=。   </p>
<pre><code>定义指针的时候也要
float* p;  \\ 编程规范，引用和指针都是的符号*、&amp; 靠近类型，而非变量名 。
</code></pre>
<p>当一个变量一旦绑定了某个变量，这个引用的关系已经不可以被改变了。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* t = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>*&amp; r = s;</span><br><span class="line">	r = t;</span><br><span class="line">	cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">\\ 输出是 world\nworld</span><br></pre></td></tr></table></figure>
<p>一个变量无论是什么变量一旦初始化绑定了某个变量，那么就不可以改变，如果改变该变量，则会改变他绑定的变量，</p>
<p>#include &lt;iostream&gt;<br>using namespace std;<br>cin代表键盘，&gt;&gt;提取运算符。<br>cin&gt;&gt;变量1&gt;&gt;变量2&gt;&gt;变量3;<br>输入数据必须得用回车符、空格、制表符来分割。   </p>
<h2 id="system-“pause”-和-cin-get"><a href="#system-“pause”-和-cin-get" class="headerlink" title="system(“pause”); 和 cin.get();"></a>system(“pause”); 和 cin.get();</h2><h2 id="输出小数控制"><a href="#输出小数控制" class="headerlink" title="输出小数控制"></a>输出小数控制</h2><p>调用iomanip 其中 setprecision(n)是控制精度的，fixed以后就是控制小数点后几位的    </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> value = <span class="number">12.3456789</span>; cout &lt;&lt; value &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认以6精度，所以输出为 12.3457</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">4</span>) &lt;&lt; value &lt;&lt; endl; <span class="comment">// 改成4精度，所以输出为12.35</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">8</span>) &lt;&lt; value &lt;&lt; endl; <span class="comment">// 改成8精度，</span></span><br><span class="line">所以输出为<span class="number">12.345679</span></span><br><span class="line">cout &lt;&lt; fixed &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">4</span>) &lt;&lt; value &lt;&lt; endl; <span class="comment">// 加了fixed意味着是固定点方式显示，所以这里的精度指的是小数位，输出为12.3457</span></span><br><span class="line">cout &lt;&lt; value &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fixed和setprecision的作用还在，依然显示12.3457</span></span><br><span class="line">cout.<span class="built_in">unsetf</span>( ios::fixed ); <span class="comment">// 去掉了fixed，</span></span><br><span class="line"></span><br><span class="line">所以精度恢复成整个数值的有效位数，显示为<span class="number">12.35</span></span><br></pre></td></tr></table></figure>

<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>有常量或者变量形式表达<br>作用有：决定数据的存储空间、决定数据的取值范围、决定数据所能参与的运算<br>32位系统里，一个整数分配4个字节，一个字符型分配1个字节。32位系统中，整数范围是-2^31  - 2^31 - 1范围<br>数据类型分类：<br>基本数据类型就是不可以继续向下分的数据类型  整型int  字符型char 实型：单精度float 双精度 double（存储空间、精度、取值范围都不相同）<br>构造类型比如数组、结构体、共用体，这种是有基本类型数据组成的复杂的类型<br>指针类型<br>空类型（void）  </p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><pre><code>数据类型  变量名表；
int a,b,c;
</code></pre>
<p>先定义后使用，先赋值后运算。    </p>
<pre><code>数据类型  变量名=表达式；  // C语言
数据类型 变量名 （表达式); // C++
</code></pre>
<p>连等形式是不被允许的。    </p>
<pre><code>int k = 3, m = 3, n(3);
</code></pre>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量就是运行过程中值不能改变  </p>
<ul>
<li>值常量：5、3.14、’a’、”abcd”</li>
<li>符号常量 用一个标识符表示的常量 需要定义  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 数据类型 标识符 = 常量值；</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 标识符 常量值   <span class="comment">// 注意这里不能加分号，不然就会被赋值成为一部分了。 </span></span></span><br></pre></td></tr></table></figure>
整数形式常量 其中八进制以数字0开始， 023， -010<br>十六进制是一0x 或 0X开始， 0XAF, -0X51<br>实型常量<br>十进制小数形势： -1.25、 17. 、 .1<br>指数形势：由尾数、指数符号e或E以及指数构成 比如1.25e-5 、1E3<br>e前面的的尾数不可以省，而且后面的指数不可以加圆括号也必须得是整数   </li>
</ul>
<p>普通字符常量：用单引号引起来的单个字符 ‘A’、’O’、’?’<br>转义符号常量：以”&quot;开头用单引号阔气的字符序列。如’\n’、’\t’、’\0’<br>字符串常量：用双引号括起来的字符序列，系统在该常量尾自动加字符串结束’\0’<br>字符型数据在内存中以ASCII码存储，一定范围内的整形与字符型数据可以相互转换。   </p>
<pre><code>char ch = &#39;a&#39; - 32;
</code></pre>
<p>注意 ‘\0’与’0’不同，前者是字符串结束符号，ASCII码是0，后者是数字字符，ASCII码是48。<br>此外，’a’ 与”a” 也不同，前者占1个字节，后者占2个字节，后者末尾隐含字符’\0’    </p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>优先级共15个级别<br>结合性规定优先级相同的运算符连续运算时候的顺序，分自左向右和自右向左两种。<br>目数：运算符所需要的操作数的个数，分单目、双目、三目运算符，通常目数少优先级高。<br>相同目数的各运算符的优先级顺序是：算数、关系、逻辑、条件、赋值、逗号</p>
<p>自增自减 取正取负都是单目运算 优先级最高 – ++<br>整数相除商为整数，一律舍弃小数部分<br>求余操作必须两个操作数都是整数  结果的符号与被除数一直 因为C00规定  a%b = a -a/b*b<br>百位：m/100、 m%100/10、 m%10<br>自增自减运算符 ++  – 作用于变量  形式前置（运算符位于变量前）和后置(运算符位于变量后)运算<br>对自增自减运算变量本身的值而言，没有区别，对于参与的表达式贡献不同，前置运算是以变化后的值参与运算，后置运算是以变化后的值参与运算的。    </p>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>== 等于 ！= 不等于  1代表真，0代表假<br>C/C++无法实现  0&lt;=x&lt;=100  而且cout记得加括号 cout &lt;&lt; (i &lt;= 100) &lt;&lt; endl;</p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑非（！）逻辑与（&amp;&amp;）逻辑或（||）<br>并非所有的逻辑运算都会被执行，**运算过程中只要表达式的值能唯一确定，后续运算就不再进行  **</p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>将右边表达式的值送到左边的变量<br>复合赋值运算符  += -= %= *=  /= 和python一样这里 右边表达式的值和左边变量做了运算后送入左边的变量  右边是一个整体</p>
<pre><code>a *= x + y     ===&gt;    a = a * (x + y)
</code></pre>
<p>左端只能是变量或数组元素，不能是表达式或常量<br>左右端类型不一致则会把右端类型转换为左端类型存入左端   </p>
<h3 id="条件运算符-？："><a href="#条件运算符-？：" class="headerlink" title="条件运算符 ？："></a>条件运算符 ？：</h3><p>是三目运算 赋值运算符的优先级要低于条件运算符<br>e1 ? e2 : e3<br>e1的值如果是非0，则去e2的值否则去e3的值，其中e2和e3表达式只有一个被求值<br>max = (x &gt; y) ? x : y</p>
<h3 id="逗号运算符（-）"><a href="#逗号运算符（-）" class="headerlink" title="逗号运算符（,）"></a>逗号运算符（,）</h3><p>从左到右依次计算每个表达式的值，<strong>整个表达式的值是最右边表达式的值</strong></p>
<pre><code>c = (a = 10, b = 20, a + b);  // c = 30
</code></pre>
<p>常见应用场景是for语句，用于连接多个表达式    </p>
<pre><code>for (i = 0, j = n; i &lt; j; i++, j--)
</code></pre>
<h2 id="类型转换运算"><a href="#类型转换运算" class="headerlink" title="类型转换运算"></a>类型转换运算</h2><p><strong>自动类型转换</strong>  （赋值运算右端类型转换为左端类型，其他运算按照从低到高转换规则转换为其他一种类型后再运算）<br>char、short -&gt; int –&gt; unsigned –&gt;long –&gt; float –&gt; double<br>如果char short要参与运算 就必须先转为int类型，同样float要参与运算也必须先转为double类型<br><strong>强制类型转换</strong>   通过一个括号实现，要么霸类型标识符括起来，要么把后面表达式括起来  </p>
<pre><code>(类型标识符) 表达式 或 类型标识符 （表达式）
</code></pre>
<p>可以把一种类型的值强制转换为另一种指定类型   强制类型转换是得到了一个性的数据，而原变量类型是不变的   </p>
<p>C++风格强制类型转换</p>
<p>语法：static_cast<type> value</p>
<pre><code>out &lt;&lt; static_cast&lt;double&gt;(1) / 2;
cout &lt;&lt; 1 / 2;
</code></pre>
<h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><p>单分支选择结构 双分支 循环结构<br>选择结构 根据条件选择不同分支执行<br>循环结构某种条件下重复执行一组操作<br>空语句 没有执行代码，只有分号构成的语句，功能主要是延迟。<br>复合语句 用{}将多条语句组合一个整体   语法结构上这还是一条语句<br><strong>内部可以定义复合语句内部使用的变量 t只在{}内部有效</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; y)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> t= x;</span><br><span class="line">	x = y ;</span><br><span class="line">	y = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子里t只在{}内部有效  也就是如果在{}内声明的新变量，外部无法使用    </p>
<h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>if(表达式)语句 如果表达式为真，则执行语句，否则跳过语句。语句只能是一条，但是可以是复合语句。   </p>
<pre><code>    if (表达式)
    &#123;
    语句1；
    &#125;
    else
    &#123;
    语句2；
    &#125;
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (表达式<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">1</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(表达式<span class="number">2</span>) </span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">2</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">语句<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>嵌套if else结构else中始终与其上面最近的没有配对的if配对。</p>
<h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><pre><code>switch(表达式)
&#123;
    case 常量表达式1：语句组1；[break;]
    case 常量表达式2：语句组2; [break;]
    [default: 语句组n]
&#125;
</code></pre>
<p>switch后的表达式类型<strong>必须为整形或者字符型</strong>，<strong>case后的常量表达式必须为可一一列举的具体取值，不能是取值范围！</strong> 多个常量表达式可以公用一组语句组    </p>
<h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>while<br>for<br>do  while  </p>
<pre><code>while (表达式)
    语句  
</code></pre>
<p>要注意表达式后面不能加；</p>
<pre><code>do
    语句
while (表达式);
</code></pre>
<p>注意这里意味着循环结束 这里必须得有;<br>do  while 是先循环后判断，所以至少会被执行一次， while先判断后循环，循环体可能一次都不执行。<br>do while最后必须得有分号  </p>
<pre><code>for (表达式1；表达式2；表达式3)
    循环体语句
</code></pre>
<p>for循环的表达式1是初始化，循环变量赋予初值，表达式2是循环条件，表达式3是循环变量变换情况<br>表达式结束的括号后没有 ；<br>三个表达式都可以省略，但是中间两个括号不能省略<br>表达式1只在循环开始之前执行一次而且可以放在for语句之前完成   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i += <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		res += i;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	int res(0), i(1);</span><br><span class="line">	<span class="keyword">for</span> (; ; )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt;= <span class="number">100</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		res += i;</span><br><span class="line">		i += <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表达式1,2,3都可以省略，但是两个分号不可以省略，同时break可以跳出循环    </p>
<p>求最大公约数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> m, n, r;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;请输入两个大于0的正整数：&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">	&#125; <span class="keyword">while</span> (m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span> ((r = m % n ) != <span class="number">0</span>)  <span class="comment">// 这里可以（括号内赋值）</span></span><br><span class="line">	&#123;</span><br><span class="line">		m = n;</span><br><span class="line">		n = r;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;最大公约数是：&quot;</span> &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断一个自然数是否是一个素数  </p>
<h2 id="辅助控制语句"><a href="#辅助控制语句" class="headerlink" title="辅助控制语句"></a>辅助控制语句</h2><p>break ： </p>
<ol>
<li>用于switch语句，跳出switch结构，保证多分支的正确执行</li>
<li>用于循环语句 强制退出循环体<br>只能跳出中值最近一层结构<br>continue  结束本次循环 跳过循环体没有被执行的语句，进行下一次循环<br>go to </li>
</ol>
<pre><code>go to here;
here:
</code></pre>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>一维数组、二维数组、字符数组、指针和数组     </p>
<pre><code>数据类型  数组名[整形常量表达式]
float s[N];
</code></pre>
<p>数组是同类型、同性质的一组元素殊勋存放构成的数据集合。所有的数据公用了同一个名字，通过下标区分不同的数据。处理时可以通过循环控制变量控制下表的变化来批量处理数组中的数据。<br>数组名代表数组在内存的首地址，由系统自动分配。<br>整形常量表达式代表数组的长度，此处是不可使用变量说明长度的。数组的长度为N，包含的分量元素的下表从 0 ~ N - 1<br>切记不可以用变量来赋值数组的长度。C99之前元素数量必须是编译阶段确定的常量。<br>长度不可以为空、变量和非整数型。<br>对于数值型数组，程序只能操作数组元素，不可以操作数组名。<br>数组的初始化<br>数组定义的同时允许为数组的部分或全部元素赋予初值。<br>初值应被组织在花括号中。（字符数组表示字符串例外）    </p>
<pre><code>int a[5] = &#123;0, 2, 4, 6, 8&#125;;
int a[] = &#123;0, 2, 4, 6, 8&#125;;  // 这个时候可以省略[]  长度为5
</code></pre>
<p>部分赋初值的时候 未被赋值的元素默认为0   </p>
<pre><code>int a[10] = &#123;1, 2, 3, 4, 5&#125;;  // a[5]--a[9] 都为0
</code></pre>
<p>只有初始化的时候可以等于集合。如果初始化过了，那么调用只会当做元素。<br>注意一下表达式错误的  ：</p>
<pre><code>int a[10];
a[9] = &#123;1, 2, 3, 4&#125;;  \\ 这是错误的因为这里已经不是初始化了，这个只能代表单个元素。 
</code></pre>
<p>C++里还有array数组和vector数组。</p>
<p>这里数组名是一个地址，相当于一个指针。所以下面输出的是 8， 1</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

void test(int tt[]) &#123;
    cout &lt;&lt; sizeof(tt) / sizeof(tt[0]) &lt;&lt; endl;
&#125;

int main()
&#123;
    int arra[] = &#123; 1,2,4,7,3,5,6,8 &#125;;
    cout &lt;&lt; sizeof(arra) / sizeof(arra[0]) &lt;&lt; endl;
    test(arra);
    return 0;
&#125;
</code></pre>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>rand() 随机数范围 0 ~32767 原型在头文件stdlib.h里<br>记录最小值坐标，然后比较，最后交换最小值坐标的值和遍历坐标的值，继续向后遍历。   </p>
<h3 id="插入、删除"><a href="#插入、删除" class="headerlink" title="插入、删除"></a>插入、删除</h3><p>数组中插入和删除都需要挨个挪动后面所有的元素值。 用for遍历实现   </p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>注意不能越界，不能下标为负数这样会把其他地址赋值为这个，将信息存储在数组外面，C++不检查这种越界错误。   </p>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><pre><code>数据类型 数组名[常量表达式1][常量表达式2]  
</code></pre>
<p> 元素个数为行列长度的乘积。行、列下表都从0开始。系统为她分配的首地址开始依次存放。<br>全部元素初始化的时候可以省略第一维长度    </p>
<pre><code>int a[2][3] = &#123;1, 2, 3, 4, 5, 6&#125;;
int a[][3] = &#123;1, 2, 3, 4, 5, 6&#125;;
</code></pre>
<p>可以按行给所有元素赋初值，每行数据组织在一对花括号内。<br>可以按照行给部分的元素赋初值，未被赋予初值的元素自动为0(数值型数组)   </p>
<pre><code>int b[3][4] = &#123;&#123;1, 2&#125;, &#123;0, 3, 4&#125;, &#123;0, 0, 5&#125;&#125;;
</code></pre>
<p>按照行赋初值可以省略第一维长度   </p>
<pre><code>int c[][3] = &#123;&#123;1&#125;, &#123;2&#125;, &#123;3&#125;&#125;;
</code></pre>
<h2 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h2><p>字符串是双引号引起的一串字符串 “ab123” （常量）字符串末尾默认有’\0’   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>] = &#123;<span class="string">&quot;I am fine&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>] = <span class="string">&quot;I am fine&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">3</span>][<span class="number">8</span>] = &#123;<span class="string">&quot;COBOL&quot;</span>, <span class="string">&quot;HELLO&quot;</span>, <span class="string">&quot;HANWEN&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>注意一下是报错的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> tmp;</span><br><span class="line">	<span class="keyword">char</span> s[<span class="number">3</span>][<span class="number">9</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&quot;AA&quot;</span>&#125;;  \\ 错的原因是这里如果有单引号，意味着一个个字符赋值，会和后面字符串不兼容，说过是字符串，必须双引号 因为后面自带<span class="string">&#x27;\0&#x27;</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; s[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存多个字符串就设计二维数组来存放<br>单数输入的时候需要字符串的整体输入    </p>
<pre><code>cin &gt;&gt; s;  // 一旦有了空格 就相当于输入停止了 ！不能提取s中空白符后面的内容 比如 hello world 只能提取hello  

gets_s(s);  // 支持字符串里有空格   

cout &lt;&lt; s;  // 字符串的整体输出 空格不影响
puts(s);  // 字符串的整体输出  
</code></pre>
<p>gets_s()和puts都是 &lt;stdio.h&gt;库里的    cin 是无法提取空格符的<br>字符串处理的原则是整体输入、整体输出，不用数组长度控制循环， 而通过当前字符是否达到字符’\0’来判断循环是否结束。所以构造字符串的时候也要注意，结尾一定要有’\0’。如果这个字符串已经构成了，循环的时候判断是否为’\0’，然后结束循环，这个’\0’自动保留即可。   </p>
<p>因为数组的名称是首字母的地址，所以不能通过  lst1 = lst2 直接复制，必须逐个元素挨个复制。<br>常用字符串处理函数：（string.h头文件里）</p>
<pre><code>strlen(str);  // 求字符串长度 不包括‘\0’；
_strlwr_s(str);  // 其中所有大写转小写；
_strupr_s(str); // 其中所有小写转大写；
strcpy_s(str1, str2);  // 把str2 复制到str1,str1 只能是字符数组的名字，
strcat_s(str1, str2);  // 将str2连接到str1的末尾,不加空格，改变了str1；
strcmp(str1, str2);  // 从左到右比较字符ASCII码， str1 &lt; str2 则返回 -1；str2 == str1 返回 0， str1 &gt; str2 返回1；
</code></pre>
<p>因为strcpy_s strcat_s _strlwr_s  _strupr_s 都涉及对str1的更改,所以str1不能是字符常量   </p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>每个变量在内存中存放都对应一段地址，其中首字节即为变量的地址，将存放地址的变量称为指针变量。<br>&amp;：取地址运算  *：取地址里的内容 </p>
<pre><code>&amp;x  \\ 代表变量x的地址 
</code></pre>
<p>指针变量相当于  &amp;x<br>指针变量的定义：</p>
<pre><code>数据类型  *标识符  
</code></pre>
<p>数据类型代表指针所指向的数据的类型<br>这里的* 星号 只是指针变量的一个标志，不是变量名的一部分    </p>
<p>指针变量的初始化   </p>
<pre><code>int a = 5, *p = &amp;a;
// 等价于：    
int a = 5, *p;
p = &amp;a;
</code></pre>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>], *p = a; \\ 因为这里的a是数组，所以a就代表数组首地址，所以可以直接等于。</span><br></pre></td></tr></table></figure>
<p>永远记住指针永远代表的是一个地址。指针变量提供了数据间接访问的一种方式。<br>指针的使用前提是，赋值运算，必须赋值赋予地址。<br>初始化可以用</p>
<pre><code>p1 = &amp;a;  // p指向变量a
p1 = p2; // 都被初始化后的指针，如果p2已经被赋值了，可以同类型直接赋值。   
p = new int;  // 动态为p分配存放一个整数的空间
p = new int[10];  // 动态为p分配一个存放10个整数的空间   
</code></pre>
<p>要避免随意将整数值赋给指针变量，此外还要保证指针对应变量类型和指针类型不一致的变量地址。     </p>
<p>指针接受加减整数的运算</p>
<pre><code>p + n (p - n); :指向p后面（或前面）的第n个元素   
p++;
p--;
</code></pre>
<p>p2 - p1 是指这两个地址差之间可以存放的数据的个数    p2 - p1 = (p2 - p1)/sizeof(数据类型)  比如p2 = 1008, p1 = 1000, 类型是int 则是 p2 - p1 = 8/4 = 2;     </p>
<p>int  4个字节 32位<br>char 1个字节<br>float 4个字节<br>double  8个字节</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p2 = <span class="number">016857B</span>0;</span><br><span class="line"><span class="keyword">int</span> *p1 = p2 + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 则P1 = 016857B4;</span></span><br></pre></td></tr></table></figure>

<h2 id="指针和一维数组"><a href="#指针和一维数组" class="headerlink" title="指针和一维数组"></a>指针和一维数组</h2><pre><code>int a[10], *p = a;
// *(p + i) == *(a + i) == a[i] 
</code></pre>
<p>也允许带下表的形式访问数组  比如  p[i] 等价于 *(p + i) 等价于 a[i] （当然 int *p = a）   </p>
<pre><code>*p++ 等价于 *p 再 p++ 因为这是后自增  先运算再自增 
(*p)++ 这个是把 p地址所指的内容 自增  先取出来这个地址的值，然后这个地址内容 + 1
</code></pre>
<p>注意数组a是地址常量，p是地址变量 *</p>
<h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><p>函数必须总是将返回值明确列出 ， 若你不写返回值，编译器会默认返回int</p>
<h2 id="指针和字符"><a href="#指针和字符" class="headerlink" title="指针和字符"></a>指针和字符</h2><pre><code>const char* s = &quot;hello&quot;;   \\ s 指向hello的 &#39;h&#39;
const char*&amp; rs = s;

int main() &#123; 
    const char* s = &quot;hello&quot;;
    const char*&amp; rs = s;
    while (*s != &#39;\0&#39;) &#123;
        cout &lt;&lt; *rs++ &lt;&lt; endl;
    &#125;
    return 0;
&#125;
</code></pre>
<h2 id="参数调用"><a href="#参数调用" class="headerlink" title="参数调用"></a>参数调用</h2><p>如果函数调用的是形参，那么实际上是做了一个copy，不改变原变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">	t = x; x = y; y = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Before calling swap():&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">swap</span>(a, b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After calling swap():&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">\\ 直接调用形参</span><br><span class="line"><span class="function">Before calling <span class="title">swap</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">a =</span> <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">After calling <span class="built_in">swap</span>():</span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">```     </span><br><span class="line">调用指针和引用则可以实现对原变量的修改。</span><br><span class="line">```C++</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>* x, <span class="keyword">int</span>* y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">	t = *x; *x = *y; *y = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Before calling swap():&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">swap</span>(&amp;a, &amp;b);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After calling swap():&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\\ passby Pointer：</span><br><span class="line"><span class="function">Before calling <span class="title">swap</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">a =</span> <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">After calling <span class="built_in">swap</span>():</span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">b = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>如果函数调用的是指针，则会改变原来的变量值，因为指针指向的地址是唯一确定的，调用函数的时候实际上就是对两个地址发生了改变。<br>使用引用也会产生同样效果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">	t = x; x = y; y = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Before calling swap():&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">swap</span>(a, b);  \\ 引用绑定发生在这里  相当于 <span class="keyword">int</span>&amp; x = a;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;After calling swap():&quot;</span> &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\\ 调用引用也可以对原变量实现修改</span><br><span class="line"><span class="function">Before calling <span class="title">swap</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">a =</span> <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">After calling <span class="built_in">swap</span>():</span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">b = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><ol>
<li>C++03中，空指针使用“0”来表示。0既是一个常量整数，也是一个常量空指针。</li>
<li>C语言中，空指针使用(void *)0来表示</li>
<li>有时候，用“NULL”来表示空指针(一种可能的实现方式是#define NULL  0)</li>
</ol>
<p>C++11中引入保留字“nullptr”作为空指针 </p>
<h2 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h2><p>C++中通过运算符new申请动态内存</p>
<pre><code>new  &lt;类型名&gt; (初值) ;     //申请一个变量的空间 只有一个哦 初值可以直接赋值 也可以&#123;&#125;大括号
new  &lt;类型名&gt;[常量表达式] ;   //申请数组常量表明有多少个这个类型的数组
</code></pre>
<p>如果申请成功，返回指定类型内存的地址；<br>如果申请失败，抛出异常，或者返回空指针(nullptr)。(C++11)  </p>
<pre><code>char* s = new char(&#39;a&#39;);
delete s;

int* p = new int[10];
delete []p;
</code></pre>
<p>动态内存使用完毕后，要用delete运算符来释放。<br>delete   &lt;指针名&gt;;    //删除一个变量/对象<br>delete []  &lt;指针名&gt;;     //删除数组空间 </p>
<h2 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h2><p>三个关键字bool,true,false（true和false都是常量）<br>布尔变量/函数的命名应使用前缀“is”<br>例如：isSet, isVisible, isFinished, isFound, isOpen<br>断行必须很明显, 在逗号或运算符后换行，新行要对齐     </p>
<pre><code>bool  isMyBook;
bool  isRunning = &#123;false&#125;;  //C++11 列表初始化方式
bool  isBoy( );  // bool类型的函数 参数为空 
 
bool   hasLicense();
bool   canWork();
bool   shouldSort();
</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0  --- false              &#x2F;&#x2F; 整数0和布尔false互相转化</span><br><span class="line"></span><br><span class="line">true --- 1                  &#x2F;&#x2F; 布尔true转化为整数1</span><br><span class="line"></span><br><span class="line">non-zero --- true     &#x2F;&#x2F; 任意非0整数转化为布尔true</span><br></pre></td></tr></table></figure>

<p>在写bool函数的时候 如果是直接和数比较建议写成数字在前，变量在后   </p>
<pre><code>if (3 == a)&#123;
    // blah blah
&#125;
</code></pre>
<p>这里如果忘了写一个等号，编辑器可以报错 ，如果反过来写，编辑器就不会报错 以为是赋值。   </p>
<pre><code>int main() &#123;
    bool isAlpha = false;
    if (!isAlpha) &#123;
        cout &lt;&lt; &quot;isAlpha = &quot; &lt;&lt; isAlpha &lt;&lt; endl;
        cout &lt;&lt; std::boolalpha &lt;&lt; &quot;isAlpha = &quot; &lt;&lt; isAlpha &lt;&lt; endl;
    &#125;
    return 0;
&#125;
</code></pre>
<p>这里的 std::boolalpha就是这后面的输出输出的bool以bool形式true or false输出，而不是以数字的形势。   </p>
<h2 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h2><ol>
<li><p>Direct list initialization (直接列表初始化)</p>
</li>
<li><p>Copy list initialization (拷贝列表初始化)</p>
<p> //直接列表初始化)</p>
<p> /* Variable initialization */ </p>
<p> int x{}; // x is 0; </p>
<p> int y{ 1 }; // y is 1; </p>
<p> /* Array initialization */ </p>
<p> int array1[]{ 1,2,3 }; </p>
<p> char s1[ 3 ] { ‘o’, ‘k’ }; </p>
<p> char s3[]{ “Hello” }; </p>
</li>
</ol>
<pre><code>//拷贝列表初始化

/* Variable initialization */ 

int z = &#123; 2 &#125;; 

/* Array initialization */ 

int array2[] = &#123; 4,5,6 &#125;; 

char s2[] = &#123; &#39;y&#39;,&#39;e&#39;,&#39;s&#39; &#125;; 

char s4[] = &#123; &quot;World&quot; &#125;;

char s5[] = &quot;Aloha&quot;; // Omit curly braces (省略花括号)
</code></pre>
<p>列表初始化有个好处就是如果出现窄化，也就是精度丢失的问题，编译器能够检查到。   比如</p>
<pre><code>int x = 1.1;  //编译器不报错；
int x&#123;1.1&#125; //编译器会提示有问题  
</code></pre>
<h2 id="C-11类型系统的增强"><a href="#C-11类型系统的增强" class="headerlink" title="C++ 11类型系统的增强"></a>C++ 11类型系统的增强</h2><p>类型系统是讲type属性制定个不同计算机程序构造块的规则集<br>为什么要类型系统： 是为了减少程序中可能出现的bug  定义不同程序块之间的接口，检查多个块之间是否一致的方式连接在一起。<br>静态类型就是这个检查发生在编译器，称为静态类型，检查发生在运行时，则是动态类型。所以C\C++\JAVA<br>,而python 就是动态语言。    </p>
<pre><code>举个栗子：
// python  str + int 这个错误就在运行时才报错 而 C++在编译的时候就不通过。   
</code></pre>
<h2 id="Auto-type-deduction-C-11自动类型推导-auto"><a href="#Auto-type-deduction-C-11自动类型推导-auto" class="headerlink" title="Auto type deduction C++11自动类型推导  auto"></a>Auto type deduction C++11自动类型推导  auto</h2><p>C++11中，auto关键字放在变量之前，作用是在声明变量的时候根据变量初始值的类型自动为此变量选择匹配的类型<br>运算符typeid(val).name() 可以显示其类型 但是会自动无视const 和 引用  也就是只显示int不是const int即使他是的话<br>例如：</p>
<pre><code>int a = 10;
auto au_a = a;  //自动类型推断，au_a为int类型
cout &lt;&lt; typeid(au_a).name() &lt;&lt; endl;
</code></pre>
<p><strong>auto 变量必须在定义时初始化</strong>，这类似于const关键字    </p>
<pre><code>auto a1 = 10;  //正确 

auto b1;   //错误,编译器无法推导b1的类型

b1 = 10;
</code></pre>
<p>定义在一个auto序列的变量必须始终推导成同一类型   </p>
<pre><code>auto a4 = 10, a5&#123;20&#125;;   //正确 

auto b4&#123;10&#125;, b5 = 20.0; //错误,没有推导为同一类型 分开用两行写即可。
</code></pre>
<p>如果初始化表达式是引用或const，则去除引用或const语义。</p>
<pre><code>int a&#123;10&#125;; 

int&amp; b = a;

auto c = b;   //c的类型为int而非int&amp;（去除引用）这时候 c = 10;地址和a不同。   

const int a1&#123;10&#125;;

auto b1 = a1; //b1的类型为int而非const int（去除const） 
</code></pre>
<p>如果auto关键字带上&amp;号，则不去除引用或const语意</p>
<pre><code>int a = 10; int&amp; b = a;

auto&amp; d = b;//此时d的类型为int 但是是引用int&amp;  这不就相当于 int&amp; d = b;么所以也是引用啊。

const int a2 = 10;

auto&amp; b2 = a2;//因为auto带上&amp;，故不去除const，b2类型为const int 也就是说b2不可以修改 也是常量   
</code></pre>
<p>初始化表达式为数组时，auto关键字推导类型为指针。</p>
<pre><code>int a3[3] = &#123; 1, 2, 3 &#125;;

auto b3 = a3; // 因为数组名称就是数组首地址的地址

cout &lt;&lt; typeid(b3).name() &lt;&lt; endl; //输出int * （输出与编译器有关）就是数组类型 这里两个地址不一样，是一个复制的数组，不过指针形式出现  
</code></pre>
<p>若表达式为数组且auto带上&amp;，则推导类型为数组类型。</p>
<pre><code>int a7[3] = &#123; 1, 2, 3 &#125;;

auto&amp; b7 = a7;  //因为这里相当于引用，那当然是原类型 int数组啦 而且地址也一样，和引用定义同。

cout &lt;&lt; typeid(b7).name() &lt;&lt; endl; //输出int [3] （输出与编译器有关）
</code></pre>
<p>C++14中，auto可以作为函数的返回值类型和参数类型  </p>
<p>auto和初始化列表一起用，要避免在一行中使用直接列表初始化和拷贝列表初始化，也就是，下面的代码是有问题的：</p>
<pre><code>auto x &#123; 1 &#125;, y = &#123; 2 &#125;;  // 不要同时使用直接和拷贝列表初始化   
</code></pre>
<p>尽量使用auto  使用auto是为了代码的正确性、性能、可维护性、健壮性，以及方便)，例如：保证在声明变量时即初始化</p>
<pre><code>auto x = int &#123;3&#125;;  // 初始化列表

auto y = int &#123;3.0&#125;; // 编译器报错，初始化列表不能窄化

auto z = int (3.0);  // C风格的强制类型转换，z的值是整数3

auto x = 42.f; // 定义浮点数

auto x = 42ul; // 无符号长整型  

auto x = &quot;42&quot;s; // C++14定义字符串
</code></pre>
<p>注意 auto不能定义C风格的数组</p>
<pre><code>auto x[] = &#123;1,2,3&#125;; // 错误 ！
</code></pre>
<h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p>decltype利用已知类型声明新变量。<br>有了auto，为什么还要整出一个decltype？原因是，我们有时候想要从表达式的类型推断出要定义的变量类型，但不想用该表达式的值初始化变量。<br>decltype是在编译期推导一个表达式的类型，它只做静态分析，因此它不会导致已知类型表达式执行。<br>decltype 主要用于泛型编程（模板）<br>decltype和auto都是C++11自动类型推导的关键字。它们有很多差别：  </p>
<ol>
<li>auto忽略最上层的const，decltype则保留最上层的const    </li>
<li>auto忽略原有类型的引用，decltype则保留原有类型的引用    </li>
<li>对解引用操作，auto推断出原有类型，</li>
<li></li>
<li>decltype推断出引用；</li>
<li>auto推断时会实际执行，decltype不会执行，只做分析。   </li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">fun1</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> <span class="number">10</span>;  &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">fun2</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;g&#x27;</span>; &#125;  <span class="comment">// C++14</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Data type of x is same as return type of fun1()</span></span><br><span class="line">    <span class="comment">// and type of y is same as return type of fun2()</span></span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">fun1</span>()) x;  <span class="comment">// 不会执行fun1()函数</span></span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">fun2</span>()) y = <span class="built_in">fun2</span>();</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(x).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">typeid</span></span>(y).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="C-内存模型"><a href="#C-内存模型" class="headerlink" title="C++内存模型"></a>C++内存模型</h2><ol>
<li>Stack(栈)  编译器自动分配释放 （局部变量(内嵌函数内的变量)、形参这些在栈里）</li>
<li>Heap(堆)  由程序员分配释放，new delete 也许程序结束后操作系统os自动回收    </li>
<li>Global/static(全局区/静态区） 生命周期是从程序开始前到程序结束。 全局变量和静态变量是放在一起的，可以简单认为是程序启动全局/静态变量就在此处。  程序结束后释放。    </li>
<li>Constant (常量区) 可以简单理解为所有常量都放一起  该区域内容不可以修改  </li>
</ol>
<p>栈从高地址向低地址生成，堆反过来。  这样为了节省空间。   </p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>常量是程序中一块数据，这个数据一旦声明后就不能被修改了。常量初始化的时候必须赋值。<br>const char* STR = “Hello”  必须得这么写因为涉及到字符串指针，这个必须得const。<br>符号常量(包括枚举值)必须全部大写并用下划线分隔单词  例如：MAX_ITERATIONS, COLOR_RED, PI     </p>
<pre><code>const int y = &#123; 42 &#125;;  // 这个在C++中叫做常量，在编译期就确定了值
const int z = x;       // z也是常量，在运行期才能确定值。
y = 42 + 1;            // 不允许
z ++;                  // 不允许
</code></pre>
<h2 id="常量指针-指针常量"><a href="#常量指针-指针常量" class="headerlink" title="常量指针 指针常量"></a>常量指针 指针常量</h2><p>我们把指针放到一个变量里面，就是指针变量，意思就是指针指的是一个常量，指针本身是个变量；我们把指针放到常量中，就是指针常量；<br>顾名思义，常量指针指针 所指的内容不可以通过指针间接应用来改变。常量指针可以定义的时候不初始化！这和别的常量设置不一样。因为常量指针是指向的内容是常量，它本身可以额随意改变指向哪个常量，是个变量，所以不用上来初始化！常量指针中的指针是变量。        </p>
<pre><code>int* p; 则p可以存放一个int型变量的地址    
float* q;
const int x = 1;

const int* p1;  //你把const int 看成一个东西  
 
p1 = &amp;x;      //指针 p1的类型是  (const int*) 如果你把一个变量指针没有const int 就指向一个const过的常量，就会出现错误。   

*p1 = 10;     // Error!

char* s1 = &quot;Hello&quot;;     // Error!

const char* s2 = &quot;Hello&quot;;     // Correct!
</code></pre>
<p> Pointer Constant (指针常量)<br>“指针常量”的含义是：指针本身的内容是个常量，不可以改变</p>
<pre><code>int x = 1, y = 1;

int* const p2 = &amp;x; //常量 p2的类型是  (int*) 这里const直接修饰p2就是p2 是个常量

*p2 = 10;     // Okay! à x=10

p2 = &amp;y;      // Error! p2 is a constant
</code></pre>
<p>说白了我们注意一下，你修改后，到底变了啥 上面这个 *p2 = 10其实是修改了 x =10 x不是常量，当然可以。数组名就是一个指针常量。     </p>
<p>const int * x;int * const y ;  在前先读，在前不变,* （指针）和 const（常量） 谁在前先读谁 ；* 代表被指的数据，名字代表指针地址, const在谁前面谁就不允许改变。</p>
<h2 id="声明类型"><a href="#声明类型" class="headerlink" title="声明类型"></a>声明类型</h2><p>C++11中为 using 关键字赋予了一个类型声明的新功能  这里注意只能用于类型，不是所有的都已using来替换  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> identifier = type-id</span><br></pre></td></tr></table></figure>
<pre><code>const unsigned long int * p;

const unsigned long int * q;

const unsigned long int * r;
// 等价于
using ConstPointer = const unsigned long int *;
ConstPointer p;
ConstPointer q;
ConstPointer r;   
</code></pre>
<p>代表类型的名字必须首字母大写并且其它字母大小写混合,例如：Line, SavingsAccount<br>#define这种代表一种预处理的指示符，用来定义”宏”，编译器不做类型检查。结尾无分号。#读作sharp。宏就是作为替换的。   </p>
<pre><code>#define macroname something
</code></pre>
<h2 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h2><p>sizeof 是一个关键字，它是一个编译时运算符，用于判断变量或数据类型的字节大小。</p>
<pre><code>sizeof (data type)
</code></pre>
<h2 id="局部变量-全局变量"><a href="#局部变量-全局变量" class="headerlink" title="局部变量/全局变量"></a>局部变量/全局变量</h2><p>局部变量可在函数体内任意位置定义，从定义位置到块尾。<br>如果外部代码块与其内嵌代码块有同名的变量，那么会产生同名覆盖这种现象。此时要遵循“就近原则”来判断哪个同名变量起作用<br>一元作用域解析运算符，局部变量名和全局变量名相同的时候，可以用 :: 访问全局变量</p>
<pre><code>::globalVariable
</code></pre>
<p>这个只针对是全局变量  如果是局部变量或常量 则没用  </p>
<h2 id="重载函数-overloading-functions"><a href="#重载函数-overloading-functions" class="headerlink" title="重载函数 overloading functions"></a>重载函数 overloading functions</h2><p>重载函数是在同一个名字空间中存在两个或者多个具有相同名字的函数所构成的语法现象。<br>重载函数就是名字完全一样，但是参数类型、个数或者顺序不一样的函数。重载函数主要用来对付不同类型的数据。<br>调用重载函数的语句，是由编译器在编译期确定的。编译器判断某个函数调用语句所对应的重载函数时，判断依据是函数参数的<strong>类型、个数和次序</strong>。如果编译器无法判定，就会报告二义性错误。<br>重载函数的判断是编译期间发生的。    </p>
<pre><code>// 这里就会报2义的错误，无法确定把哪个数字变成浮点数
  int maxNumber(int num1, double num2) &#123;
if (num1 &gt; num2)
    return num1;
else
    return num2;
&#125;
double maxNumber(double nums1, int num2) &#123;
    if (num1 &gt; num2)
        return num1;
    else
        return num2;
&#125;
int main() &#123;
    cout &lt;&lt; maxNumber(1, 2) &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>函数的参数可以指定默认值。指定默认值时，要<strong>保证带有默认值的参数要位于函数参数列表的右侧</strong>。调用带有默认参数值的函数时，如果不指定带有默认值的参数，则该参数自动被赋为默认值，需要调用的时候参数前置。函数如果需要重载，不可以重定义默认参数。     </p>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>普通函数的优缺点Pros(优点): 易读易维护 Cons (缺点): 调用时有开销<br>函数调用时：参数及部分CPU寄存器的内容进栈，控制流跳转<br>函数返回时：返回值及寄存器值出栈，控制流跳转<br>使用内联函数，目的：减小函数调用开销，方法：代码插入到调用处，结果：导致程序变大<br>定义函数时，在函数类型前面加上 inline 关键字，则该函数就成为内联函数。一般而言，内联函数的声明和定义都在一起。我们很少将内联函数的声明和定义分开编写。<br>内联函数的使用，编译器在遇到内联函数的调用时，会将内联函数的函数体展开到调用位置，从而避免函数调用的开销。一般来说，内联函数只有在需要考虑程序运行性能的环境中才使用。程序员所用的 inline 关键字，只是对编译器的一个请求。内联函数是否展开，是由编译器决定的。<br>使用频繁调用的段函数，不适用长调用的长函数。<br>内联函数是一种机制，编译机制， inline是对编译器的请求，而不是命令。大部分编译器并不把带有循环、递归、静态变量等或代码较多的函数进行内敛编译。      </p>
<h2 id="string头文件"><a href="#string头文件" class="headerlink" title="string头文件"></a>string头文件</h2><p>先调用#include <string><br>std命名空间里有  std::to_string(i)函数可以把i变成字符串，就可以用+来操作了   </p>
<pre><code>cout &lt;&lt; std::to_string(x) + &quot;++++&quot; &lt;&lt; endl;      
</code></pre>
<h2 id="for-基于范围循环"><a href="#for-基于范围循环" class="headerlink" title="for 基于范围循环"></a>for 基于范围循环</h2><p> 基于范围的for循环的语法</p>
<pre><code>for( 元素名变量 : 广义集合) &#123; 循环体 &#125;
</code></pre>
<p>a.“元素名变量”可以是引用类型，以便直接修改集合元素的值；如果不是应用类型，那么这里就是用同一个地址不断去复制广义集合地址里的元素内容到同一个地址上来操作。<br>b. “元素名变量”也可以是const类型，避免循环体修改元素的值<br>c. 其中“广义集合”就是“Range（范围）”，是一些元素组成的一个整体  </p>
<h2 id="vs-整段注释和取消注释"><a href="#vs-整段注释和取消注释" class="headerlink" title="vs 整段注释和取消注释"></a>vs 整段注释和取消注释</h2><p>选中，然后 注释：先CTRL+K，然后CTRL+C   取消注释： 先CTRL+K，然后CTRL+U   </p>
<h2 id="初始化器的if语句-C-17"><a href="#初始化器的if语句-C-17" class="headerlink" title="初始化器的if语句 C++17"></a>初始化器的if语句 C++17</h2><p>这种设定即相当于for循环里定义迭代对象i一样，主要功能就是防止同名变量作用域影响。<br>注意这是C++17的新特性，得在C++编译器标志调整到std:c++17这个在项目属性 C++那栏里。<br>如果写在里面则作用域只限于if语句   </p>
<pre><code>int main() &#123;

if (auto x = foo(42); x &gt; 40) &#123;
    cout &lt;&lt; x &lt;&lt; endl;
&#125;
else &#123;
    cout &lt;&lt; &quot;haha&quot; &lt;&lt; endl;
&#125;
return 0;
&#125;

int main() &#123;
int score = 82;
switch (auto x = score; x) &#123;
    case 10:
    case 9:
        cout &lt;&lt; &quot;A &quot; &lt;&lt; endl;
        break;
    default:
        cout &lt;&lt; &quot;D&quot; &lt;&lt; endl;
    &#125;
&#125;
</code></pre>
<h2 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h2><p>对象是一个现实世界中一个独一无二的实体<br>Features of OO (面向对象的特征)可以这么记，封装抽象 继承多态   </p>
<p>(1)     Abstraction      (抽象)</p>
<p>(2)     Polymorphism   (多态)</p>
<p>(3)     Inheritance       (继承)</p>
<p>(4)     Encapsulation   (封装)</p>
<p>我们将这四个单词的首字母放在一起： A PIE  </p>
<p>An object is an instance of a class (对象是类的实例)<br>A class includes (类包含)：</p>
<p>(1)     data fields，defined by variables(由变量定义的数据域)</p>
<p>(2)     Behaviors， defined by  functions(由函数定义的行为)</p>
<p>对象构成：一个独一无二的名字 unique identity； 状态 state； 行为behaviors 行为   </p>
<p>对象 = 数据 + 方法；<br>A class has two special types of functions (类中有两种特殊的函数)   </p>
<p>(1)     constructors : which are invoked automatically when constructing objects from the class. (构造函数：在创建对象时被自动调用)</p>
<p>(2)     destructors : : which are invoked automatically when the object is destroyed. (析构函数：在对象被销毁时被自动调用)<br>析构/构造函数简写：ctor  和  dtor   </p>
<h2 id="构造函数-constructors"><a href="#构造函数-constructors" class="headerlink" title="构造函数 constructors"></a>构造函数 constructors</h2><p>Ctors的特点:</p>
<p>(1)    Automatic invocation(自动调用)</p>
<p>(2)    Has the same name as the defining class (与类同名)</p>
<p>(3)    NO return value (including “void”); (无返回值)</p>
<p>(4)    Can be overloaded (可重载)</p>
<p>(5)    May have no arguments (可不带参数)   </p>
<p>构造函数没有返回值 void都不行<br>类可以不声明构造函数   这时候编译器会自动提供一个带有空函数体的无参构造函数default constructor也可以自己写一个 = default    </p>
<p>比如我定义一个类：<br>    class Circle {<br>    public:<br>        float radius;<br>        Circle() {<br>            radius = 1;<br>        }      // 也可以直接写成  Circle() = default；<br>        Circle(float newRadius) {<br>            radius = newRadius;<br>        }<br>        float getArea() {<br>            return radius * radius * 3.14159;<br>        }<br>    };  \ 类声明注意这里一定得分号结束 </p>
<pre><code>class Circle &#123;
public:  
    float radius;
    Circle(float newRadius = 1) &#123;
        radius = newRadius;
    &#125;
    float getArea() &#123;
        return radius * radius * 3.14159;
    &#125;
&#125;;  \\ 类声明注意这里一定得分号结束 
</code></pre>
<p>那么一个是无参的构造函数 一个是有参的构造函数相当于我们python的 </p>
<pre><code>def __init__(self, newRadius = 1.0):
    self.newRadius = newRadius;
</code></pre>
<p>我们调用的时候可以这样调用</p>
<pre><code>Circle circle1&#123;5.5&#125;;  // 多用统一初始化 会自动窄化检查  ;(5.5)也没有错
Circle circle2;
</code></pre>
<p>对象访问运算符 dot operator (.)<br>类的一个特征是封装，public和private就是实现这两个目的的，用户代码外也就是类的外边， 如果要访问类里面，只能访问public里的数据，和方法，而不能方位private。而private里面的是类私有的数据和方法，私有的成员，只能被类的成员和友元访问，类的另一个特征是继承，protected就是实现这一个目的的，protected成员可以被派生类对象访问，不能被类外访问。    </p>
<p>class is a type.类是一个数据类型。   </p>
<pre><code>Circle c3&#123;5.5&#125;; // 直接列表初始化,调有参ctor 建议这么赋值

Circle c4 = &#123;5.5&#125;; // 拷贝列表初始化,调ctor 这么写也不错  是拷贝列表初始化
</code></pre>
<h2 id="类的拷贝"><a href="#类的拷贝" class="headerlink" title="类的拷贝"></a>类的拷贝</h2><p>Memberwise Copy (成员拷贝)</p>
<p>(1)     use the assignment operator( 使用赋值运算符) ：  =</p>
<p>(2)     By default, each data field of one object is copied to its counterpart in the other object. ( 默认情况下，对象中的每个数据域都被拷贝到另一对象的对应部分)函数不拷贝，因为函数在编译的时候变成一堆二进制代码，没什么可拷贝的。  </p>
<pre><code>circle2 = circle1;
</code></pre>
<p>(1)     将circle1 的radius 拷贝到circle2 中</p>
<p>(2)     拷贝后：circle1  和 circle2  是两个不同的对象，但是半径的值是相同的。( 但是各自有一个radius 成员变量)     </p>
<p>C++11这个class和C的struct功能基本一样，只是struct没有关键字public因为他默认类内所有数据都是公有的。   </p>
<p>编码规范： 类名首字母必须大写     </p>
<h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><p>有时需要创建一个只用一次的对象 ，这种不命名的对象叫做匿名对象</p>
<h2 id="局部类、嵌套类"><a href="#局部类、嵌套类" class="headerlink" title="局部类、嵌套类"></a>局部类、嵌套类</h2><p>函数内定义的类是局部类，只有函数内可以调用和使用这个类的类型，嵌套类是类里声明一个类，嵌套结构。也是只有这个类里才可以调用和访问这个类型。    </p>
<h2 id="声明和实现分离"><a href="#声明和实现分离" class="headerlink" title="声明和实现分离"></a>声明和实现分离</h2><p>C++类的声明放在 .h里 描述类的结构； .cpp里存放类的实现 描述类方法的实现   </p>
<pre><code>FunctionType ClassName::FunctionName(Arguments)&#123;//...&#125;   
</code></pre>
<p>二元作用域解析运算符。当函数在类声明中实现，它自动成为内联函数 但不需要写inline关键字。 声明和实现的分离不涉及数据，只涉及函数。     </p>
<pre><code>class A &#123;
public:
    A();
    A(double various);
    double f1();
    double f2();
&#125;;
A::A() &#123;
    // blah
&#125;
A::A(double various) &#123;
    // blah
&#125;
double A::f2() &#123;
    // blah blah
&#125;
inline double A::f1() &#123;
    //blah blah
&#125;
</code></pre>
<p>然后把声明创建一个头文件，然后.h 存在里面 后面调用 #include “.h”<br>存放类声明的头文件被包含多次，编译器可能会报告类重复声明的错误   </p>
<h2 id="避免头文件多次被包含"><a href="#避免头文件多次被包含" class="headerlink" title="避免头文件多次被包含"></a>避免头文件多次被包含</h2><h2 id="对象指针"><a href="#对象指针" class="headerlink" title="对象指针"></a>对象指针</h2><p>可以用箭头运算符 指针直接访问对象成员</p>
<pre><code>int main() &#123;
    Circle circle1&#123;12.9&#125;;
    auto* pCircle = &amp;circle1;
    cout &lt;&lt; &quot;The radius is &quot; &lt;&lt; (*pCircle).radius &lt;&lt; endl;  // 如果是简引用方式，记得加括号，因为后面.操作符优先级比*高
    cout &lt;&lt; &quot;The Area is &quot; &lt;&lt; (*pCircle).getArea() &lt;&lt; endl;
    *pCircle = 10.;
    cout &lt;&lt; &quot;The radius is &quot; &lt;&lt; (*pCircle).radius &lt;&lt; endl;
    cout &lt;&lt; &quot;The Area is &quot; &lt;&lt; (*pCircle).getArea() &lt;&lt; endl; 
    cout &lt;&lt; &quot;The radius is &quot; &lt;&lt; pCircle-&gt;radius &lt;&lt; endl;
    cout &lt;&lt; &quot;The Area is &quot; &lt;&lt; pCircle-&gt;getArea() &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p>为了保留对象，可以用new在堆上生成对象，用delete释放。因为在函数中声明生成的对象都会在栈中，如果函数return了，计算机会自动释放掉栈中的对象。   </p>
<pre><code>Circle* pCirlce2 = new Circle&#123; 5.9 &#125;;
delete pCircle2;
</code></pre>
<p>类数组  类不就是类型 和 int [] 数组有啥区别呢，就这么理解就好了  存放多个对象的连续排列的数组   </p>
<pre><code>int main() &#123;
auto pCircle2 = new Circle&#123; 5.9 &#125;; //自动判定指针类型
Circle c3&#123; 2.0 &#125;;
Circle* c2 = &amp;c3;
Circle* pCircle1 = new Circle[3]&#123; 1.0, 2.0, 3.0 &#125;;
for (int i = 0; i &lt; 3; i++) &#123;
    cout &lt;&lt; pCircle1[i].getArea() &lt;&lt; endl; //这里注意如果是用(*pCircle++).getArea也可以实现访问 但是指针地址结束后指向最后一个地址后，后面我在释放空间的时候，就麻烦了，还必须得吧指针倒回去不合适啊。
&#125;

delete []pCircle1;
delete pCircle2;

return 0;
&#125;
</code></pre>
<h2 id="对象数组-array-of-objects"><a href="#对象数组-array-of-objects" class="headerlink" title="对象数组 array of objects"></a>对象数组 array of objects</h2><p>(1)     声明方式1</p>
<pre><code>Classname objectname[number];
</code></pre>
<p>(2)     声明方式2</p>
<p>用匿名对象构成的列表初始化数组</p>
<pre><code>Circle ca2[3] = &#123; // 注意：不可以写成： auto ca2[3]=     因为声明数组时不能用auto

Circle&#123;3&#125;, 

Circle&#123; &#125;, 

Circle&#123;5&#125; &#125;;  
</code></pre>
<p>(3)     声明方式3</p>
<p>用C++11列表初始化，列表成员为隐式构造的匿名对象</p>
<pre><code>Circle ca3[3] &#123; 3.1, &#123;&#125;, 5 &#125;;

Circle ca4[3] = &#123; 3.1, &#123;&#125;, 5 &#125;; 
</code></pre>
<p>(4)     声明方式4</p>
<p>用new在堆区生成对象数组</p>
<pre><code>auto* p1 = new Circle[3];
auto p2 = new Circle[3]&#123; 3.1, &#123;&#125;, 5 &#125;;
delete [] p1;
delete [] p2;
p1 = p2 = nullptr;
</code></pre>
<h2 id="void"><a href="#void" class="headerlink" title="void"></a>void</h2><p>当函数不需要返回值值时，必须使用void限定，这就是我们所说的第一种情况。例如：void func（int a,char *b）。<br>当函数不允许接受参数时，必须使用void限定，这就是我们所说的第二种情况。例如：int func(void)。    </p>
<p>void 指针可以指向任意类型的数据，就是说可以用任意类型的指针对void 指针对 void 指针赋值。</p>
<h2 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h2><pre><code>int arra[] &#123; 1,2,4,7,3,5,6,8 &#125;;
cout &lt;&lt; sizeof(arra) / sizeof(arra[0]) &lt;&lt; endl;
</code></pre>
<h2 id="对象做为函数参数"><a href="#对象做为函数参数" class="headerlink" title="对象做为函数参数"></a>对象做为函数参数</h2><p>三种 传对象本身(相当于复制了一个对象给形参，对形参改变不影响传入的那个对象)，传对象的引用（会改变传入对象本身），传指针也就是对象地址。   </p>
<pre><code>// 传值 传的是整个对象的值 
void print(Circle c) &#123;
    cout &lt;&lt; c.getArea() &lt;&lt; endl;
&#125;

int main()
&#123;
    Circle mycircle&#123; 5.0 &#125;;
    print(mycircle);
    return 0;
&#125;

// 传引用 
void print(Circle&amp; c) &#123;
c.radius = 10;
cout &lt;&lt; c.getArea() &lt;&lt; endl;
&#125;

int main()
&#123;
    Circle mycircle&#123; 5.0 &#125;;
    print(mycircle);
    cout &lt;&lt; mycircle.getArea() &lt;&lt; endl;
    return 0;
&#125;

// 传指针 本质也是传值 不过是穿的是地址的值
void print(Circle* c) &#123;
cout &lt;&lt; (*c).getArea() &lt;&lt; endl;
&#125;

int main()
&#123;
    Circle mycircle&#123; 5.0 &#125;;
    print(&amp;mycircle);
    return 0;
&#125;
</code></pre>
<h2 id="对象作为函数返回值"><a href="#对象作为函数返回值" class="headerlink" title="对象作为函数返回值"></a>对象作为函数返回值</h2><pre><code>// 传对象
// class Object &#123; ... &#125;;

Object f ( /*函数形参*/ )&#123;

  // Do something

  return Object(args);

&#125;

// main() &#123;

Object o = f ( /*实参*/ );

f( /*实参*/ ).memberFunction();
</code></pre>
<p>对象指针也可以做为返回值，但是注意不要再堆中新生成一个指针，这样后面很可能在函数调用后忘了delete，这是一个邪恶不合格的写法。   </p>
<pre><code>// class Object &#123; ... &#125;;

Object* f ( /*函数形参*/ )&#123;
    Object* o = new Object(args) // 这是“邪恶”的用法，不要这样做

  // Do something

  return o;

&#125;

// main() &#123;

Object* o = f ( /*实参*/ );

f( /*实参*/ )-&gt;memberFunction();

// 记得要delete o
</code></pre>
<p>正确的对象指针传递是：</p>
<pre><code>// class Object &#123; ... &#125;;

Object* f ( Object* p, /*其它形参*/ )&#123;

  // Do something

  return p;

&#125;

// main() &#123;

Object* o = f ( /*实参*/ );

// 不应该delete o 因为这就是一个局部指针变量。
</code></pre>
<p>对象引用也是：</p>
<pre><code>// class Object &#123; ... &#125;;

Object&amp; f ( /*函数形参*/ )&#123;

  Object o &#123;args&#125;;

  // Do something

  return o;  //这是邪恶的用法

&#125;


// 正确做法  
// class Object &#123; ... &#125;;

Object&amp; f ( Object&amp; p, /*其它形参*/ )&#123;

  // Do something

  return p;

&#125;

// main() &#123;

auto&amp; o = f ( /*实参*/ );

f( /*实参*/ ).memberFunction();  
</code></pre>
<p>在为函数传参时， 何时用引用，何时用指针呢？</p>
<p>一般来说，能用引用尽量不用指针。引用更加直观，更少出现意外的疏忽导致的错误。</p>
<p>指针可以有二重、三重之分，比引用更加灵活。有些情况下，例如使用 new 运算符，只能用指针。     </p>
<h2 id="抽象和封装"><a href="#抽象和封装" class="headerlink" title="抽象和封装"></a>抽象和封装</h2><p>抽象: 提炼目标系统中我们关心的核心要素的过程<br>封装: 绑定数据和函数的语言构造块，以及限制访问目标对象的内容的手段<br>数据域采用public的形式有2个问题</p>
<p>(1)     First, data may be tampered. ( 数据会被类外的方法篡改)</p>
<p>(2)     Second, it makes the class difficult to maintain and vulnerable to bugs. ( 使得类难于维护，易出现bug)  </p>
<p>To read/write private data, we need get/set function (为读写私有数据，需要get/set函数)<br>(1)     get function  is referred to as a getter (获取器，or accessor),</p>
<p>(2)     set function is referred to as a setter (设置器，or mutator).</p>
<p>设置getter和setter函数的时候 函数名通常根据编码规范来写，get/set +变量名（大写变量名的第一个字母 ）如果是Bool类型 get写成   is+变量名 。而且既然使用来给外部访问private里的数据的，所以getter 和 setter都必须得放在public里。   </p>
<h2 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h2><p>类里的所有函数都可以访问类里的数据成员无论private 或 public。<br>类里的局部变量和数据域同名，则还是符合就近原则，函数屏蔽。<br>this 指针是一个内建指针，不需要声明和赋值。   this指向当前对象的。  感觉和python的self一个意思。   </p>
<pre><code>class Circle &#123;
public:
    Circle();
    Circle(float radius) &#123;
        this-&gt;radius = radius;
    &#125;
private:
    float radius;
public:
    void setRadius(float radius) &#123;
        this-&gt;radius = radius;
    &#125;
&#125;;  
</code></pre>
<p>this 的类型是一个 classname *const 是一个指针常量<br>还有个避免重名的办法就是，函数的形参如果要同名，就把形参改成 名称加下划线后缀 radius_    </p>
<h2 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h2><p>类里的数据初始化有些不一样 其实比较扯淡。。。估计以后会修改 完全没必要  </p>
<pre><code>int a[] = &#123;1,2,3&#125;; // 错误：数组类型成员不能自动推断大小  这个在函数里就没这个问题 
int a(1); // 错误：这个也是只是在类里编译不通过  
</code></pre>
<p>C++11是允许就地初始化的     </p>
<h2 id="构造函数初始化"><a href="#构造函数初始化" class="headerlink" title="构造函数初始化"></a>构造函数初始化</h2><p>构造函数的函数体执行之前，类中的数据成员必须完成初始化<br>构造函数可以用以下形式初始化  </p>
<pre><code>classname (parameterList)
    ：dataField1&#123;value1&#125;， dataField2&#123;value2&#125;
&#123;
&#125;
</code></pre>
<p>具体划一下就是</p>
<pre><code>Circle::Circle()&#123;
    radius = 1;
&#125;
//原来这种构造函数的初始化类型可以写成以下这种

Circle::Circle() : radius&#123;1&#125; &#123;

&#125;
</code></pre>
<p>而且你在初始化一个类的时候，如果这类构造函数构造结构里有别的类的对象，那么就要在构造体之前完成把内嵌对象构造完成，就需要这么个结构  </p>
<pre><code>class Time &#123; /* Code omitted */ &#125;

class Action &#123;

public:

  Action(int hour, int minute, int second) &#123;

    time = Time(hour, minute, second); //time对象应该在构造函数体之前构造完成

  &#125;

 

private:

  Time time;

&#125;; 
</code></pre>
<p>这个就要修改以下改成  </p>
<pre><code>class Time &#123; /* Code omitted */ &#125;

class Action &#123;

public:

  Action(int hour, int minute, int second) ：Time time&#123;hour, minute, second&#125;&#123;

  
  &#125;

 

private:

  Time time;

&#125;; 
</code></pre>
<p>如果类的数据域里有别的类，需要在类构造函数体之前完成数据域的初始化，也就是其他类的对象的初始化，这个时候其他类的构造函数必须得能够使用，如果没有写，系统不会默认生成那个default的空构造函数，得手动自己写。    </p>
<pre><code>Classname() = default；
Classname() = delete;  //强制不生成空构造函数。  
</code></pre>
<h2 id="类中成员初始化次序"><a href="#类中成员初始化次序" class="headerlink" title="类中成员初始化次序"></a>类中成员初始化次序</h2><p>How to Initialize the Object/Class Members? (如何初始化对象/类成员)</p>
<p>Default Member Initialization (就地初始化)</p>
<p>Constructor Initialization List (构造函数初始化列表)</p>
<p>Assign Values to the members in Ctor Body (在构造函数体中为成员赋值)。注意，这个不是初始化，而是赋值。</p>
<p>执行次序： 就地初始化 à Ctor 初始化列表 à  在Ctor 函数体中为成员赋值</p>
<p>哪个起作用（初始化/赋值优先级）： 在Ctor 函数体中为成员赋值 &gt; Ctor 初始化列表  &gt;  就地初始化   </p>
<p>Default Member Initializer is Ignored(就地初始化被忽略)</p>
<p>If a member has a default member initializer and also appears in the member initialization list in a constructor, the default member initializer is ignored. (若一个成员同时有就地初始化和构造函数列表初始化，则就地初始化语句被忽略不执行)</p>
<pre><code>#include &lt;iostream&gt;

int x = 0;

struct S &#123;

  int n = ++x;            // default initializer

  S() &#123; &#125;                 // 使用就地初始化(default initializer)

  S(int arg) : n(arg) &#123; &#125; // 使用成员初始化列表

&#125;;

int main() &#123;

  std::cout &lt;&lt; x &lt;&lt; &#39;\n&#39;; // 输出 0

  S s1;

  std::cout &lt;&lt; x &lt;&lt; &#39;\n&#39;; // 输出 1 (default initializer ran)

  S s2(7);

  std::cout &lt;&lt; x &lt;&lt; &#39;\n&#39;; // 输出 1 (default initializer did not run)

&#125;
</code></pre>
<h2 id="C-字符串类-string"><a href="#C-字符串类-string" class="headerlink" title="C++字符串类 string"></a>C++字符串类 string</h2><p>C++ 使用string类处理字符串<br>记得#include <string><br>很多string函数接受两个数字参数 index, n<br>index是从index位置开始<br>n是多少个字符<br>创建 string 对象<br>Create an empty string using string’s no-arg constructor(用无参构造函数创建一个空字串):</p>
<pre><code>string newString;
</code></pre>
<p>Create a string object from a string value or from an array of characters (由一个字符串常量或字符串数组创建string对象) :</p>
<pre><code>string message&#123; &quot;Aloha World!&quot; &#125;;

char charArray[] = &#123;&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\0&#39;&#125;; //可以没有‘/0’会自动加

string message1&#123; charArray &#125;;
</code></pre>
<p>Appending a String (追加字符串) 不仅追加改变了str1 而且式子表达式还返回str1</p>
<p>append</p>
<pre><code>string s1&#123; &quot;Welcome&quot; &#125;;

s1.append( &quot; to C++&quot; ); // appends &quot; to C++&quot; to s1

cout &lt;&lt; s1 &lt;&lt; endl; // s1 now becomes Welcome to C++

string s2&#123; &quot;Welcome&quot; &#125;;

s2.append( &quot; to C and C++&quot;, 3, 2 ); // appends &quot; C&quot; to s2

cout &lt;&lt; s2 &lt;&lt; endl; // s2 now becomes Welcome C

string s3&#123; &quot;Welcome&quot; &#125;;

s3.append( &quot; to C and C++&quot;, 5); // appends &quot; to C&quot; to s3

cout &lt;&lt; s3 &lt;&lt; endl; // s3 now becomes Welcome to C

string s4&#123; &quot;Welcome&quot; &#125;; 

s4.append( 4, &#39;G&#39; ); // appends &quot;GGGG&quot; to s4  注意这里只能加单字符 不能加字符串  

cout &lt;&lt; s4 &lt;&lt; endl; // s4 now becomes WelcomeGGGG
</code></pre>
<p>Assigning a String (为字符串赋值) 不仅追加改变了str1 而且式子表达式还返回str1</p>
<pre><code>string s1&#123; &quot;Welcome&quot; &#125;;

s1.assign( &quot;Dallas&quot; ); // assigns &quot;Dallas&quot; to s1

cout &lt;&lt; s1 &lt;&lt; endl; // s1 now becomes Dallas

string s2&#123; &quot;Welcome&quot; &#125;;

s2.assign( &quot;Dallas, Texas&quot;, 1, 3 ); // assigns &quot;all&quot; to s2

cout &lt;&lt; s2 &lt;&lt; endl; // s2 now becomes all

string s3&#123; &quot;Welcome&quot; &#125;;

s3.assign( &quot;Dallas, Texas&quot;, 6 ); // assigns &quot;Dallas&quot; to s3

cout &lt;&lt; s3 &lt;&lt; endl; // s3 now becomes Dallas

string s4&#123; &quot;Welcome&quot; &#125;;

s4.assign( 4, &#39;G&#39; ); // assigns &quot;GGGG&quot; to s4  注意这里只能加单字符 不能加字符串  

cout &lt;&lt; s4 &lt;&lt; endl; // s4 now becomes GGGG 
</code></pre>
<p>(1)     at(index):  返回当前字符串中index位置的字符</p>
<p>(2)     clear(): 清空字符串</p>
<p>(3)     erase(index, n):  删除字符串从index开始的n个字符</p>
<p>(4)     empty(): 检测字符串是否为空 返回bool</p>
<pre><code>string s1&#123; &quot;Welcome&quot; &#125;;

cout &lt;&lt; s1.at(3) &lt;&lt; endl; // s1.at(3) returns c

cout &lt;&lt; s1.erase(2, 3) &lt;&lt; endl; // s1 is now Weme

cout &lt;&lt; s1.erase(1);// s1 is now  W

s1.clear(); // s1 is now empty

cout &lt;&lt; s1.empty() &lt;&lt; endl; // s1.empty returns 1 (means true)
</code></pre>
<p> Comparing Strings (比较字符串)<br>compare() 函数用于比较两个字符串。它与C语言中的 strcmp() 函数很像。</p>
<pre><code>string s1&#123; &quot;Welcome&quot; &#125;;

string s2&#123; &quot;Welcomg&quot; &#125;;

cout &lt;&lt; s1.compare(s2) &lt;&lt; endl; // returns -1 if s1 &lt; s2

cout &lt;&lt; s2.compare(s1) &lt;&lt; endl; // returns 1 if s1 &gt; s2

cout &lt;&lt; s1.compare(&quot;Welcome&quot;) &lt;&lt; endl; // returns 0  
</code></pre>
<p>Obtaining Substrings (获取子串)</p>
<p>at() 函数用于获取一个单独的字符；</p>
<p>substr() 函数则可以获取一个子串</p>
<pre><code>string s1&#123; &quot;Welcome&quot; &#125;;

cout &lt;&lt; s1.substr(0, 1) &lt;&lt; endl; // returns W；  从0号位置开始的1个字符

cout &lt;&lt; s1.substr(3) &lt;&lt; endl; // returns come；  从3号位置直到末尾的子串

cout &lt;&lt; s1.substr(3, 3) &lt;&lt; endl; // returns com；从3号位置开始的3个字符
</code></pre>
<p>Searching in a String (搜索字符串)<br>find() 函数可以在一个字符串中搜索一个子串或者一个字符 </p>
<pre><code>string s1&#123; &quot;Welcome to C++&quot; &#125;;

cout &lt;&lt; s1.find(&quot;co&quot;) &lt;&lt; endl; // returns 3； 返回子串出现的第一个位置

cout &lt;&lt; s1.find(&quot;co&quot;, 6) &lt;&lt; endl; // returns 一个奇怪的数很大 从6号位置开始查找子串出现的第一个位置

cout &lt;&lt; s1.find(&#39;o&#39;) &lt;&lt; endl; // returns 4    返回字符出现的第一个位置

cout &lt;&lt; s1.find(&#39;o&#39;, 6) &lt;&lt; endl; // returns 9   从6号位置开始查找字符出现的第一个位置  
</code></pre>
<p>Inserting and Replacing Strings (插入和替换字符串)<br>insert() : 将某个字符/字符串插入到当前字符串的某个位置<br>replace() 将本字串从某个位置开始的一些字符替换为其它内容   </p>
<pre><code>string s1(&quot;Welcome to C++&quot;);

s1.insert(11, &quot;Java and &quot;); // 超过右边界会报错 也就是在s1最后一个字符后面的后面插入会报错。

cout &lt;&lt; s1 &lt;&lt; endl; // s1 becomes Welcome to Java and C++

string s2&#123; &quot;AA&quot; &#125;;

s2.insert(1, 4, &#39;B&#39;); //在1号位置处连续插入4个相同字符

cout &lt;&lt; s2 &lt;&lt; endl; // s2 becomes to ABBBBA

string s3&#123; &quot;Welcome to Java&quot; &#125;;

s3.replace(11, 4, &quot;C++&quot;); //从11号位置开始向后的4个字符替换掉。注意&#39;\0&#39;

cout &lt;&lt; s3 &lt;&lt; endl; // returns Welcome to C++ 
</code></pre>
<p>此外 string 提供字符串操作符以供使用，  </p>
<p>[ ] 用数组下标运算符访问字符串中的字符  </p>
<p>= 将一个字符串的内容复制到另一个字符串</p>
<ul>
<li>连接两个字符串得到一个新串</li>
</ul>
<p>+= 将一个字符串追加到另一个字符串末尾</p>
<p>&lt;&lt;  将一个字符串插入一个流</p>
<blockquote>
<blockquote>
<p> 从一个流提取一个字符串，分界符为空格或者空结束符</p>
</blockquote>
</blockquote>
<p>==, !=, &lt;,   &lt;=, &gt;, &gt;=  用于字符串比较</p>
<p>删除收尾的空格符：</p>
<pre><code>s.erase(0, s.find_first_not_of(&quot; \t\n\r&quot;));
s.erase(s.find_last_not_of(&quot; \t\r\n&quot;) + 1);
</code></pre>
<p>字符串数字和整数数字之间的转换</p>
<pre><code>在std::sto（String TO）   
stod 转为double
stof 转为float
stoul 转为unsigned long
stoi 转为int
stol 转为long
stoll 转为 long long
stold 转为 long double
</code></pre>
<h2 id="C-风格数组-array"><a href="#C-风格数组-array" class="headerlink" title="C++ 风格数组 array"></a>C++ 风格数组 array</h2><p>需要包含头文件 #include <array><br>C Style Array (C++ raw array，也叫做C++原生数组)</p>
<p>int arr[ ] = { 1, 2, 3 };</p>
<p>arr 可能会退化为指针：void f(int a[]) { std::cout &lt;&lt; sizeof(a)/sizeof(a[0]); }</p>
<p>arr 不知道自己的大小： sizeof(arr)/sizeof(arr[0])</p>
<p>两个数组之间无法直接赋值: array1 = array2;</p>
<p>不能自动推导类型：auto a1[] = {1,2,3};</p>
<p>C++ Style Array</p>
<p>是一个容器类，所以有迭代器（可以认为是一种用于访问成员的高级指针）</p>
<p> 可直接赋值</p>
<p> 知道自己大小：size()</p>
<p> 能和另一个数组交换内容：swap() 这个如果两个数组大小 种类任何不同都无法实现交换   </p>
<p> 能以指定值填充自己: fill()</p>
<p> 取某个位置的元素( 做越界检查) ：at()  </p>
<p>Create C++ Style Array (创建C++风格数组)<br> array不支持添加和删除元素以及改变容器大小的操作   </p>
<p>C++数组类是一个模板类，可以容纳任何类型的数据</p>
<pre><code>#include &lt;array&gt;

std::array&lt; 数组 类型,  数组大小&gt;   数组名字;

std::array&lt; 数组 类型,  数组大小&gt;   数组 名字 &#123; 值1,  值2, …&#125;;
</code></pre>
<p>限制与C风格数组相同，比如这个只能存同类型的数据，数组的大小确定后就不可以更改了。   </p>
<pre><code>std::array&lt;int , 10&gt; x;

std::array&lt;char , 5&gt; c&#123; &#39;H&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39; &#125;;   // 但是std::array&lt;char, 5&gt; array1&#123;&quot;hell&quot;&#125;; 因为字符串末尾自带&#39;\0&#39;

array&lt;int, 5&gt; myarray&#123;&#125;; //这样初始化数组内元素都为0（int）,否则里面是非空的  
</code></pre>
<p><strong>C++17引入了一种新特性，对类模板的参数进行推导</strong> (学完模板才能看懂这句话) 但是记住函数参数是必须要&lt;&gt;声明的，因为形参上来没有初始化   </p>
<p>示例：</p>
<pre><code>std::array a1 &#123;1, 3, 5&#125;;            // 推导出  std::array&lt;int, 3&gt;

std::array a2 &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;&#125;;   // 推导出  std::array&lt;char, 4&gt;   
</code></pre>
<p>二维数组定义：  </p>
<pre><code>// 二维数组    
array &lt;array&lt;int, 3&gt;, 4&gt;;
// 求数组大小
cout &lt;&lt; myarray.size() 
// 数组赋值
myarray = &#123; 7,4,11 &#125;;
// 交换数组
array swaparray&#123; 77,92,25 &#125;;
myarray.swap(swaparray);
print(swaparray);

//sort
sort(myarray.begin(), myarray.end(), std::greater&lt;int&gt;()); // 默认升序排列，可以greater&lt;int&gt;() 修改成降序 
</code></pre>
<p>数组全体赋值一个fill，两个数组之间对换所有元素 swap</p>
<pre><code>array&lt;int, 5&gt; arr&#123;1,5,3,4,2&#125;;
arr.fill(5); // 等价 arr = &#123;5,5,5,5,5&#125;;
</code></pre>
<p>swap（）</p>
<pre><code>std::array&lt;int, 3&gt; first = &#123; 1, 2, 3 &#125;;
std::array&lt;int, 3&gt; second = &#123; 6, 5, 4 &#125;;
first.swap(second);
</code></pre>
<h2 id="常量表达式-与-C-11的constexpr-关键字"><a href="#常量表达式-与-C-11的constexpr-关键字" class="headerlink" title="常量表达式 与 C++11的constexpr 关键字"></a>常量表达式 与 C++11的constexpr 关键字</h2><p>常量表达式的计算是发生在编译期间的。<br> Constant expression is an expression that can be evaluated at compile time. (常量表达式是编译期可以计算值的一个表达式)<br>    // 例如：C++ 数组的大小要求是编译期的一个常量（原生数组以及std::array）</p>
<pre><code>int n = 1; 

n ++;

std::array&lt;int, n&gt; a1; // error: n is not a constant expression 

const int cn = 2; 

std::array&lt;int, cn&gt; a2; // OK: cn is a constant expression   
</code></pre>
<p> const 修饰的对象未必是编译期常量 也就是说很多const定义的常量可能是编译期常量也可能是运行期常量   </p>
<pre><code>const int rcn = n; // rcn is runtime constant, compiler does NOT know its value at compile-time  

rcn = ++n;         // error: rcn is read-only  

std::array&lt;int , rcn&gt; a3; // error: rcn is NOT known at compile-time  
</code></pre>
<p>C++11 constexpr: 编译期常量表达式说明符 这个声明过的表达式可以在编译器就当常量来使用      </p>
<pre><code>constexpr int max(int a , int b) &#123; // c++11 引入 constexpr    
  if (a &gt; b) return a;   // c++14才允许constexpr函数中有分支循环等
  else       return b;    
&#125;    
int main() &#123;    
  int m = 1;    
  const int rcm = m++;   // rcm是运行期常量    
  const int cm = 4;      // 编译期常量，等价于: constexpr int cm = 4;     
  int a1[ max(m , rcm)]; // 错误：m &amp; rcm 不是编译期常量    
  std::array&lt;char , max(cm , 5)&gt; a2; // OK: cm 和 5 是编译期常量 
&#125;
</code></pre>
<p>const vs constexpr主要区别<br>const ：  告知程序员，const 修饰的内容是不会被修改的。主要目的是帮程序员避免bug </p>
<pre><code>char* s1 = &quot;Hello&quot;; // C++编译出错 需要加const 因为这个字符指针指向的是一个常量，是放在常量区的不可改变的 

*s1 = &#39;h’;          // C语言中，语法正确，但运行时会出错 

const char* s2 = &quot;World&quot;; // C++ 要求加const

*s2 = &#39;w&#39;;                // C++编译器报错
</code></pre>
<p>constexpr ：用在所有被要求使用“constant expression”的地方（就是constexpr 修饰的东西可以在编译期计算得到值），主要目的是让编译器能够优化代码提升性能 。</p>
<h2 id="断言-assert"><a href="#断言-assert" class="headerlink" title="断言 assert"></a>断言 assert</h2><p>是个宏不是函数<br>Assertion is a statement to check assumptions (断言是一条检测假设成立与否的语句)</p>
<p>如果假设成立，则断言悄无声息，如果不成立，就会中断程序。   </p>
<p>assert : C语言的宏(Macro)，运行时检测。这方便我们程序员写代码的时候检测是否出问题了。<br> <strong>用法：包含头文件 <cassert></strong>  以调试模式编译程序（不同模式调试程序，不是编译不一样，而是参数不一样，debug模式下，就不会优化代码，反而塞一堆东西进程序，比如断点功能啊等等，帮助我们如果出bug调试和信息，release模式发行模式下，则会帮助我们优化代码，代码更短运行更快，但是没有debug功能）       </p>
<pre><code>assert( bool_expr ); // bool_expr这个布尔表达式为假则中断程序

std::array a&#123; 1, 2, 3 &#125;;  //C++17 类型参数推导

for (size_t i = 0; i &lt;= a.size(); i++) &#123;

  assert(i &lt; 3);  //断言：i必须小于3，否则失败

  std::cout &lt;&lt; a[ i ];

  std::cout &lt;&lt; (i == a.size() ? &quot;&quot; : &quot; &quot;);
</code></pre>
<p>assert()依赖于NDEBUG 宏<br>NDEBUG这个宏是C/C++标准规定的，所有编译器都有对它的支持。</p>
<p>(1)      调试(Debug)模式编译时，编译器不会定义NDEBUG，所以assert()宏起作用。</p>
<p>(2)      发行(Release)模式编译时，编译器自动定义宏NDEBUG，使assert不起作用</p>
<p>如果要强制使得assert()生效或者使得assert()不生效，只要手动 #define NDEBUG 或者 #undef NDEBUG即可。<br>assert()是帮助我们调试程序和检查程序的，而不是帮搭建程序结构的,实现程序功能的~  </p>
<p>Code Complete 2: “Use error-handling for conditions you expect to occur; use assertions for conditions that should never occur.” (《代码大全2》：若某些状况是你预期中的，那么用错误处理；若某些状况永不该发生，用断言)</p>
<h2 id="静态断言（不是重点）"><a href="#静态断言（不是重点）" class="headerlink" title="静态断言（不是重点）"></a>静态断言（不是重点）</h2><p>static_assert ( bool_constexpr, message)</p>
<p>其中两个参数解释如下：</p>
<p>(1)      bool_constexpr:   编译期常量表达式，可转换为bool 类型</p>
<p>(2)      message: 字符串字面量 ，是断言失败时显示的警告信息。自C++17起，message是可选的</p>
<p>作用：编译时断言检查<br>    // 下面的语句能够确保该程序在32位的平台上编译进行。</p>
<pre><code>// 如果该程序在64位平台上编译，就会报错

static_assert(sizeof(void *) == 4, &quot;64-bit code generation is not supported.&quot;);
</code></pre>
<h2 id="声明declare和定义define"><a href="#声明declare和定义define" class="headerlink" title="声明declare和定义define"></a>声明declare和定义define</h2><p>“声明”是引入标识符并描述其类型，无论是类型，对象还是函数。<strong>编译器</strong>需要该“声明”，以便识别在它处使用该标识符。声明主要给编译器看的<br>定义”实例化/实现这个标识符。<strong>链接器</strong>需要“定义”，以便将对标识符的引用链接到标识符所表示的实体<br>区别</p>
<p>（1）A definition can be used in the place of a declaration ( 定义有时可取代声明，反之则不行)</p>
<p>（2 An identifier can be declared more than once, but can be defined only once ( 标识符可被声明多次，但只能定义一次)</p>
<p>(3) 定义通常伴随着编译器为标识符分配内存</p>
<p>(1) Declaration: “Somewhere, there exists a foo.” ( 声明：某个地方有个foo)</p>
<p>(2) Definition: “…and here it is!”  ( 定义：它在这儿，长成这样)   </p>
<h2 id="代理构造"><a href="#代理构造" class="headerlink" title="代理构造"></a>代理构造</h2><p>一个构造函数可以调用另外的构造函数   </p>
<pre><code>class A&#123;

public:   

   A(): A(0)&#123;&#125;  \\注意要调用 放在构造体前面 而且加冒号

   A(int i): A(i, 0)&#123;&#125;

   A(int i, int j) &#123;

      num1=i;

      num2=j;

      average=(num1+num2)/2;

   &#125;

private:

   int num1;

   int num2;

   int average;

&#125;;
</code></pre>
<p>上面例子中，构造函数的调用次序:</p>
<p>A() -&gt; A(int) -&gt; A(int, int)</p>
<h2 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h2><p>不可变对象对我们写多线程程序是很有帮助的<br>immutable object(不可变对象): The contents of an object cannot be changed (except through memberwise copy) once the object is created.(对象创建后，其内容不可改变，除非通过成员拷贝，就是赋值符复制一个新对象拷贝过来)</p>
<p>1.2. immutable class (不可变类) : The class of immutable object (不可变对象所属的类)</p>
<p>class immutable</p>
<p>(1) Mark all data fields private (所有数据域均设置为“私有”属性)</p>
<p>(2) No mutator functions  (没有更改器函数)</p>
<p>(3) No accessor that would return a reference/pointer to a mutable data field object(也没有能够<strong>返回可变数据域对象的引用或指针</strong>的访问器)</p>
<h2 id="枚举数据类型"><a href="#枚举数据类型" class="headerlink" title="枚举数据类型"></a>枚举数据类型</h2><p>enum 类型名 {枚举值表}；</p>
<p>类型名是变量名，指定枚举类型的名称。<br>枚举值是常量不是变量，不能在程序中再为枚举元素赋值。</p>
<p>将会为每个枚举元素分配一个整型值，默认从0开始，逐个加1。    </p>
<p>枚举常量代表该枚举类型的变量可能取的值，编译系统为每个枚举常量指定一个整数值，默认状态下，这个整数就是所列举元素的序号，序号从0开始。 可以在定义枚举类型时为部分或全部枚举常量指定整数值，在指定值之前的枚举常量仍按默认方式取值，而指定值之后的枚举常量按依次加1的原则取值。 各枚举常量的值可以重复。  </p>
<pre><code>enum fruit_set &#123;apple, orange, banana=1, peach, grape&#125;
//枚举常量apple=0,orange=1, banana=1,peach=2,grape=3。
enum week &#123;Sun=7, Mon=1, Tue, Wed, Thu, Fri, Sat&#125;;
//枚举常量Sun,Mon,Tue,Wed,Thu,Fri,Sat的值分别为7、1、2、3、4、5、6。
</code></pre>
<p>枚举常量只能以标识符形式表示，而不能是整型、字符型等文字常量。例如，以下定义非法：</p>
<pre><code>enum letter_set &#123;&#39;a&#39;,&#39;d&#39;,&#39;F&#39;,&#39;s&#39;,&#39;T&#39;&#125;; //枚举常量不能是字符常量
enum year_set&#123;2000,2001,2002,2003,2004,2005&#125;; //枚举常量不能是整型常量

// 以下定义合法 
enum letter_set &#123;a, d, F, s, T&#125;;
enum year_set&#123;y2000, y2001, y2002, y2003, y2004, y2005&#125;;
</code></pre>
<p>引用枚举表中元素的时候，记得加命名空间 比如 letter_set :: a</p>
<h2 id="静态成员-实例成员"><a href="#静态成员-实例成员" class="headerlink" title="静态成员 实例成员"></a>静态成员 实例成员</h2><p>static members instance members    </p>
<p>我们在类里做声明，需要用到关键字static，在类外做初始化也就是定义，但不能带static关键字，但是记得类外定义的时候得带上类名:: 。<br>静态成员就是说 我们可以不创建实例也可以访问的成员，可以通过类的名字就可以访问了。   </p>
<p>静态成员的声明<br>在类定义中，关键字 static 声明 不绑定到类实例的成员( 该成员无需创建对象即可访问)</p>
<p>静态成员定义复杂，一般情况下，在类外面定义，大部分情况都不会报错。   </p>
<p>静态数据成员具有静态存储 或者 C++11线程存储期特性    </p>
<p>对象的存储在程序开始时分配， 而在程序结束时解回收   </p>
<p>只存在对象的一个实例化（不管我们生成了多少个对象，静态成员只有一个）   </p>
<p>静态成员如果没有初始化，会被零初始化。<br>这里的 numberOfObjects 就是静态成员，需要static初始化。   </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">double</span> side;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> squareNumber;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Square</span>() :<span class="built_in">Square</span>(<span class="number">1.0</span>) &#123;&#125;</span><br><span class="line">	<span class="built_in">Square</span>(<span class="keyword">double</span> side_) &#123; </span><br><span class="line">		side = side_; </span><br><span class="line">		squareNumber++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSquareNumber</span><span class="params">()</span> </span>&#123;  <span class="comment">// 注意这里调用静态成员的函数也必须得声明static 不然，就无法实现通过类名访问这个函数，因为不是static的。</span></span><br><span class="line">		<span class="keyword">return</span> squareNumber;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Square::sq;   <span class="comment">// 初始化放在类外 ，记得加类名::找到数据域。 可以不赋值0，那就回被自动零初始化；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	std::cout &lt;&lt; Square::<span class="built_in">getSquareNumber</span>() &lt;&lt; std::endl;</span><br><span class="line">	Square s1, s2&#123; <span class="number">5.0</span> &#125;;</span><br><span class="line">	std::cout &lt;&lt; Square::<span class="built_in">getSquareNumber</span>() &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>Destructor</p>
<p>Destructors are the opposite of constructors. (dtor vs ctor) 析构函数与构造函数正好相反  </p>
<p>析构函数不可以重载的喔，因为构造函数ctor有参数作为区分，他没有参数所以不可以重载  </p>
<pre><code>class S &#123;
~S() = default;  // 显式声明系统默认的析构函数，如果显式声明不需要析构函数则， =delete;
&#125;;
</code></pre>
<p>析构函数举个栗子</p>
<pre><code>class Square &#123;
private:
    double side;
    static int squareNumber;
public:
    Square() :Square(1.0) &#123;&#125;
    Square(double side_) &#123; 
        side = side_; 
        squareNumber++;
    &#125;
    ~Square() &#123;
        squareNumber--;
    &#125;
    static int getSquareNumber() &#123;
        return squareNumber;
    &#125;
&#125;;
int Square::squareNumber = 0;
int main() &#123;
    std::cout &lt;&lt; Square::getSquareNumber() &lt;&lt; std::endl;
    Square s1, s2&#123; 5.0 &#125;;
    std::cout &lt;&lt; Square::getSquareNumber() &lt;&lt; std::endl;
    &#123;
        Square s3, s4&#123; 6.6 &#125;;  // 对象在内嵌域内生成，生存期结束，销毁
    &#125;
    std::cout &lt;&lt; Square::getSquareNumber() &lt;&lt; std::endl;
    return 0;
&#125;
</code></pre>
<p>在析构函数里主要做几件事，一个是如果创建对象使用了指针或者在堆里new了写空间，那么得在这个对象销毁是，delete掉这个指针和空间。    </p>
<h2 id="静态变量和全局变量"><a href="#静态变量和全局变量" class="headerlink" title="静态变量和全局变量"></a>静态变量和全局变量</h2><p>全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。 而静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它。   </p>
<p>static全局变量与普通的全局变量<br>static全局变量只初使化一次，作用域被限制在该变量的源文件内有效，防止在其他文件单元中被引用   </p>
<p>static局部变量和普通局部变量<br>static局部变量只被初始化一次，下一次依据上一次结果值</p>
<p>static函数与普通函数<br>static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝</p>
<pre><code>int main() &#123;
    class B &#123;
    public:
        void foo() &#123;
            int i = 0;
            static int j = 0;
            cout &lt;&lt; j &lt;&lt; &quot; &quot; &lt;&lt; i;
            ++j;
            ++i;
            cout &lt;&lt; endl;
        &#125;
    &#125;;
    B().foo();
    B().foo();
    B().foo();
    return 0;
&#125;
</code></pre>
<h2 id="Friend-友元"><a href="#Friend-友元" class="headerlink" title="Friend 友元"></a>Friend 友元</h2><p>私有成员无法从类外访问，但有时又需要授权某些可信的函数和类访问这些私有成员   </p>
<p>C++ enables you to use the friend keyword to declare friend functions and friend classes for a class (用friend关键字声明友元函数或者友元类，友元的缺点：打破了封装性)</p>
<pre><code>class Square &#123;
private:
    double side;
    static int squareNumber;
public:
    Square() :Square(1.0) &#123;&#125;
    Square(double side_) &#123; 
        side = side_; 
        squareNumber++;
    &#125;
    ~Square() &#123;
        squareNumber--;
    &#125;
    static int getSquareNumber() &#123;
        return squareNumber;
    &#125;
    double getSide() &#123;
        return side;
    &#125;
    friend class Area;   // 注意这里是声明 带类型
    friend void print(const Square&amp; square);  // 注意这里是声明 
&#125;;
void print(const Square&amp; s) &#123;
    std::cout &lt;&lt; s.side &lt;&lt; std::endl;
&#125;
class Area &#123;
private:
    double area;
    Square* s;
public:
    Area() = default;
    Area(Square* s_) &#123;
        area = (*s_).side * (*s_).side;
        std::cout &lt;&lt; s_ &lt;&lt; std::endl;
        s = s_;
        std::cout &lt;&lt; s &lt;&lt; std::endl;
    &#125;
    double getArea() &#123; return area; &#125;
    void changeSide(double side_) &#123; (*s).side = side_; &#125;
&#125;;
int Square::squareNumber = 0;
int main() &#123;
    Square ss1&#123; 1.5 &#125;;
    print(ss1);
    std::cout &lt;&lt; &amp;ss1 &lt;&lt; std::endl;
    Area a&#123; &amp;ss1 &#125;;
    std::cout &lt;&lt; a.getArea() &lt;&lt; std::endl;
    a.changeSide(3);
    print(ss1);
    return 0;
&#125;
</code></pre>
<p>在public里声明一下 注意是声明不是定义，就可以在友元里直接使用 对象.私域变量了。</p>
<h2 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h2><p>copy ctor<br>作用是根据已有的对象创建一个一模一样的对象   </p>
<p>用一个对象 去<strong>初始化</strong>一个<strong>同类对象</strong>   </p>
<p>拷贝构造函数的结构：</p>
<pre><code>类名 (类名&amp;)；
//或者 类名 (const 类名&amp; 形参名);
</code></pre>
<p>对象在定义初始化的时候 = 号就不是赋值，而是调用拷贝构造函数</p>
<pre><code>className obj1 = obj2; // 这里就是调用拷贝构造函数  
// 当然可以写成其他形势比如
className obj1&#123;obj2&#125;;
className obj1 = &#123;obj2&#125;;
</code></pre>
<p>如果不写拷贝构造函数，就会隐式声明的拷贝构造函数，是编译器自动生成的，这个是简单的将对象的每个数据域1对1的复制到新对象里去。如果复制过程中有特殊需求，就需要自己构造一个拷贝构造函数。特别是当数据域里有指针的时候，这时候如果需要深拷贝，必须要自己构造拷贝构造函数。        </p>
<pre><code>class Square &#123;
private:
    double side;
    static int squareNumber;
public:
    Square() :Square(1.0) &#123;&#125;
    Square(double side_) &#123;
        side = side_;
        squareNumber++;
    &#125;
    Square(Square&amp; s) &#123;
        this-&gt;side = s.side;
        squareNumber++;
        std::cout &lt;&lt; &quot;Square(const Square&amp; ) is invoked&quot; &lt;&lt; std::endl;
    &#125;
    ~Square() &#123;
        squareNumber--;
    &#125;
    static int getSquareNumber() &#123;
        return squareNumber;
    &#125;
    double getSide() &#123;
        return side;
    &#125;
    friend class Area;   // 注意这里是声明 带类型
    friend void print(const Square&amp; square);  // 注意这里是声明 
&#125;;
void print(const Square&amp; s) &#123;
    std::cout &lt;&lt; s.side &lt;&lt; std::endl;
&#125;

int Square::squareNumber = 0;
int main() &#123;
    Square s1&#123; 2 &#125;;
    print(s1);
    std::cout &lt;&lt; Square::getSquareNumber() &lt;&lt; std::endl;
    Square s2&#123;s1&#125;;
    std::cout &lt;&lt; Square::getSquareNumber() &lt;&lt; std::endl;
    Square* s3 = new Square&#123; 5.0 &#125;;
    std::cout &lt;&lt; Square::getSquareNumber() &lt;&lt; std::endl;
    delete s3;
    s3 = nullptr;
    std::cout &lt;&lt; Square::getSquareNumber() &lt;&lt; std::endl;
    return 0;
&#125;
</code></pre>
<h2 id="深拷贝-浅拷贝"><a href="#深拷贝-浅拷贝" class="headerlink" title="深拷贝 浅拷贝"></a>深拷贝 浅拷贝</h2><p> Shallow Copy vs. Deep Copy (浅拷贝和深拷贝)<br>浅拷贝：数据域是一个指针，只拷指针的地址，而非指针指向的内容)<br>shallow copy </p>
<p>深拷贝：拷贝指针指向的内容<br>deep copy</p>
<p>因为默认拷贝构造函数，他是全部数据域一对一的拷贝赋值，所以数据域里如果有指针指向一个堆区的一个对象，那么拷贝的时候这个指针内容也就是这个对象地址还是一样的，所以就出现了浅拷贝的情况：数据域里的指针指向同一个地址。</p>
<p>深拷贝需要自行编写拷贝构造函数，在赋值运算的时候重载赋值运算符。    </p>
<h2 id="Vector-class-重点"><a href="#Vector-class-重点" class="headerlink" title="Vector class (重点)"></a>Vector class (重点)</h2><p>vector是一种动态数组，事实上可以替代new ，delete数组的工作，它的实现其实也是通过new、delete实现的，只是自动完成的而已。  </p>
<p>需要包含<vector> 头文件 命名空间在std </p>
<pre><code>vector&lt;dataType&gt; vectorname   
</code></pre>
<p>编码规范 迭代变量名应该用 i, j, k 等  </p>
<pre><code>vector&lt;int&gt; iV &#123;-2, -1, 0&#125;;
for (int i = 1; i &lt; 10; i++)
    iV.push_back(i + 1);  
</code></pre>
<p>构造：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">explicit vector (size_type n);</span><br><span class="line">         vector (size_type n, const value_type&amp; val,</span><br><span class="line">                 const allocator_type&amp; alloc &#x3D; allocator_type());</span><br><span class="line">\\用n个val填充容器，含一个参数的是C++11定义的</span><br><span class="line">std::vector&lt;int&gt; second (4,100);          &#x2F;&#x2F; four ints with value 100</span><br><span class="line">vector&lt;string&gt; words4&#123; 4, &quot;hehihi&quot; &#125;; &#x2F;&#x2F; 一样的 生成4个 hehihi字符串  </span><br><span class="line">std::vector&lt;int&gt; third (second.begin(),second.end());  &#x2F;&#x2F; 从开始的迭代元素复制到右侧的迭代器，所以左右区间相同会出现两个元素。  </span><br><span class="line">std::vector&lt;int&gt; v1 (v2); &#x2F;&#x2F;无论是(v2) 还是 &#123;v2&#125; 还是 &#x3D; v2 这里都是复制，改变v1不影响v2 ,这里和python的 “&#x3D;” 不一样</span><br></pre></td></tr></table></figure>
<p>vector 手册</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">push_back(element:same dataType) :void   尾部增加一个元素</span><br><span class="line">pop_back(): void  尾部(back)pop删掉一个元素，这里没有返回值和python pop不一样</span><br><span class="line">size(): unsigned int  长度 </span><br><span class="line">capacity(): 当前分配给容器的存储空间大小 </span><br><span class="line">max_size()：返回最大这个容器可以最大多大容量</span><br><span class="line">reserve(int):void 使得这个容器的分配空间变为多少</span><br><span class="line">at(index:int):dataType 访问</span><br><span class="line">operator[index:int]:dataType 访问</span><br><span class="line">empty():bool  判断是否为空</span><br><span class="line">clear():void  清空</span><br><span class="line">swap(v2:vector):void  交换</span><br><span class="line">erase(pos:iterator):iterator   移除pos位置的元素 参数是迭代器 用begin去写</span><br><span class="line">iterator erase(iterator first,iterator last)：删除firstd迭代器到last迭代器的元素 左闭右开</span><br><span class="line">insert(pos:const_iterator, element):iterator  插入 和python一样 也是指针</span><br><span class="line">resize：void resize (size_type n, value_type val &#x3D; value_type()); \\改变容器可以容纳元素的个数为n。如果n小于当前的容器大小，则保留前面n个元素，移除后面的。如果n大于当前容器大小，就扩展容器。value是初始值，如果n大于当前容器大小，则新增加的元素的值为value，若value省略，会自动调用一个默认值。resize()函数无返回。</span><br><span class="line">front():datatype 容器第一个元素</span><br><span class="line">back():datatype 容器最后一个元素  </span><br><span class="line">data():datatype* 返回一个指向容器中数组的指针c.data()指向开头 </span><br><span class="line">assign():void</span><br></pre></td></tr></table></figure>


<h2 id="和-运算符"><a href="#和-运算符" class="headerlink" title="#和 ## 运算符"></a>#和 ## 运算符</h2><p>#构串操作符  只能修饰带参数的宏的形参，他将实参的字符序列（注意！！不是实参的值！），转为字符串常量。<br>构串操作符#只能修饰带参数的宏的形参，它将实参的字符序列（而不是实参代表的值）转换成字符串常量</p>
<pre><code>#define STRING(x)  #x#x#x
#define TEXT(x)  &quot;class&quot;#x&quot;Info&quot;
//宏引用：
int abc = 100；
STRING(abc);
TEXT(abc);
//替换结果：
abcabcabc
classabcInfo
</code></pre>
<p>##：合并操作符<br>合并操作符##将出现在其左右的字符序列合并成一个新的标识符<br>使用合并操作符##时，自身的标识符必须预先有定义，否则编译器会报“标识符未定义”的编译错误。<br>字符序列合并成新的标识符不是字符串。</p>
<pre><code>#define CLASS_NAME(name) class##name
#define MERGE(x,y) x##y##x
//宏引用：
CLASS_NAME(Timer)
MERGE(me,To)
//替换结果：
classTimer
meTome
</code></pre>
<h2 id="stack-栈"><a href="#stack-栈" class="headerlink" title="stack 栈"></a>stack 栈</h2><p>函数调用时，主函数传给子函数的参数先进栈，进入子函数后，子函数的局部变量也按序在栈中建立    </p>
<p>子函数返回时，局部变量出栈、参数出栈。  </p>
<h2 id="用于数组的结构化绑定声明-类似于python的元组赋值-元组绑定"><a href="#用于数组的结构化绑定声明-类似于python的元组赋值-元组绑定" class="headerlink" title="用于数组的结构化绑定声明 类似于python的元组赋值 元组绑定"></a>用于数组的结构化绑定声明 类似于python的元组赋值 元组绑定</h2><p>结构化绑定声明是一个声明语句，意味着声明了一些标识符并对标识符做了初始化</p>
<p>就好像python的元组赋值一样，但是这里只是一个声明语句，所以这里的标识符如果之前被定义或者声明过，那么会报错。       </p>
<p>将指定的一些名字绑定到初始化器的子对象或者元素上   </p>
<ol>
<li><pre><code>  cv-auto &amp;/&amp;&amp;(可选) [标识符列表] = 表达式;
</code></pre>
</li>
<li><pre><code>  cv-auto &amp;/&amp;&amp;(可选) [标识符列表] &#123; 表达式 &#125;;
</code></pre>
</li>
<li><pre><code>  cv-auto &amp;/&amp;&amp;(可选) [标识符列表] ( 表达式 );
</code></pre>
</li>
<li><pre><code>  cv-auto: 可能由const/volatile修饰的auto关键字
</code></pre>
</li>
<li><pre><code>  &amp;/&amp;&amp; 左值引用或者右值引用
</code></pre>
</li>
<li><pre><code>  标识符列表：逗号分隔的标识符
</code></pre>
</li>
</ol>
<pre><code>int main() &#123;
    int array[]&#123; 42,12,16 &#125;;
    auto[a1, a2, a3] = array; // a1是array[0] 的拷贝 
    std::cout &lt;&lt; a1 &lt;&lt; &quot; &quot; &lt;&lt; a2 &lt;&lt; &quot; &quot; &lt;&lt; a3 &lt;&lt; std::endl;
    const auto[b1, b2, b3](array); // b1是 array[0]的只读拷贝 因为这里是const
    auto &amp;[c1, c2, c3] &#123;array&#125;; // c1是array[0]的引用
    std::cout &lt;&lt; c1 &lt;&lt; &quot; &quot; &lt;&lt; c2 &lt;&lt; &quot; &quot; &lt;&lt; c3 &lt;&lt; std::endl;
    array[0] = 1;
    std::cout &lt;&lt; c1 &lt;&lt; &quot; &quot; &lt;&lt; c2 &lt;&lt; &quot; &quot; &lt;&lt; c3 &lt;&lt; std::endl;
&#125;
</code></pre>
<h2 id="用于对象数据成员的结构化绑定"><a href="#用于对象数据成员的结构化绑定" class="headerlink" title="用于对象数据成员的结构化绑定"></a>用于对象数据成员的结构化绑定</h2><p>基本和数组的结构化绑定形式差不多<br>若初始化表达式为类/结构体类型，则标识符列表中的名字绑定到类/结构体的非静态数据成员上</p>
<ol>
<li><pre><code> ** 数据成员必须为公有成员**
</code></pre>
</li>
<li><pre><code>  标识符数量必须等于数据成员的数量
</code></pre>
</li>
<li><pre><code>  标识符类型与数据成员类型一致
</code></pre>
</li>
</ol>
<pre><code>class C &#123;  // 可以改用 struct C，然后去掉下面的public属性说明

public:

  int i &#123; 420 &#125;; // 就地初始化

  char ca[ 3 ] &#123; &#39;O&#39;, &#39;K&#39;, &#39;!&#39; &#125;;

&#125;;

int main() &#123;

  C c;

  auto [a1, a2] &#123;c&#125;; // a1是int类型，a2是char[]类型

  std::cout &lt;&lt; &quot;c.i:&quot; &lt;&lt; a1 &lt;&lt; &quot; c.ca:&quot; &lt;&lt; b2 &lt;&lt; std::endl;

&#125;
</code></pre>
<p>auto后跟&amp;，则标识符是数据成员的引用</p>
<p>auto前可放置const，表明标识符是只读的  </p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>inheritance   </p>
<p>继承链上有很多说法， 基类 - 派生类， 父类 - 子类， 超类 - 子类   </p>
<p>子继承父，父泛化子  </p>
<p>子类中包含父类中大部分成员   </p>
<p>C++11引入final特殊标识符，可以使得类不能被继承</p>
<p>： public 父类名<br>加了父类的属性作为创建对象的组成后也需要修改构建函数，调用父类的构建函数完成堆父类属性的设置</p>
<pre><code>class B final &#123;&#125;; \\ 这样B类就不会被继承了  
</code></pre>
<p>继承定义：   </p>
<pre><code>class Rectangle : public Shape &#123;  // ： public 父类名
private:
    double width&#123; 1.0 &#125;;
    double height&#123; 1.0 &#125;;
public:
    Rectangle() = default;
    Rectangle(double width_, double height_, Color color_, bool filled_);
    double getWidth() const;
    double getHeight() const;
    void setWidth(double width_);
    void setHeight(double height_);
    double getArea() const;
&#125;;

Rectangle::Rectangle(double width_, double height_, Color color_, bool filled_) :width&#123; width_ &#125;, height&#123;height_&#125; ,Shape(color_, filled_)&#123;  // 加了父类的属性作为创建对象的组成后也需要修改构建函数，调用父类的构建函数完成堆父类属性的设置
&#125;
double Rectangle::getWidth() const &#123; return width; &#125;
double Rectangle::getHeight() const &#123; return height; &#125;
void Rectangle::setWidth(double width_) &#123; width = width_; &#125;
void Rectangle::setHeight(double height_) &#123; height = height_; &#125;
double Rectangle::getArea() const &#123; return width * height; &#125;
</code></pre>
<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p>struct 类似于class但是里面默认全是共有属性的 相当于等于 class + public，写就当class写就好了</p>
<h2 id="继承中的构造函数"><a href="#继承中的构造函数" class="headerlink" title="继承中的构造函数"></a>继承中的构造函数</h2><p>C++11:派生类不继承的特殊函数</p>
<p>(1)     析构函数</p>
<p>(2)     友元函数</p>
<p>(1)     using A::A;  继承所有基类ctor 不写也默认继承  </p>
<p>(2)     不能仅继承指定的某个基类ctor   但是可以通过在b中创建一个同参数的b类构造函数，在调用a类构造函数的同时，还可以在函数体内做一些b类的初始化和构造函数做的事情   </p>
<p>调用继承的构造函数</p>
<pre><code>struct A &#123; // 等价于 class A &#123; public:

    A(int i) &#123;&#125;

    A(double d, int i) &#123;&#125;
// ...
&#125;;

struct B : A &#123;  // C++11

    using A::A; // 继承基类所有构造函数

    int d&#123;0&#125;;   // 就地初始化

&#125;;

int main() &#123;

    B b(1);   // 调A(int i)

&#125;
</code></pre>
<p>派生类构造函数调用A类构造函数的时候，无论在：后面是先初始化了自身成员，还是什么顺序，都是先调用基类的构造函数，再对自身成员初始化。在执行函数体内。</p>
<pre><code>struct A &#123; // 等价于 class A &#123; public:

    A(int i) &#123;&#125;

    A(double d, int i) &#123;&#125;
// ...

&#125;;
struct B : A &#123;  // C++11

    using A::A; // 继承基类所有构造函数  调用过来其实本质是生成了   B(int i)：A(int i)&#123;&#125;   B(double d, int i):A(double d, int i)&#123;&#125;

    int d&#123;0&#125;;   // 就地初始化 因为基类的构造函数不含派生类的成员的初始化过程

&#125;;

int main() &#123;

    B b(1);   // 调A(int i)

&#125;
</code></pre>
<p>调用基类构造函数也是一种方式   </p>
<pre><code> struct A &#123; // 等价于 class A &#123; public:

  A(int i) &#123; cout &lt;&lt; &quot;A(int i)&quot; &lt;&lt; endl; &#125;

  A(double d , int i) &#123;&#125;

  // ...

&#125;;

 

struct B : A &#123;  // C++11

  using A::A; // 继承基类ctor，除了A(int i) 因为下面重定义了B（int i） 而且一旦有重定义的派生类构造函数，那么无参的构造函数必须重写。手动写一下声明。

  int d&#123; 0 &#125;; // 就地初始化
  B():A()&#123;&#125;  //也可以 B（） = default； //自动会去调用A类的无参构造函数 

  B(int i) : A&#123; i &#125; , d&#123; i &#125; &#123; 

    std::cout &lt;&lt; &quot;B(int i)&quot; &lt;&lt; std::endl;

  &#125;

&#125;;

 

int main() &#123;

  B b(1);   // 调用 B(int i)

  std::cin.get();
</code></pre>
<p>}</p>
<p>如果一个派生类不写一个构造函数，那么默认继承全部基类构造函数</p>
<pre><code>class B &#123;
public:
    B() &#123; cout &lt;&lt; &quot;B()&quot; &lt;&lt; endl; &#125;
    B(int i) &#123; cout &lt;&lt; &quot;B(&quot; &lt;&lt; i &lt;&lt; &#39;)&#39; &lt;&lt; endl; &#125;
    B(char c) &#123; cout &lt;&lt; &quot;B(&quot; &lt;&lt; c &lt;&lt; &#39;)&#39; &lt;&lt; endl; &#125;
&#125;;
class E &#123;
public:
    E() &#123; cout &lt;&lt; &quot;E()&quot; &lt;&lt; endl; &#125;
&#125;;
class D : public B &#123;
public:
    using B::B;
    D(double i) :e1&#123;&#125;, e2&#123;&#125;, B&#123; static_cast&lt;int&gt;(i) &#125; &#123; cout &lt;&lt; &quot;D(&quot; &lt;&lt; i &lt;&lt; &#39;)&#39; &lt;&lt; endl; &#125;
    D() = default;
private:
    E e1, e2;

&#125;;

int main() &#123;
    D d&#123;1.1&#125;;
    
    return 0;
&#125;
//
//cout&gt;&gt;B(1) 调用顺序是 先调B的对应的构造函数 在对成员初始化 最后进入构造体内执行 
//E()
//E()
//D(1.1)
</code></pre>
<p>(若基类ctor未被显式调用，基类的默认构造函数就会被调用)也就是如果派生类构造函数写了但是没有显式声明调用基类那个构造函数则默认调用基类无参构造函数</p>
<p>编码规范</p>
<p>文件扩展名：头文件用.h，源文件用 .cpp (c++, cc也可)</p>
<p>类应该在头文件中声明并在源文件中定义，俩文件名字应该与类名相同</p>
<p>类成员变量不可被声明为public</p>
<p>所以基类的默认构造函数一定要好好编写、小心编写。   </p>
<h2 id="构造链-和-析构链"><a href="#构造链-和-析构链" class="headerlink" title="构造链 和 析构链"></a>构造链 和 析构链</h2><p>构造类实例会沿着继承链调用所有的基类ctor)</p>
<p>调用次序: base first, derive next (父先子后)  </p>
<p>dtor与ctor正好相反)</p>
<p>调用次序: derive first, base next (子先父后) 如果析构对象里有对象对象，实现调用该对象的析构函数在调用内嵌对象的析构函数  </p>
<h2 id="创建的对象到底在堆上还是栈上"><a href="#创建的对象到底在堆上还是栈上" class="headerlink" title="创建的对象到底在堆上还是栈上"></a>创建的对象到底在堆上还是栈上</h2><p>如果需要在堆上创建对象，要么使用new运算符，要么使用malloc系列函数。这点没有异议。</p>
<p>真正有异议的是下面的代码：</p>
<pre><code>Object obj;
</code></pre>
<p>此时，obj是在栈上分配的吗？</p>
<p>要回答这个问题，我们首先要理解这个语句是什么意思。这个语句就是代表着，在栈上创建对象吗？</p>
<p>其实，这行语句的含义是，使对象obj具有“自动存储（automatic storage）”的性质。所谓“自动存储”，意思是这个对象的存储位置取决于其声明所在的上下文。</p>
<p>如果这个语句出现在函数内部，那么它就在栈上创建对象。</p>
<p>如果这个语句不是在函数内部，而是作为一个类的成员变量，则取决于这个类的对象是如何分配的。考虑下面的代码：</p>
<pre><code>class Class
&#123;
    Object obj;
&#125;;
 
Class *pClass = new Class;
  // 指针pClass所指向的对象在堆上分配空间。

  // 因为Object obj;语句的含义是“自动存储”，所以，pClass-&gt;obj也是在堆上创建的。

 

Object *pObj;
pObj = new Object;
// Object *pObj;代表，指针pObj是自动存储
// 仅此而已，没有任何其它含义。
// 而之后一行语句则指出，这个指针所指向的对象是在堆上面分配的。
</code></pre>
<p>如果这两行语句出现在一个函数内部，意味着当函数结束时，pObj会被销毁，但是它指向的对象不会。因此，为了继续使用这个对象，通常我们会在函数最后添加一个return语句，或者使用一个传出参数。否则的话，这个在堆上创建的对象就没有指针指向它，也就是说，这个对象造成了<strong>内存泄露</strong>。 </p>
<p>并不是说指针指向的对象都是在堆上创建的。下面的代码则使用指针指向一个在栈上创建的对象：</p>
<pre><code>Object obj;
Object *pObj = &amp;obj;
</code></pre>
<p>堆和栈的区别在于两点：</p>
<p>生命周期<br>性能<br>第一点才是我们需要着重考虑的。由于栈的特性，如果你需要一个具有比其所在的上下文更长的生命周期的变量，只能在堆上创建它。所以，我们的推荐是：只要能在栈上创建对象，就在栈上创建；否则的话，如果你不得不需要更长的生命周期，只能选择堆上创建。这是由于在栈上的对象不需要我们手动管理内存。有经验的开发人员都会对内存管理感到头疼，我们就是要避免这种情况的发生。总的来说，我们更多推荐选择在栈上创建对象。</p>
<p>但是，有些情况，即便你在栈上创建了对象，它还是会占用堆的空间。考虑如下代码：</p>
<pre><code>void func
&#123;
    std::vector v;
&#125;
</code></pre>
<p>对象v是在栈上创建的。但是，STL 的vector类其实是在堆上面存储数据的（这点可以查看源代码）。因此，只有对象v本身是在栈上的，它所管理的数据（这些数据大多数时候都会远大于其本身的大小）还是保存在堆上。  </p>
<p>首先，在堆上创建对象需要追踪内存的可用区域。这个算法是由操作系统提供，通常不会是常量时间的。当内存出现大量碎片，或者几乎用到 100% 内存时，这个过程会变得更久。与此相比，栈分配是常量时间的。其次，栈的大小是固定的，并且远小于堆的大小。所以，如果你需要分配很大的对象，或者很多很多小对象，一般而言，堆是更好的选择。如果你分配的对象大小超出栈的大小，通常会抛出一个异常。尽管很罕见，但是有时候也的确会发生。有关性能方面的问题，更多出现在嵌入式开发中：频繁地分配、释放内存可能造成碎片问题。   </p>
<p>现代操作系统中，堆和栈都可以映射到虚拟内存中。在 32 位 Linux，我们可以把一个 2G 的数据放入堆中，而在 Mac OS 中，栈可能会限制为 65M。</p>
<p>总的来说，关于究竟在堆上，还是在栈上创建对象，首要考虑你所需要的生命周期。当性能真正成为瓶颈的时候，才去考虑性能的问题。堆和栈是提供给开发者的两个不同的工具，不存在一个放之四海而皆准的规则告诉你，一个对象必须放在堆中还是在栈中。选择权在开发者手中，决定权在开发者的经验中。</p>
<h2 id="基类同名函数"><a href="#基类同名函数" class="headerlink" title="基类同名函数"></a>基类同名函数</h2><p>内部作用域的名字隐藏外部作用域的(同名)名字  避免某些潜在的危险行为、每个类在创建时，它的函数名都是写在一张干净的白纸上面，不会被基类函数名干扰</p>
<p>(1)     The derived class acts as an inner scope (派生类视作内部作用域)</p>
<p>(2)     The base class as an outer scope(基类视作外部作用域)</p>
<pre><code>class B &#123;
public:
    B() = default;
    void f() &#123; cout &lt;&lt; &quot;B.f()&quot; &lt;&lt; endl; &#125;
&#125;;
class D : public B &#123;
public:
    void f(int i) &#123; cout &lt;&lt; &quot;D.f()&quot; &lt;&lt; endl; &#125;
&#125;;
int main() &#123;
    D d;
    d.B::f(); // 加上作用域   static_cast&lt;B&gt;(D).F();也行 
    return 0;
&#125;
</code></pre>
<p>也可以用 using来实现对基类同名函数的隐藏的设定 using fatherclassname :: functionname;</p>
<pre><code>class B &#123;
public:
    B() = default;
    void f() &#123; cout &lt;&lt; &quot;B.f()&quot; &lt;&lt; endl; &#125;
&#125;;
class D : public B &#123;
public:
    using B::f;
    void f(int i) &#123; cout &lt;&lt; &quot;D.f()&quot; &lt;&lt; endl; &#125;
&#125;;
int main() &#123;
    D d;
    d.f();
    return 0;
&#125;
</code></pre>
<h2 id="重定义与重载"><a href="#重定义与重载" class="headerlink" title="重定义与重载"></a>重定义与重载</h2><p>3.1. Overload Functions (重载函数)</p>
<p>3.1.1. more than one function with the same name (多个函数名字相同)</p>
<p>3.1.2. But different in at least one of the signatures: (但至少一个特征不同)</p>
<p>(1)     parameter type        (参数类型)</p>
<p>(2)     parameter number      (参数数量)</p>
<p>(3)     parameter sequence    (参数顺序)</p>
<p>3.2. Redefine Functions (重定义函数)</p>
<p>3.2.1. The functions have the same signature (函数特征相同)</p>
<p>(1)     Name (同名)</p>
<p>(2)     Parameters (including type, number and sequence) (同参数：类型，数量和顺序)</p>
<p>(3)     Return type (返回值类型)</p>
<p>3.2.2. Defined in base class and derived class, respectively (在基类和派生类中分别定义)  </p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>广义的多态：不同类型的实体/对象对于同一消息有不同的响应，就是OOP中的多态性。   (不同对象调用同一个函数得到的结果不同)     </p>
<p>目前有两种多态，一种是重载多态，一种是子类型多态。<br>重载多态：利用的函数的特征不同（类型，数量和顺序）区分不同的函数，所以产生不同的响应<br>子类型多态：是在继承里，调用同名的重定义函数</p>
<p>确定具有多态性的语句调用哪个函数的过程就叫联编 binding  </p>
<p>如果是重载多态，那么这时候一般编译器就能确定调用哪个函数，这个就叫静态联编   </p>
<p>如果是程序运行是才能够确定调用那个函数实现的多态，这个叫动态联编，而这种多态也叫运行多态。     </p>
<pre><code>class A           &#123; virtual int f() &#123;return 1;&#125; &#125;;

class B: public A &#123; virtual int f() &#123;return 8;&#125; &#125;;

A  a; B b;

A* p = &amp;b;

a.f()   // call A::f()

b.f()   // call B::f()

p-&gt;f(); // call B::f()  // 这里p指针虽然是A类型的指针，但是指向的是A类的子类B类的一个对象，那么这时候调用的是子类的函数  
</code></pre>
<h3 id="为什么要使用运行时多态"><a href="#为什么要使用运行时多态" class="headerlink" title="为什么要使用运行时多态"></a>为什么要使用运行时多态</h3><p>覆写：在派生类里重定义一个虚函数  </p>
<p>使用虚函数virtual function 虚函数  在函数前面加上virtual 关键字，</p>
<p>用途是可以用父类指针去访问子类对象成员 </p>
<p>虚函数局有传递性  基类中定义了虚同名函数，那么派生类中的同名函数自动变成虚函数   </p>
<p>不管使用基类指针还是基类引用 都可以实现调用虚函数调用的是实际对象的同名函数<br>虚函数有：</p>
<ol>
<li>虚函数表</li>
<li>运行时联编/动态联编</li>
<li>比非虚函数开销</li>
</ol>
<p>下面的部分就可以使用虚函数方式需要写多个重载的print函数<br>    class A{<br>    public:<br>        virtual string toString() { return “A”; }<br>    };<br>    class B : public A{<br>    public:<br>        string toString() { return “B”; }<br>    };<br>    class D : public B{<br>    public:<br>        string toString() { return “D”; }<br>    };<br>    void print(A* obj) {<br>        cout &lt;&lt; obj-&gt;toString() &lt;&lt; endl;<br>    }<br>    int main() {<br>        A a;<br>        B b;<br>        D d;<br>        A* p1 = &a;<br>        A* p2 = &b;<br>        A* p3 = &d;<br>        print(p1); print(p2); print(p3);<br>        return 0;<br>    }</p>
<p>**如果子类中同名函数写错了 或者没有，那么就会往上找一层，直到找到符合的同名虚函数来执行   ** </p>
<p>如果防止编写的时候出现写错，可以使用关键字  override</p>
<pre><code>string toString override &#123;//blah blah&#125;   // 这个override关键字就会在编译的时候自动检查这个函数是否与父类里的函数特性完全一致（参数、返回）
</code></pre>
<p>简单说：</p>
<ol>
<li>就是如果不是虚函数，那么指针引用是啥类型，调用啥类型里的函数   </li>
<li>如果是虚函数,那么如果是基类指针，这时候调用啥类型里的函数看指针、引用所指向的是啥类型，就调用啥类型。这个就叫运行时多态。动态联排。</li>
</ol>
<h2 id="override"><a href="#override" class="headerlink" title="override"></a>override</h2><p>override是一个标识符 不是关键字 ，也就是可是作为变量名的，但是在关键位置出现就会出现和关键字一样的效果指令。只能在类里声明，和函数声明放一起，不能在定义的时候使用。                 </p>
<p>价值在于避免程序员在写程序的时候，避免一些错误。<br>    class A {</p>
<pre><code>public:

  virtual void foo() &#123;&#125;

  void bar() &#123;&#125;

&#125;;

 

class B : public A &#123;

public:

  void foo() const override &#123; // 错误： B::foo 不覆写 A::foo

  &#125;                           // （签名不匹配）

  void foo() override;   // OK ： B::foo 覆写 A::foo

  void bar() override &#123;&#125; // 错误： A::bar 非虚

&#125;;

 

void B::foo() override &#123;// 错误： override只能放到类内使用只能在声明的时候作为标识符声明清楚，不能在定义的时候再声明override。   

&#125;   
</code></pre>
<p>final 显式声明禁止覆写</p>
<p>C++11引入final特殊标识符，指定派生类不能覆写虚函数  这个也可以用于让一个类不可被继承，他的子类就不会默认继承这个函数的虚函数了。     </p>
<pre><code>struct Base &#123;

    virtual void foo();

&#125;;

struct A : Base 

&#123; 

    void foo() final; // A::foo 被覆写且是最终覆写

    void bar() final; // 错误：非虚函数不能被覆写或是 final

&#125;;

struct B final : A // struct B 为 final，不能被继承

&#123;

    void foo() override; // 错误： foo 不能被覆写，因为它在 A 中是 final

&#125;;
</code></pre>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><p>protected:<br>保护属性的数据或函数可被派生类成员访问    </p>
<p>我们的友元friend也是打破了封装性，但是是让友元对象和函数可以看到私有成员，protect是让派生类或者叫子类可以看到的保护的成员 </p>
<p>私有成员只能在类内函数访问，或者友元，其他无论什么方式继承的派生类都无法在基类外访问基类的私有成员。</p>
<p>三种继承 公有继承、私有继承、保护继承：<br>无非就是  class Derived：public Base{  、class Derived：private Base{、class Derived：protected Base{；<br>就是在继承的时候选择什么继承方式   </p>
<p>无论何种继承，其子类都是能访问父类的公有成员和保护成员的；</p>
<p>如果是公有继承，则基类的成员在派生类里还是维持原有属性，那么孙类还是可以访问基类的公有和保护成员； 派生类以外的其它函数    可以通过派生类的对象，访问从基类继承的公有成员, 但不能访问从基类继承的保护成员和私有成员。</p>
<p>如果是私有继承，则基类的成员在派生类里全部变成private私有属性，也就是孙类无法访问任何基类的成员；派生类以外的其它函数  不能通过派生类的对象，访问从基类继承的任何成员。</p>
<p>如果是保护继承，则基类的成员在派生类里，除了public成员变成保护成员以外，其他维持不变，也就是孙类还是可以访问到基类的公有和保护成员。但是类外，无法通过子类的对象访问其父类的共有成员了，因为他在子类中变成了保护成员，类外无法访问。   派生类以外的其它函数    不能通过派生类的对象，访问从基类继承的任何成员。  </p>
<pre><code>class A &#123;
public:       // 访问属性
  int i;

protected:

  int j;

private:

  int k;

&#125;;

class B: public A &#123;        // 此public为派生方式

public:       // 访问属性

  void display() &#123;

    cout &lt;&lt; i &lt;&lt; endl; // OK, can access i

    cout &lt;&lt; j &lt;&lt; endl; // OK, can access j

    cout &lt;&lt; k &lt;&lt; endl; // Error! cannot access k

  &#125;

&#125;;

int main() &#123;

  A a;

  cout &lt;&lt; a.i &lt;&lt; endl; // OK, can access a.i

  cout &lt;&lt; a.j &lt;&lt; endl; // Error, cannot access a.j

  cout &lt;&lt; a.k &lt;&lt; endl; // Error, cannot access a.k

&#125;
</code></pre>
<h2 id="抽象类与纯虚函数"><a href="#抽象类与纯虚函数" class="headerlink" title="抽象类与纯虚函数"></a>抽象类与纯虚函数</h2><p>包含抽象函数的类被称为抽象类 ，抽象类不能实例化（创建对象）<br>abstract class 派生类时，新类越来越明确和具体，沿着派生类向父类移动，类会越来越抽象，越往上，直到类太抽象了，无法实例化，那么就叫抽象类。     </p>
<p>抽象函数就是我太抽象了 无法实现的功能，但是我要求我的子类们必须都给完成了，比如一个图形的面积，我不知道啥图形啥参数，当然没办法求面积，但是我实现一个抽象函数，要求我的子类们比如，三角形类和圆形类都必须得把这个函数功能实现了。这个叫抽象函数。     </p>
<p>抽象函数也叫纯虚函数 要求子类实现它。</p>
<p>关键字virtual 加上取消函数体的大括号，换成 = 0；</p>
<pre><code>virtual double getArea() = 0;
</code></pre>
<p>这样生命了以后，子类必须实现这个getArea()纯虚函数才能够实例化一个对象 很好理解，因为派生类会继承基类的成员，所以基类里有个虚函数没被重定义，那么就相当于这个类也是个虚类，所以无法实现实例化       </p>
<p>包含纯虚函数的类就叫抽象类（不能实例化—不能创建对象）   </p>
<p>编译器处理虚函数的方法是给每个对象增加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，这个数组就叫虚函数表，虚函数表里存储了为类对象进行声明的虚函数的地址，调用虚函数的时候，程序查看存储在对象里的虚函数表，然后转向相应的函数地址表。   </p>
<p>使用虚函数在内存和执行时间上都有所开销：</p>
<ol>
<li>每个对象都将增大，增大量为存储地址的空间 </li>
<li>对于每个类，编译器都创建一个虚函数地址表（数组）</li>
<li>对于每个函数调用，都执行一项额外的操作，就是到这个表中查找地址。</li>
</ol>
<h2 id="动态类型转换"><a href="#动态类型转换" class="headerlink" title="动态类型转换"></a>动态类型转换</h2><p>通常来说C++不允许将一个类型的地址赋值给另一种类型的指针，也不允许一个类型的引用指向另一种类型。    </p>
<p>将派生类引用或指针转为基类引用或指针，被称为向上强制转换，这使得公有继承不需要进行显示类型转换。将基类指针或引用转为派生类指针或引用，叫向下强制转换，这个时候必须显示声明，因为is-a关系大部分时候是不可逆的，派生类里可能有新增的数据成员，因此这些数据的类成员函数不能应用于基类。 </p>
<p>这个时候显示声明强制转换就是需要运算符   dynamic_cast</p>
<p>dynamic_cast 运算符</p>
<p>(1)     沿继承层级向上、向下及侧向转换到类的指针和引用</p>
<p>(2)     转指针：失败返回nullptr</p>
<p>(3)     转引用：失败抛异常</p>
<pre><code>void printObject(Shape &amp;shape)
&#123;
  cout &lt;&lt; &quot;The area is &quot; 
       &lt;&lt; shape.getArea() &lt;&lt; endl;
  Shape *p = &amp;shape;
  Circle *c = dynamic_cast&lt;Circle*&gt;(p);
  // Circle&amp; c = dynamic_cast&lt;Circle&amp;&gt;(shape); 
  // 引用转换失败则抛出一个异常 std::bad_cast
  if (c != nullptr) // 转换失败则指针为空
  &#123;
    cout &lt;&lt; &quot;The radius is &quot; 
         &lt;&lt; p1-&gt;getRadius() &lt;&lt; endl;
    cout &lt;&lt; &quot;The diameter is &quot; 
         &lt;&lt; p1-&gt;getDiameter() &lt;&lt; endl;
  &#125;
&#125;
</code></pre>
<p>基类派生类对象转换的时候 </p>
<p>可将派生类对象截断，只使用继承来的信息</p>
<p>但不能将基类对象加长，无中生有变出派生类对象</p>
<h2 id="typeid"><a href="#typeid" class="headerlink" title="typeid"></a>typeid</h2><p>typeid returns a reference to an object of class type_info. (typeid运算符返回一个type_info对象的引用)</p>
<p>typeid(AType).name() 返回实现定义的，含有类型名称的C风格字符串(char *)</p>
<pre><code>#include &lt;typeinfo&gt;  //使用typeid，需要包含此头文件 

class A &#123;&#125;;

A a&#123;&#125;;

// ……

  auto&amp; t1 = typeid(a); // 注意这里是引用 要加&amp; 不然报错

  if (typeid(A) == t1) &#123;

    std::cout &lt;&lt; &quot;a has type &quot; 

              &lt;&lt; t1.name() &lt;&lt; std::endl;

  &#125;
</code></pre>
<h2 id="设置精度"><a href="#设置精度" class="headerlink" title="设置精度"></a>设置精度</h2><pre><code>#include &lt;iomanip&gt;
using std::cout;
using std::endl;
using std::string;
int main() &#123;
    
    float a = 17 / 7.0;
    cout &lt;&lt; std::setprecision(4) &lt;&lt; a;
    return 0;
&#125;
</code></pre>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>去掉最后一位    101101-&gt;10110    x&gt;&gt;1</p>
<p>在最后加一个0    101101-&gt;1011010    x&lt;&lt;1</p>
<p>在最后加一个1    101101-&gt;1011011    (x&lt;&lt;1)+1</p>
<p>把最后一位变成1    101100-&gt;101101    x | 1</p>
<p>把最后一位变成0    101101-&gt;101100    (x |1) - 1</p>
<p>最后一位取反    101101-&gt;101100    x ^ 1</p>
<p>把右数第K位变成1    101001-&gt;101101,k=3    x  | (1&lt;&lt;(k-1))</p>
<p>把右数第K位变成0    101101-&gt;101101,k=3    x &amp; ~(1&lt;&lt;(k-1))</p>
<p>右数第k位取反    101001-&gt;101101,k=3    x ^ (1&lt;&lt;(k-1))</p>
<p>取末三位    1101101-&gt;101    x &amp;7</p>
<p>取末k位    1101101-&gt;1101,k=5    x &amp; (1&lt;&lt;k-1)</p>
<p>取右数第k位    1101101-&gt;1,k=4    x &gt;&gt; (k-1)&amp;1</p>
<p>把末k位变成1    101001-&gt;101111,k=4    x|(1&lt;&lt;k-1)</p>
<p>末k位取反    101001-&gt;100110,k=4    x^(1&lt;&lt;k-1)</p>
<p>把右边连续的1变成0    100101111-&gt;100100000    x&amp;(x+1)</p>
<p>把右起第一个0变成1    100101111-&gt;100111111    x|(x+1)</p>
<p>把右边连续的0变成1    11011000-&gt;11011111    x|(x-1)</p>
<p>取右边连续的1    100101111-&gt;1111    (x^(x+1))&gt;&gt;1</p>
<p>去掉右起第一个1的左边    100101000-&gt;1000    x&amp;(x^(x-1))</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>iterator迭代器是一个变量，相当于容器和操纵容器的算法之间的中介。迭代器可以指向容器中的某个元素，通过迭代器就可以读写它指向的元素。从这一点上看，迭代器和指针类似。</p>
<p>正向迭代器，定义方法如下：</p>
<pre><code>容器类名::iterator  迭代器名;
</code></pre>
<ol start="2">
<li>常量正向迭代器，定义方法如下： 容器类名::const_iterator  迭代器名;</li>
</ol>
<ol start="3">
<li><p>反向迭代器，定义方法如下：</p>
<p> 容器类名::reverse_iterator  迭代器名;</p>
</li>
</ol>
<ol start="4">
<li>常量反向迭代器，定义方法如下： 容器类名::const_reverse_iterator  迭代器名;<br>通过迭代器可以读取它指向的元素，*迭代器名就表示迭代器指向的元素。通过非常量迭代器还能修改其指向的元素。</li>
</ol>
<p>迭代器都可以进行++操作。反向迭代器和正向迭代器的区别在于：<br>对正向迭代器进行++操作时，迭代器会指向容器中的后一个元素；<br>而对反向迭代器进行++操作时，迭代器会指向容器中的前一个元素。    </p>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h2><p>sort(first_pointer,first_pointer+n,cmp)<br>该函数可以给数组，或者链表list、向量排序。</p>
<p>实现原理：sort并不是简单的快速排序，它对普通的快速排序进行了优化，此外，它还结合了插入排序和推排序。系统会根据你的数据形式和数据量自动选择合适的排序方法，这并不是说它每次排序只选择一种方法，它是在一次完整排序中不同的情况选用不同方法，比如给一个数据量较大的数组排序，开始采用快速排序，分段递归，分段之后每一段的数据量达到一个较小值后它就不继续往下递归，而是选择插入排序，如果递归的太深，他会选择推排序。  </p>
<p>此函数有3个参数：</p>
<p>参数1：第一个参数是数组的首地址，一般写上数组名就可以，因为数组名是一个指针常量。</p>
<p>参数2：第二个参数相对较好理解，即首地址加上数组的长度n（代表尾地址的下一地址）。</p>
<p>参数3：默认可以不填，如果不填sort会默认按数组升序排序。也就是1,2,3,4排序。也可以自定义一个排序函数，改排序方式为降序什么的，也就是4,3,2,1这样。</p>
<p>使用此函数需先包含：</p>
<p>#include <algorithm><br>并且导出命名空间：</p>
<p>using namespace std;<br>简单例子：对数组A的0~n-1元素进行升序排序，只要写sort(A,A+n)即可；对于向量V也一样，sort(v.begin(),v.end())即可。</p>
<p>自己编写排序规则函数</p>
<p>例如：</p>
<pre><code>bool compare(int a,int b)
&#123;
return a&lt;b; //升序排列，如果改为return a&gt;b，则为降序
&#125;

//情况二：结构体排序
Student Stu[100];
bool cmp2(Student a,Student b)
&#123;
return a.id&gt;b.id;//按照学号降序排列
//return a.id&lt;b.id;//按照学号升序排列
&#125;
sort(Stu,Stu+100,cmp2);
</code></pre>
<p>方法二：使用标准库函数</p>
<p>include <functional> 这是标准库可以不include 提供了一堆基于模板的比较函数对象，它们是：equal_to<Type>、not_equal_to<Type>、greater<Type>、greater_equal<Type>、less<Type>、less_equal<Type>。这些东西的用法看名字就知道了。在这里，我么sort要用到的也只是greater和less就足够了，用法如下：</p>
<p>● 升序：sort(begin,end,less<data-type>())<br>● 降序：sort(begin,end,greater<data-type>())     </p>
<p>方法三：重载结构体或类的比较运算符</p>
<pre><code>//情况一：在结构体内部重载
typedef struct Student&#123;
int id;
string name;
double grade;

bool operator&lt;(const Student&amp; s) const
&#123;
return id&gt;s.id;//降序排列
//return id&lt;s.id;//升序排列
&#125;
&#125;;
vector&lt;Student&gt; V;
sort(V.begin(),V.end());
//情况二：在外部重载
vector&lt;Student&gt; V;
bool operator&lt;(const Student&amp; s1, const Student&amp; s2)  //一定要记得加const
const&#123;
return s1.id&gt;s2.id;//降序排列
//return s1.id&lt;s2.id;//升序排列
&#125;
sort(V.begin(),V.end());
</code></pre>
<p>注意：一定要重载&lt;运算符，因为系统默认是降序，用的是&lt;运算符。</p>
<h2 id="C-不允许嵌套声明函数"><a href="#C-不允许嵌套声明函数" class="headerlink" title="C++不允许嵌套声明函数"></a>C++不允许嵌套声明函数</h2><p>不可以嵌套定义函数，每一个函数都有一个内存地址，这个地址是函数入口，它是不可以在其他函数中定义的，比如：想要调用嵌套定义的函数，如果不调用上级函数，是没有办法调用的。但是函数可以嵌套调用。    </p>
<h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>有些情况比如以下，就会出现，p1是字符指针，但是p2 是字符变量的情况。</p>
<pre><code>int main()&#123;
    char* p1, p2;
    cout &lt;&lt; typeid(p1).name() &lt;&lt; &quot; &quot; &lt;&lt; typeid(p2).name() &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p>这个时候可以用typedef 定义一种类型的别名，而不只是简单的宏替换<br>比如long long 我们可以定义为 ll 这样就避免了写大量数据  </p>
<pre><code>typedef char* CHARP;  //记得分号
int main()&#123;
    CHARP p1, p2;
    char pp = &#39;a&#39;;
    p2 = &amp;pp;
    cout &lt;&lt; *p2;
    return 0;
&#125;
</code></pre>
<h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><p>pair是将2个数据组合成一组数据，当需要这样的需求时就可以使用pair，如stl中的map就是将key和value放在一起来保存。另一个应用是，当一个函数需要返回2个数据的时候，可以选择pair。 pair的实现是一个结构体，主要的两个成员变量是first second 因为是使用struct不是class，所以可以直接使用pair的成员变量。</p>
<p>其标准库类型–pair类型定义在#include <utility>头文件中，定义如下：</p>
<p>类模板：template&lt;class T1,class T2&gt; struct pair</p>
<p>参数：T1是第一个值的数据类型，T2是第二个值的数据类型。</p>
<p>功能：pair将一对值(T1和T2)组合成一个值，</p>
<p>        这一对值可以具有不同的数据类型（T1和T2），</p>
<p>        两个值可以分别用pair的两个公有函数first和second访问。</p>
<p>pair包含两个数值，与容器一样，pair也是一种模板类型。</p>
<pre><code>pair&lt;string, int&gt; word_count; 
pair&lt;string, int&gt; name_age(&quot;Tom&quot;, 18);
</code></pre>
<p>可以用typedef 来简化摸板</p>
<pre><code>typedef pair&lt;string,string&gt; Author;
Author proust(&quot;March&quot;,&quot;Proust&quot;);
pair&lt;int, double&gt; p2 = p1; 
</code></pre>
<p>初始化：</p>
<pre><code>typedef pair&lt;int, int&gt; PAIR;
int main() &#123;
    pair&lt;int, int&gt; p1(1, 2);
    /*cout &lt;&lt; p1.first;*/
    pair&lt;int, int&gt; p2 = p1;
    PAIR p3&#123; p1 &#125;;
    cout &lt;&lt; p3.first &lt;&lt; &quot; &quot; &lt;&lt; p3.second;
    return 0;
&#125;
</code></pre>
<p>pair对象的操作  访问两个元素操作可以通过.first和.sencond访问 </p>
<p>还可以利用make_pair创建新的pair对象</p>
<pre><code>pair&lt;int, double&gt; p1;
 p1 = make_pair(1, 1.2);
</code></pre>
<p>函数会以pair对象作为返回值时，可以直接通过std::tie进行接收</p>
<pre><code>std::pair&lt;std::string, int&gt; getPreson() &#123;
    return std::make_pair(&quot;Sven&quot;, 25);
&#125;
 
int main(int argc, char **argv) &#123;
    std::string name;
    int ages;
 
    std::tie(name, ages) = getPreson();
 
    std::cout &lt;&lt; &quot;name: &quot; &lt;&lt; name &lt;&lt; &quot;, ages: &quot; &lt;&lt; ages &lt;&lt; std::endl;
 
    return 0;
&#125;
</code></pre>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map是有一颗红黑树实现的，所有数据都是有序的，对数据自动排序  是有序键值对容器，它的元素的键是唯一的。用比较函数 Compare 排序键。搜索、移除和插入操作拥有对数复杂度。</p>
<p>头文件在 <map></p>
<p>insert<br>size</p>
<p>初始化：</p>
<pre><code>map&lt;int, int&gt; dic&#123; &#123;1,2&#125;, &#123;2,3&#125;, &#123;4,5&#125; &#125;;
</code></pre>
<p>访问：     </p>
<ol>
<li>operator[]  如果key 存在则返回 value ，如果没有这个key则是返回 default值，int类型是0，字符串类型是 空字符串  </li>
<li>map.at(first) 这里如果越界first不存在则会异常  </li>
</ol>
<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;
 
int main() &#123;
  std::map&lt;int, float&gt; num_map;
  num_map[4] = 4.13;
  num_map[9] = 9.24;
  num_map[1] = 1.09;
  // 调用 a_map.begin() 与 a_map.end()
  for (auto it = num_map.begin(); it != num_map.end(); ++it) &#123;
    std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot;, &quot; &lt;&lt; it-&gt;second &lt;&lt; &#39;\n&#39;;
  &#125;
&#125;
</code></pre>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入:"></a>插入:</h3><p>其中operator[] 访问可以更新，但是insert方法则如果first也就是key已经存在情况下，则会拒绝更新插入新value值也就是second。    </p>
<ol>
<li>operator[first] = second;</li>
<li>insert(pair&lt;type1, type2&gt;(first, second));</li>
<li>insert(make_pair(first, second));</li>
<li>insert(map&lt;type1, type2&gt;::value_type(first, second));</li>
</ol>
<pre><code>map&lt;int, string&gt; dic;
 //插入数据
dic[1] = &quot;Hello map~&quot;;
dic[1] = &quot;nihao map&quot;; // 这会更新first 为1 的second
dic.insert(map&lt;int, string&gt;::value_type(2, &quot;Hello C++&quot;));
dic.insert(map&lt;int, string&gt;::value_type(2, &quot;Hello C plus plus&quot;)); // 还是 2 对应的还是 Hello C++ 就是不更新了
dic.insert(std::make_pair(3, &quot;hello makabaka&quot;));
dic.insert(pair&lt;int, string&gt;(3, &quot;hello feifeiyu&quot;)); // 还是 3 对应的还是 hello makabaka 就是不更新了
cout &lt;&lt; dic[3] &lt;&lt; endl;
return 0;
</code></pre>
<h3 id="迭代器："><a href="#迭代器：" class="headerlink" title="迭代器："></a>迭代器：</h3><p>begin():<br>返回指向 map 首元素的迭代器。</p>
<p>若 map 为空，则返回的迭代器将等于 end() 。    </p>
<pre><code>#include &lt;iostream&gt;
#include &lt;map&gt;
 
int main() &#123;
  std::map&lt;int, float&gt; num_map;
  num_map[4] = 4.13;
  num_map[9] = 9.24;
  num_map[1] = 1.09;
  // 调用 a_map.begin() 与 a_map.end()
  for (auto it = num_map.begin(); it != num_map.end(); ++it) &#123;
    std::cout &lt;&lt; it-&gt;first &lt;&lt; &quot;, &quot; &lt;&lt; it-&gt;second &lt;&lt; &#39;\n&#39;;
  &#125;
&#125;
</code></pre>
<p>我们定义一个map迭代器通常可以用auto直接初始化的，如果没法直接初始化的，迭代器类型是  map&lt;type1, type2&gt;::iterator  </p>
<pre><code>map&lt;int, int&gt; dic;
auto it = dic.begin();
map&lt;int, int&gt;::operator it2 = dic.begin();
</code></pre>
<h3 id="查找："><a href="#查找：" class="headerlink" title="查找："></a>查找：</h3><ol>
<li><p>判断是否存在用count,C++20出了个contains<br>map.count(first) 如果存在则返回 1，不存在返回0。 </p>
</li>
<li><p>当然如果用数组方式，就是如果不存在就返回一个空的second类型，比如map&lt;int, string&gt;如果 map[first] first不存在，则返回一个空字符串    </p>
</li>
<li><p>find函数返回一个迭代器，key在里面则返回数据所在位置的迭代器，找到了则可以通过 map.find(key) -&gt; second 访问value值。如果map中没有查找的数据，则返回的是map.end()迭代器。</p>
<p> auto iter = dic.find(1);<br> cout &lt;&lt; iter-&gt;second;</p>
</li>
<li><p>equal_range 返回容器中所有拥有给定关键的元素范围。范围以二个迭代器定义，一个指向首个不小于 key 的元素，另一个指向首个大于 key 的元素。首个迭代器可以换用 lower_bound() 获得，而第二迭代器可换用 upper_bound() 获得。</p>
<p> std::pair&lt;iterator,iterator&gt; equal_range( const Key&amp; key );</p>
</li>
</ol>
<p>返回两个迭代器，含一对定义所需范围的迭代器的 std::pair ：第一个指向首个不小于 key 的元素，第二个指向首个大于 key 的元素。若无元素不小于 key ，则将尾后（见 end() ）迭代器作为第一元素返回。类似地，若无元素大于 key ，则将尾后迭代器作为第二元素返回。</p>
<h3 id="删除：erase"><a href="#删除：erase" class="headerlink" title="删除：erase"></a>删除：erase</h3><p>erase 有三个重载函数<br>一个是迭代器删除    迭代器删除是返回迭代器的iterator erase( iterator pos );也就是说 删除完以后，会整体前移，所以这里，迭代器指向下一个元素。<br>一个是关键字删除<br>一个是迭代器上下介，左闭右开批量删除  </p>
<p>如果是关键字删除，erase返回删除键的个数。</p>
<pre><code>dic.erase(1);  // 用first关键字 删除 
dic.erase(dic.find(2)); // 用迭代器删除  
dic.erase(dic.begin(), dic.end()); //迭代器区间 左闭右开 批量删除
</code></pre>
<p>再用迭代器删除的时候 ，千万注意，删除一个元素后 迭代器指向的是下一个元素，因为后面整体前移了。</p>
<pre><code>int main()
&#123;
    std::map&lt;int, std::string&gt; c = &#123;% row %&#125;&#123;  &#123;1, "one"&#125;, &#123;2, "two"&#125;, &#123;3, "three"&#125;,&#123;4, "four"&#125;, &#123;5, "five"&#125;, &#123;6, "six"&#125;  &#125;;&#123;% endrow %&#125;
    // 从 c 擦除所有奇数
    for (auto it = c.begin(); it != c.end(); )
        if (it-&gt;first % 2 == 1)
            it = c.erase(it);    // 这里it要重新赋值 
        else
            ++it;  // 如果这里不这么写 而是放在循环体里，如果两个奇数放一起，则会出现跳过的情况   
    for (auto&amp; p : c)
        std::cout &lt;&lt; p.second &lt;&lt; &#39; &#39;;
&#125;
</code></pre>
<h3 id="容量："><a href="#容量：" class="headerlink" title="容量："></a>容量：</h3><ol>
<li><p>大小：<br>大小还是size() 函数没差，返回有多少个key,也就是first个数  </p>
</li>
<li><p>是否为空：<br>bool: empty()  </p>
</li>
<li><p>最大容量:<br>max_size()  </p>
</li>
</ol>
<p>修改器：</p>
<ol>
<li>清空  map.clear();</li>
<li>交换  swap(map1, map2); 或者 map1.swap(map2); 不用容量相等，但两者类型必须相等   </li>
</ol>
<h2 id="遍历的时候可以当python-list用"><a href="#遍历的时候可以当python-list用" class="headerlink" title="{} 遍历的时候可以当python list用"></a>{} 遍历的时候可以当python list用</h2><pre><code>int main() &#123;
    for (int i : &#123;2, 3, 3&#125;)
        cout &lt;&lt; i &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set 和map 基本类似 就是没有 value 只有key 而且去重<br>set 是关联容器，含有 Key 类型对象的已排序集。用比较函数 比较 (Compare) 进行排序。搜索、移除和插入拥有对数复杂度。 set 通常以红黑树实现。<br><set><br> set进行遍历注意点<br>（1）红黑树的遍历是走的中序，则s.begin()是红黑树的最左结点；<br>（2）s.end()是最后一个数据的下一个位置；<br>（3）++it1仍然是按照中序的方式（左根右）；     </p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><pre><code>struct Point &#123; double x, y; &#125;;
struct PointCmp &#123;
    bool operator()(const Point&amp; lhs, const Point&amp; rhs) const &#123; 
        return std::hypot(lhs.x, lhs.y) &lt; std::hypot(rhs.x, rhs.y); 
    &#125;
&#125;;
 
int main()
&#123;
  // (1) 默认初始化器
  std::set&lt;std::string&gt; a;
  a.insert(&quot;cat&quot;);
  a.insert(&quot;dog&quot;);
  a.insert(&quot;horse&quot;);
  for(auto&amp; str: a) std::cout &lt;&lt; str &lt;&lt; &#39; &#39;;
  std::cout &lt;&lt; &#39;\n&#39;;
 
  // (2) 迭代器初始化器
  std::set&lt;std::string&gt; b(a.find(&quot;dog&quot;), a.end());
  for(auto&amp; str: b) std::cout &lt;&lt; str &lt;&lt; &#39; &#39;;
  std::cout &lt;&lt; &#39;\n&#39;;
 
  // (3) 复制构造函数
  std::set&lt;std::string&gt; c(a);
  c.insert(&quot;another horse&quot;);
  for(auto&amp; str: c) std::cout &lt;&lt; str &lt;&lt; &#39; &#39;;
  std::cout &lt;&lt; &#39;\n&#39;;
 
  // (4) 移动构造函数
  std::set&lt;std::string&gt; d(std::move(a));
  for(auto&amp; str: d) std::cout &lt;&lt; str &lt;&lt; &#39; &#39;;
  std::cout &lt;&lt; &#39;\n&#39;;
  std::cout &lt;&lt; &quot;moved-from set is &quot;;
  for(auto&amp; str: a) std::cout &lt;&lt; str &lt;&lt; &#39; &#39;;
  std::cout &lt;&lt; &#39;\n&#39;;
 
  // (5) initializer_list 构造函数
  std::set&lt;std::string&gt; e &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;five&quot;, &quot;eight&quot;&#125;;
  for(auto&amp; str: e) std::cout &lt;&lt; str &lt;&lt; &#39; &#39;;
  std::cout &lt;&lt; &#39;\n&#39;;
 
  // 自定义比较
  std::set&lt;Point, PointCmp&gt; z = &#123;&#123;2, 5&#125;, &#123;3, 4&#125;, &#123;1, 1&#125;&#125;;
  z.insert(&#123;1, -1&#125;); // 这会失败，因为 1,-1 的长度等于 1,1
  for(auto&amp; p: z) std::cout &lt;&lt; &#39;(&#39; &lt;&lt; p.x &lt;&lt; &#39;,&#39; &lt;&lt; p.y &lt;&lt; &quot;) &quot;;
  std::cout &lt;&lt; &#39;\n&#39;;
&#125;
</code></pre>
<p>输出<br>    cat dog horse<br>    dog horse<br>    another horse cat dog horse<br>    cat dog horse<br>    moved-from set is<br>    eight five one three two<br>    (1,1) (3,4) (2,5)</p>
<p>举个重载运算符的例子<br>    class Student {<br>    public:<br>        int id, grade;<br>        Student() = default;<br>        Student(int id_, int grade_) {<br>            id = id_, grade = grade_;<br>        }<br>        bool operator &lt; (const Student s2) const{  //这里的const不能少<br>            return this-&gt;grade &gt; s2.grade;<br>        }<br>    };</p>
<pre><code>int main() &#123;
    set&lt;Student&gt; table;
    table.insert(Student(1, 99));
    table.insert(Student(2, 98));
    table.insert(Student(3, 100));
    for (auto item : table) &#123;
        cout &lt;&lt; item.id &lt;&lt; &#39; &#39; &lt;&lt; item.grade &lt;&lt; endl;
    &#125;
    return 0;
&#125;
</code></pre>
<p>其他基本和map无差</p>
<h3 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h3><p>begin\end\rbegin\rend   </p>
<h3 id="容量"><a href="#容量" class="headerlink" title="容量"></a>容量</h3><p>empty、size、max_size     </p>
<h3 id="修改器"><a href="#修改器" class="headerlink" title="修改器"></a>修改器</h3><p>clear、insert、erase、swap<br>insert:    返回一个指向这个的迭代器，和bool值也就是插入成功与否 如果有值则插入不成功  </p>
<pre><code>    std::pair&lt;iterator,bool&gt; insert( value_type&amp;&amp; value );
    void insert( InputIt first, InputIt last ); //迭代器起始终止位置，array set vector任何有迭代器容器都行
</code></pre>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>count、find、contians、equal_range、lower_bound、upper_bound</p>
<h3 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h3><p>哈希表 哈希实现  插入删除查找都是o(1) 和python dict 一样  </p>
<h3 id="访问："><a href="#访问：" class="headerlink" title="访问："></a>访问：</h3><p> 插入的是一个pair， 所以类型也是pair</p>
<pre><code>for(auto&amp; p: dict)
    std::cout &lt;&lt; &quot; &quot; &lt;&lt; p.first &lt;&lt; &quot; =&gt; &quot; &lt;&lt; p.second &lt;&lt; &#39;\n&#39;;
</code></pre>
<h3 id="迭代器-2"><a href="#迭代器-2" class="headerlink" title="迭代器"></a>迭代器</h3><p>begin() \ end()</p>
<h3 id="容量-1"><a href="#容量-1" class="headerlink" title="容量"></a>容量</h3><p>empty()\ size()\ max_size()</p>
<h3 id="修改器-1"><a href="#修改器-1" class="headerlink" title="修改器"></a>修改器</h3><p>clear()\<br>insert插入 但是插入值不更新，如果键已存在，则不更新    </p>
<p>可以用 make_pair 、{first，second}等形式<br>    int main ()<br>    {<br>    std::unordered_map&lt;int, std::string&gt; dict = { {1, “one”}, {2, “two”} };<br>    dict.insert({3, “three”});<br>    dict.insert(std::make_pair(4, “four”));<br>    dict.insert({ {4, “another four”}, {5, “five”} });<br>    dict.insert(pair&lt;int, string&gt; (5, “hello”));<br>    bool ok = dict.insert({1, “another one”}).second;<br>    std::cout &lt;&lt; “inserting 1 -&gt; &quot;another one&quot; “<br>              &lt;&lt; (ok ? “succeeded” : “failed”) &lt;&lt; ‘\n’;</p>
<p>erase  和map里的基本一样<br>从容器移除指定的元素。</p>
<ol>
<li>移除位于 pos 的元素。</li>
<li>移除范围 [first; last) 中的元素，它必须是 *this 中的合法范围。</li>
<li>移除关键等于 key 的元素（若存在一个）。</li>
</ol>
<p>swap交换 也一样 </p>
<pre><code>map1.swap(map2);
swap(map1, map2);
</code></pre>
<h3 id="查找：-1"><a href="#查找：-1" class="headerlink" title="查找："></a>查找：</h3><ol>
<li>at 越界检查</li>
<li>operator [] 不越界检察</li>
<li>count 返回特点键 数量</li>
<li>find() 返回特定键的元素 返回迭代器</li>
<li>contains</li>
</ol>
<h3 id="桶"><a href="#桶" class="headerlink" title="桶"></a>桶</h3><p>bucket_count 是C++ STL中的内置函数，该函数返回unordered_set容器中存在的存储桶总数。 存储桶是unordered_set内部哈希表中的一个存储元素的插槽。 举个例子，就是如果只有6各元素，也是8个桶，如果是9个元素，就是64个桶，成指数增加桶，为了存储这个key </p>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p>双端队列 两端进出O(1) 同python的deque</p>
<p>std::deque （ double-ended queue ，双端队列）是有下标顺序容器，它允许在其首尾两段快速插入及删除。另外，在 deque 任一端插入或删除不会非法化指向其余元素的指针或引用。</p>
<p>与 std::vector 相反， deque 的元素不是相接存储的：典型实现用单独分配的固定大小数组的序列，外加额外的登记，这表示下标访问必须进行二次指针解引用，与之相比 vector 的下标访问只进行一次。</p>
<p>deque 的存储按需自动扩展及收缩。扩张 deque 比扩张 std::vector 更优，因为它不涉及到复制既存元素到新内存位置。另一方面， deque 典型地拥有较大的最小内存开销；只保有一个元素的 deque 必须分配其整个内部数组（例如 64 位 libstdc++ 上为对象大小 8 倍； 64 位 libc++ 上为对象大小 16 倍或 4096 字节的较大者）。</p>
<p>deque 上常见操作的复杂度（效率）如下：</p>
<p>随机访问——常数 O(1)<br>在结尾或起始插入或移除元素——常数 O(1)<br>插入或移除元素——线性 O(n)</p>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><ol>
<li>指针初始化：<br> int arr[10] = { 1,2,3,4,5,6,7,8,9 };<br> deque<int> dq(arr, arr + 10);<br> array arr = { 1,2,3,4,5,6,7,8,9 };<br> deque<int> dq(arr.begin(), arr.end());<br> deque<int> dq(4,2); // {2,2,2,2}</li>
</ol>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><ol>
<li>operator =</li>
<li>assign dq.assign(4, 2);<br> dq.assign(arr.begin(), arr.end());</li>
</ol>
<h3 id="元素访问"><a href="#元素访问" class="headerlink" title="元素访问"></a>元素访问</h3><ol>
<li>at()</li>
<li>operator []</li>
<li>front()  第一个元素的引用</li>
<li>back()   最后一个元素的引用<h3 id="迭代器-3"><a href="#迭代器-3" class="headerlink" title="迭代器"></a>迭代器</h3>begin()\end()\rbegin()\rend()<h3 id="容量-2"><a href="#容量-2" class="headerlink" title="容量"></a>容量</h3>empty()\size()\max_size()</li>
</ol>
<p>###修改器<br>clear()\push_back()\pop_back()\push_front()\pop_front()\resize()\swap()</p>
<p>insert</p>
<pre><code>insert(pos:const_iterator, element):iterator 
</code></pre>
<p>erase<br>    (1)<br>iterator erase( iterator pos );<br>iterator erase( iterator first, iterator last );</p>
<ol>
<li>移除位于 pos 的元素。</li>
<li>移除范围 [first; last) 中的元素。  </li>
</ol>
<h3 id="shrink-to-fit"><a href="#shrink-to-fit" class="headerlink" title="shrink_to_fit"></a>shrink_to_fit</h3><p>请求移除未使用的容量。</p>
<p>它是减少使用内存而不更改序列的大小非强制性请求。请求是否达成依赖于实现。</p>
<p>所有迭代器和引用都被非法化。尾后迭代器亦被非法化。</p>
<pre><code>int main() &#123;
    std::deque&lt;int&gt; nums(1000, 42);
    nums.push_front(1);
    nums.pop_front();
 
    nums.clear();
 
    // nums 现在不含项目，但它仍保有分配的内存。
    // 调用 shrink_to_fit 可能会释放任何不使用的内存。
    nums.shrink_to_fit();
&#125;
</code></pre>
<h2 id="heap"><a href="#heap" class="headerlink" title="heap"></a>heap</h2><p>头文件<algorithm>   </p>
<p>虽然STL中关于heap默认调整成的是大顶堆，但却可以让用户利用自定义的compare_fuction函数实现大顶堆或小顶堆。   </p>
<p>is_heap(iter_begin, iter_end) 是不是个堆<br>sort_heap(iter_begin, iter_end)  堆排序   </p>
<pre><code>void sort_heap(first_pointer,end_pointer,compare_function);
</code></pre>
<p>make_heap()是把容器中制定迭代器之间的元素进行建堆操作<br>一个参数是数组或向量的头指针，第二个向量是尾指针。第三个参数是比较函数的名字<br>。在缺省的时候，默认是大跟堆。</p>
<pre><code>void make_heap(first_pointer,end_pointer,compare_function);  
</code></pre>
<p>push_heap，把容器最末尾的元素进行上调，即相当于是插入一个元素，因此如果要往堆中插入元素，例如vector构成的堆，应该先用push_back()函数将一个元素插入到vector容器的末尾，然后调用push_heap()函数进行上调。push_heap()假设由[first,last-1)是一个有效的堆，然后，再把堆中的新元素加进来，做成一个堆。     </p>
<pre><code>void push_heap(first_pointer,end_pointer,compare_function);
</code></pre>
<p>pop_heap，把堆顶元素删除，此时的删除是把对顶的元素，和最末尾的元素进行交换，然后进行下虑操作。此后，vector中最后一个元素就是刚才从堆中pop出来的元素，此时只需要将这个元素在vector中进行pop_back()即可删除，维护这个堆。pop_heap()不是真的把最大（最小）的元素从堆中弹出来。而是重新排序堆。把first和last交换，然后将[first,last-1)的数据再做成一个堆。</p>
<pre><code>void pop_heap(first_pointer,end_pointer,compare_function);
</code></pre>
<h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p>C++ STL默认的priority_queue是将优先级最大的放在队列最前面，也即是最大堆。】</p>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>可以用迭代器构造，也可以vector(num, value)的这个形式赋初值<br>    int main() {<br>        vector<int> arr{ 1,2,3,4,5 };<br>        priority_queue<int> q(arr.begin(), arr.end());<br>        while (!q.empty()) {<br>            cout &lt;&lt; q.top() &lt;&lt; endl;<br>            q.pop();<br>        }<br>        return 0;<br>    }</p>
<pre><code>priority_queue&lt;int&gt; q(10,1);
</code></pre>
<h3 id="元素访问-1"><a href="#元素访问-1" class="headerlink" title="元素访问"></a>元素访问</h3><p>只能访问栈顶元素  </p>
<pre><code>q.top()
</code></pre>
<h3 id="容量-3"><a href="#容量-3" class="headerlink" title="容量"></a>容量</h3><p>empty(), size(),</p>
<h3 id="修改器-2"><a href="#修改器-2" class="headerlink" title="修改器"></a>修改器</h3><p>push().pop(),swap()</p>
<h2 id="NULL-和-nullptr"><a href="#NULL-和-nullptr" class="headerlink" title="NULL 和 nullptr"></a>NULL 和 nullptr</h2><p>在这段代码中，我们对函数func进行可重载，参数分别是void*类型和int类型，但是运行结果却与我们使用NULL的初衷是相违背的，因为我们本来是想用NULL来代替空指针，但是在将NULL输入到函数中时，它却选择了int形参这个函数版本，所以是有问题的，这就是用NULL代替空指针在C++程序中的二义性。</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

void func(void* i)
&#123;
    cout &lt;&lt; &quot;func1&quot; &lt;&lt; endl;
&#125;

void func(int i)
&#123;
    cout &lt;&lt; &quot;func2&quot; &lt;&lt; endl;
&#125;

void main(int argc, char* argv[])
&#123;
    func(NULL);
    func(nullptr);
    getchar();
&#125;
</code></pre>
<p>输出：</p>
<pre><code>func2
func1
</code></pre>
<p>总结：</p>
<p>NULL在C++中就是0，这是因为在C++中void* 类型是不允许隐式转换成其他类型的，所以之前C++中用0来代表空指针，但是在重载整形的情况下，会出现上述的问题。所以，C++11加入了nullptr，可以保证在任何情况下都代表空指针，而不会出现上述的情况，因此，建议以后还是都用nullptr替代NULL吧，而NULL就当做0使用。</p>
<h2 id="关于溢出："><a href="#关于溢出：" class="headerlink" title="关于溢出："></a>关于溢出：</h2><pre><code>long long tmp = nums[i] - nums[i - 1]; //这种写法还是会溢出，因为等号后面默认还是原来的int类型，如果算出来的值溢出了，还是会溢出 要这么写
long long tmp = (long long) nums[i] - nums[i - 1];
</code></pre>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>这么来理解 现在有10个 0-1之间的小数，桶排序就是比如说我每 0.25建立一个桶，然后装进来，在0-0.25， 0.25- 0.5之间就是一个桶 ，放在一起就是一个桶  。可以设置一个区间，然后用个getid函数判断这个数应该落在第几个桶里，存不存在这号元素的桶就直接用哈希表来找。</p>
<h2 id="输入一个数组"><a href="#输入一个数组" class="headerlink" title="输入一个数组"></a>输入一个数组</h2><p>知道长度比较容易 直接for循环来取值</p>
<pre><code>int num;
for (int i = 0; i &lt; 5; i++) &#123;
    cin &gt;&gt; num;
    vec1.push_back(num);
&#125;
</code></pre>
<p>输入一个数组（多个数组就多几个循环或者写成函数 多次调用实现）</p>
<pre><code>vector&lt;int&gt; vec1;
vector&lt;int&gt; vec2;
int num;
while (cin &gt;&gt; num) &#123;
    vec1.push_back(num);
    if (cin.get() == &#39;\n&#39;)
        break;
&#125;

或者

while (1) &#123;
    cin &gt;&gt; num;
    vec1.push_back(num);
    if (cin.get() == &#39;\n&#39;)
        break;
&#125;
</code></pre>
<p>cin会忽略‘\n’</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://andrekuu.github.io/2021/04/22/C++%E5%AD%A6%E6%97%A0%E6%AD%A2%E5%A2%83/" data-id="cknscjo0v0008egve03lweq9g" data-title="C++学无止境" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/22/Linux/">Linux</a>
          </li>
        
          <li>
            <a href="/2021/04/22/Mysql%E5%9F%BA%E7%A1%80/">Mysql基础</a>
          </li>
        
          <li>
            <a href="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/">计算机网络细节</a>
          </li>
        
          <li>
            <a href="/2021/04/22/LeetCode-%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/">LeetCode 周赛总结</a>
          </li>
        
          <li>
            <a href="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 AndreKuu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>