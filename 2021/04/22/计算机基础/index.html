<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>计算机基础 | AndreKuu</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="存储层次结构除了存储器和外部记录介质以外，运算器也是存储结构中的一员，因为CPU中的通用寄存器包含在运算器中，所以运算器也算含有存储功能的部件。   存储器的特性： 非易失性 可读可写 随机访问 访问时间 容量 价格 功耗  易失性：通电后就会丢失数据的存储器我们称其为易失性存储器，反之则为非易失性存储器。CPU内的通用存储器和内存都是易失性的，而BIOS芯片（Basic Input Output">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机基础">
<meta property="og:url" content="https://andrekuu.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="AndreKuu">
<meta property="og:description" content="存储层次结构除了存储器和外部记录介质以外，运算器也是存储结构中的一员，因为CPU中的通用寄存器包含在运算器中，所以运算器也算含有存储功能的部件。   存储器的特性： 非易失性 可读可写 随机访问 访问时间 容量 价格 功耗  易失性：通电后就会丢失数据的存储器我们称其为易失性存储器，反之则为非易失性存储器。CPU内的通用存储器和内存都是易失性的，而BIOS芯片（Basic Input Output">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-04-21T19:39:25.000Z">
<meta property="article:modified_time" content="2021-04-21T19:40:38.814Z">
<meta property="article:author" content="AndreKuu">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="AndreKuu" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">AndreKuu</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://AndreKuu.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-计算机基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2021-04-21T19:39:25.000Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      计算机基础
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="存储层次结构"><a href="#存储层次结构" class="headerlink" title="存储层次结构"></a>存储层次结构</h2><p>除了存储器和外部记录介质以外，运算器也是存储结构中的一员，因为CPU中的通用寄存器包含在运算器中，所以运算器也算含有存储功能的部件。  </p>
<h3 id="存储器的特性："><a href="#存储器的特性：" class="headerlink" title="存储器的特性："></a>存储器的特性：</h3><ul>
<li>非易失性</li>
<li>可读可写</li>
<li>随机访问</li>
<li>访问时间</li>
<li>容量</li>
<li>价格</li>
<li>功耗</li>
</ul>
<h3 id="易失性："><a href="#易失性：" class="headerlink" title="易失性："></a>易失性：</h3><p>通电后就会丢失数据的存储器我们称其为易失性存储器，反之则为非易失性存储器。CPU内的通用存储器和内存都是易失性的，而BIOS芯片（Basic Input Output System，基本输入输出系统，是用于计算机开机过程中各种硬件设备的初始化和检测的芯片）和硬盘则是非易失性的。</p>
<h3 id="开机后的程序是CPU从BIOS芯片开始执行程序，把硬盘初始化配置好以后，再把硬盘数据搬运到内存，之后CPU才可以在内存中运行程序。"><a href="#开机后的程序是CPU从BIOS芯片开始执行程序，把硬盘初始化配置好以后，再把硬盘数据搬运到内存，之后CPU才可以在内存中运行程序。" class="headerlink" title="开机后的程序是CPU从BIOS芯片开始执行程序，把硬盘初始化配置好以后，再把硬盘数据搬运到内存，之后CPU才可以在内存中运行程序。"></a>开机后的程序是CPU从BIOS芯片开始执行程序，把硬盘初始化配置好以后，再把硬盘数据搬运到内存，之后CPU才可以在内存中运行程序。</h3><h3 id="可读可写："><a href="#可读可写：" class="headerlink" title="可读可写："></a>可读可写：</h3><p>BIOS只可读（要借助专用设备才可写），其他存储器基本都支持可读可写。</p>
<h3 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h3><p>对存储器中的数据访问所花费的时间与这个数据所在的位置没有关系。（非随机访问的典型就是磁带）<br>内存和BIOS都是支持随机访问的，而硬盘不支持，硬盘是多个盘片构成的，盘片处于高速旋转状态，并有一个机械读写头去寻找需要访问数据的位置，这就是非随机访问的模式。</p>
<h3 id="为什么需要一个cache高速缓存？"><a href="#为什么需要一个cache高速缓存？" class="headerlink" title="为什么需要一个cache高速缓存？"></a>为什么需要一个cache高速缓存？</h3><p>因为随着硬件的发展，CPU的运行速度得到了巨幅的提升，而主存DRAM的数据读取速度的提升则远不及此。导致，cpu运行效率和DRAM主存的运行效率差距过大，这严重影响了CPU的性能。</p>
<h3 id="层次化的存储结构-CPU通用寄存器Byte量级–SRAM高速缓存KB-MB量级–DRAM主存MB-GB量级–DISK磁盘GB-TB量级-容量越来越大但是速度更慢，但单位字节成本更低"><a href="#层次化的存储结构-CPU通用寄存器Byte量级–SRAM高速缓存KB-MB量级–DRAM主存MB-GB量级–DISK磁盘GB-TB量级-容量越来越大但是速度更慢，但单位字节成本更低" class="headerlink" title="层次化的存储结构 CPU通用寄存器Byte量级–SRAM高速缓存KB\MB量级–DRAM主存MB\GB量级–DISK磁盘GB\TB量级  容量越来越大但是速度更慢，但单位字节成本更低"></a>层次化的存储结构 CPU通用寄存器Byte量级–SRAM高速缓存KB\MB量级–DRAM主存MB\GB量级–DISK磁盘GB\TB量级  容量越来越大但是速度更慢，但单位字节成本更低</h3><h3 id="内存条即内存模组是由若干个DRAM芯片和电路组成的。"><a href="#内存条即内存模组是由若干个DRAM芯片和电路组成的。" class="headerlink" title="内存条即内存模组是由若干个DRAM芯片和电路组成的。"></a>内存条即内存模组是由若干个DRAM芯片和电路组成的。</h3><h3 id="DRAM芯片内部核心的就是一个存储阵列，还有一个行译码器、列译码器、缓冲区-。"><a href="#DRAM芯片内部核心的就是一个存储阵列，还有一个行译码器、列译码器、缓冲区-。" class="headerlink" title="DRAM芯片内部核心的就是一个存储阵列，还有一个行译码器、列译码器、缓冲区 。"></a>DRAM芯片内部核心的就是一个存储阵列，还有一个行译码器、列译码器、缓冲区 。</h3><h3 id="DRAM组成："><a href="#DRAM组成：" class="headerlink" title="DRAM组成："></a>DRAM组成：</h3><p>DRAM的存储信息存储在存储阵列中，由一个行坐标和列坐标可以选中一个存储单元，通常包含4bit或者8bit。基本单元通过一个电容实现1bit存储信息。</p>
<h3 id="DRAM-基础存储单元1bit构成："><a href="#DRAM-基础存储单元1bit构成：" class="headerlink" title="DRAM 基础存储单元1bit构成："></a>DRAM 基础存储单元1bit构成：</h3><p>1个电容，一个行选择信号介入的NMOS和列选择信号NMOS还有一个刷新放大器，因为电容会漏电，所以要定时刷新电容值。写入就是给电容充电，读就是电容放电。</p>
<h3 id="DRAM的特点："><a href="#DRAM的特点：" class="headerlink" title="DRAM的特点："></a>DRAM的特点：</h3><p>优点：  </p>
<ul>
<li>集成度高</li>
<li>功耗低</li>
<li>价格低<br>缺点：</li>
<li>速度较慢</li>
<li>定时刷新</li>
</ul>
<p>当前常用的是DDR4 SDRAM</p>
<h3 id="SRAM的基本存储单位（1bit）："><a href="#SRAM的基本存储单位（1bit）：" class="headerlink" title="SRAM的基本存储单位（1bit）："></a>SRAM的基本存储单位（1bit）：</h3><p>双稳态触发器。由6个晶体管构成其中有两个PMOS，4个NMOS，信号输入输出端，和电源接地。 当读出和写入结束后，利用晶体管组成的结构，加上外接电源可以保持内部存储信息不变，这也是为什么突然断电就会丢失SRAM的信息。</p>
<h3 id="SRAM基本结构："><a href="#SRAM基本结构：" class="headerlink" title="SRAM基本结构："></a>SRAM基本结构：</h3><p>数据存储在存储矩阵里，此外有地址线连接译码驱动，这里的实现不同与DRAM，不是通过行列选择的。而且选择的存储矩阵单位可能是8bit也可能是16,64bit，另外通过读写控制连接着读写控制线和数据线，实现指定读还是写什么数据的过程。</p>
<h3 id="SRAM的特点："><a href="#SRAM的特点：" class="headerlink" title="SRAM的特点："></a>SRAM的特点：</h3><p>优点：</p>
<ul>
<li>速度较快<br>缺点：</li>
<li>集成度低</li>
<li>功耗较高</li>
<li>价格较高</li>
</ul>
<p>现代CPU中高速缓存都是用SRAM实现的，主存用DRAM实现</p>
<h3 id="主存工作原理（SDRAM）"><a href="#主存工作原理（SDRAM）" class="headerlink" title="主存工作原理（SDRAM）"></a>主存工作原理（SDRAM）</h3><pre><code>1.CPU会申请总线控制权，Bus Request,然后发送内存控制器32位地址。内存控制器会将这个地址分解形成行地址和列地址，然后内存控制器就会像内存发起访存操作。
2.[precharge]and row Access 通过存储总线发出行地址，会被行译码器row decoder接受，会在存储阵列中选取全部这一行，然后经过一个放大器，放大后放在一个缓冲区当中。（这个过程就叫行访问或者激活）
3.tRCD后就会发出列地址，Column Access会被列译码器接受。列译码器Column decoder接收到然后在缓冲区中选择对应的列。然后把对应存储单元数据放到数据接口处。（这一过程叫列访问）
4.Bus Transmission 数据传输回CPU
</code></pre>
<h3 id="tRCD（row-to-column-delay）-：从行选择到列选择的延迟-2-3个时钟-（15-23ns-PC133标准）"><a href="#tRCD（row-to-column-delay）-：从行选择到列选择的延迟-2-3个时钟-（15-23ns-PC133标准）" class="headerlink" title="tRCD（row to column delay） ：从行选择到列选择的延迟 2-3个时钟 （15-23ns PC133标准）"></a>tRCD（row to column delay） ：从行选择到列选择的延迟 2-3个时钟 （15-23ns PC133标准）</h3><h3 id="CL-（CAS-latency）-从列选到数据输出的延迟-（15-23ns-PC133标准）"><a href="#CL-（CAS-latency）-从列选到数据输出的延迟-（15-23ns-PC133标准）" class="headerlink" title="CL （CAS latency） 从列选到数据输出的延迟 （15-23ns PC133标准）"></a>CL （CAS latency） 从列选到数据输出的延迟 （15-23ns PC133标准）</h3><h3 id="tRP：-行预充电（关闭行）的延迟时间-（15-23ns-PC133标准）"><a href="#tRP：-行预充电（关闭行）的延迟时间-（15-23ns-PC133标准）" class="headerlink" title="tRP： 行预充电（关闭行）的延迟时间  （15-23ns PC133标准）"></a>tRP： 行预充电（关闭行）的延迟时间  （15-23ns PC133标准）</h3><h3 id="为什么一下子取一行？"><a href="#为什么一下子取一行？" class="headerlink" title="为什么一下子取一行？"></a>为什么一下子取一行？</h3><p>因为通常情况下，访问内存都不会只读一个数，而是会连续读出多个数，将一行连接到缓冲区中和连接一个并没有什么时间上的差异，而且如果下一次访存还在同一行，则可以跳过行选择阶段，大大缩短访存的时间。</p>
<h3 id="预充电是什么？"><a href="#预充电是什么？" class="headerlink" title="预充电是什么？"></a>预充电是什么？</h3><p>如果下一次CPU访问内存对应的行地址不是上一次的行地址，则需要对缓存区也就是激活的这一行关闭，这就叫预充电。预充电有两种方式，第一种是传输结束后就开始预充电，另一种是下一次接受访存指令后如果非同一行再预充电。</p>
<p>亿PC133标准下，SDRAM为例，时钟周期是7.5ns tRCD,CL,tRP均为3个周期，则大约一次访存需要12个周期，90ns</p>
<h3 id="SDRAM为什么很难性能提升？"><a href="#SDRAM为什么很难性能提升？" class="headerlink" title="SDRAM为什么很难性能提升？"></a>SDRAM为什么很难性能提升？</h3><p>因为SDRAM的读写根本还是对电容的充放电，而这部分时间很难被优化。</p>
<h3 id="DDR？是什么"><a href="#DDR？是什么" class="headerlink" title="DDR？是什么"></a>DDR？是什么</h3><p>DDR就是DOUBLE DATA RATE ，双倍数据率，是一种传递数据的方式，不止用于内存数据传输上，是一种时钟频率上升或者下降沿都传输数据的<br>后续DDR-200 DDR2-400 DDR2-800就是在双倍数据率基础上提高翻倍核心频率，和主频率不同了。</p>
<h3 id="Cache的原理："><a href="#Cache的原理：" class="headerlink" title="Cache的原理："></a>Cache的原理：</h3><p>Cache的工作原理是基于程序访问的局部性原理（通俗说就是把经常用到的数据放在一个高速的cache里面）。即时间程序性和空间程序性。时间程序性就是被访问的存储器单元（指令或者数据）很快还会被再次访问。空间局限性，就是正在被访问的存储器单元附近的单元很快会被再次访问。</p>
<p>所以cache在去主存中取回带访问数据的同时，还会同时取回与位置相邻的主存单位的数据，<strong>以数据块为单位和主存进行数据交换</strong>。并保存最近被主存数据频繁访问的主存单元的数据。</p>
<h3 id="cache访问过程"><a href="#cache访问过程" class="headerlink" title="cache访问过程"></a>cache访问过程</h3><p>CPU向cache发出读请求，cache判断是否在cache中，如果在，就叫做cache hit cache命中，从cache中读数据并返回。如果这个数据不再cache中，则称为cache miss cache失效，则继续向主存发出读请求，读出数据并返回，返回的数据块返回cache，cache会更新数据块内容，并把CPU指定内容返回给CPU。</p>
<h3 id="cache的写策略："><a href="#cache的写策略：" class="headerlink" title="cache的写策略："></a>cache的写策略：</h3><ul>
<li>Cache命中时的写策略：1.写穿透 write through 数据同时写入cache和内存<pre><code>              2.写返回 write back 数据值写入cache仅当数据块被替换的时候才将数据写会主存。
</code></pre>
</li>
<li>Cache失效时的写策略：1.写不分配 直接将数据写入内存<pre><code>               2.写分配 将该数据所在的块读入cache后，再将数据写入cache。
</code></pre>
</li>
</ul>
<p>写穿透和写不分配这套组合适合设计简单但是对性能要求不高的系统。</p>
<p>写分配和写返回适用于高性能。</p>
<h3 id="平均访问时间：-hittime-miss-penalty-miss-rate"><a href="#平均访问时间：-hittime-miss-penalty-miss-rate" class="headerlink" title="平均访问时间： = hittime + miss penalty* miss rate"></a>平均访问时间： = hittime + miss penalty* miss rate</h3><p>提高一点点命中率都会带来性能很大程度上的提升</p>
<p>cache失效的原因：</p>
<h3 id="义务失效："><a href="#义务失效：" class="headerlink" title="义务失效："></a>义务失效：</h3><p>第一次访问某数据块也称为冷启失效。无法有效避免。</p>
<h3 id="容量失效"><a href="#容量失效" class="headerlink" title="容量失效"></a>容量失效</h3><p>cache无法保存程序访问的所需要的所有数据块  —- 可以通过增加cache容量缓解</p>
<h3 id="冲突失效"><a href="#冲突失效" class="headerlink" title="冲突失效"></a>冲突失效</h3><p>多个存储器位置映射到同一个cache位置，而导致冲突带来的失效。—使用多路组相连cache</p>
<h3 id="cache的替换算法："><a href="#cache的替换算法：" class="headerlink" title="cache的替换算法："></a>cache的替换算法：</h3><ul>
<li>random 随机替换算法，硬件随机选择一个cache数据块替换</li>
<li>轮转 round robin 按照设定顺序依次选择cache数据块替换</li>
<li>最近最少使用LRU算法，用硬件记录访问历史信息，然后选择距离现在最长时间未被访问的cache数据块选择替换。</li>
</ul>
<p>core i7 的多级高速缓存：<br>L1 cache 指令和数据分离 各32KB 8路组相连 命中周期为4个周期</p>
<h3 id="输入输出接口（I-O接口-的基本功能"><a href="#输入输出接口（I-O接口-的基本功能" class="headerlink" title="输入输出接口（I/O接口)的基本功能"></a>输入输出接口（I/O接口)的基本功能</h3><ul>
<li>1.数据缓冲 解决CPU与外设之间的速度差距</li>
<li>2.提供联络信息  协调与同步数据交换过程</li>
<li>3.信号与信息格式地转换  模/数  数/模转换 串/并转换  电平转换</li>
<li>4.设备选择 同一个I/O接口可能接着几个I/O设备所以需要选择是哪个设备</li>
<li>5.中断管理</li>
<li>6.可编程功能</li>
</ul>
<p>I/O接口可能是主板上的一个插卡 也可能是主板上的一个芯片。</p>
<h3 id="I-O接口组成："><a href="#I-O接口组成：" class="headerlink" title="I/O接口组成："></a>I/O接口组成：</h3><p>内部有数据输入寄存器、数据输出寄存器、状态寄存器、控制寄存器、中断控制逻辑、和连接三个线的接口 数据总线 地址总线 控制总线通过并行接口电路接进来。并行接口电路是I/O接口的一种，一般有两种常见的物理实现形式，一种是独立的芯片，一种是包含在多功能芯片中。</p>
<h3 id="并行接口电路连接较为复杂设备的工作方式："><a href="#并行接口电路连接较为复杂设备的工作方式：" class="headerlink" title="并行接口电路连接较为复杂设备的工作方式："></a>并行接口电路连接较为复杂设备的工作方式：</h3><p>除了连接了并行输出数据的8根数据线，还要有两根通讯联络信号，又称为握手信号。当设备准备好以后，就会发出输出/输入请求，而接口接收到信号后也要返回一个回答信号，这样才能保证数据既不会重复也不会遗漏。现代个人计算机中会和其他很多输入输出设备的接口集成在南桥芯片中。部分性能要求搞得或者用途特殊的输入输出接口采用独立芯片或者板卡的形式。</p>
<h3 id="握手信号："><a href="#握手信号：" class="headerlink" title="握手信号："></a>握手信号：</h3><p>总是成对出现，在数据传输中启着定时协调和联络的作用，采用握手方式数据传输，每一过程必须都有应答，彼时进行确认。</p>
<p>I/O接口:I/O接口内部包含一组称为I/O端口的寄存器，每个端口都有自己的端口号（端口地址）。</p>
<h3 id="I-O端口编址："><a href="#I-O端口编址：" class="headerlink" title="I/O端口编址："></a>I/O端口编址：</h3><ol>
<li>I/O端口和存储器分开编址。(I/O映像的I/O方式)直接寻址：用一个字节立即数指定端口地址，间接寻址就是用DX的内容指定端口地址（端口地址小于256）。端口地址（&gt;255）只能用间接寻址（因为指令字节长度的限制）分开编址会出现存储器和I/O接口同址的情况，所以要用一个M/IO信号指定是访问存储器还是I/O接口。</li>
<li>I/O端口和存储器统一编址。（存储器映像的I/O方式）</li>
</ol>
<h3 id="统一编址和分开编址优缺点："><a href="#统一编址和分开编址优缺点：" class="headerlink" title="统一编址和分开编址优缺点："></a>统一编址和分开编址优缺点：</h3><p>统一编址：<br>1.优点：</p>
<ul>
<li>可以用访问存储器的指令来访问I/O端口，访问存储器的指令功能比较齐全，可以实现对I/O端口内的数据进行处理</li>
<li>可以将CPU中I/O操作和访问存储器操作统一设计为一套控制逻辑，简化内部结构，cpu无需产生区别访问内存操作和I/O操作的控制信号，从而可减少引脚。</li>
</ul>
<p>2.缺点：</p>
<ul>
<li>由于I/O设备占用了一部分存储器地址，所以存储地址变小了。</li>
<li>由于利用访问存储器的指令来进行I/O操作，所以指令长度通常比单独的I/O指令长，所以执行指令的执行时间也比较长。</li>
</ul>
<p>分开编址：<br>优点：</p>
<ol>
<li>I/O端口不占用存储器地址，不会减少用户的存储器地址空间</li>
<li>I/O指令编码短，执行快</li>
<li>I/O指令的地址码短，地址译码方便</li>
<li>采用单独的I/O指令，使得程序中I/O操作和其他操作层次清晰，便于理解<br>缺点：</li>
<li>只能用专门的I/O指令，访问端口的方法不如访问存储器的方法多。</li>
<li>需要专门的区分内存操作还是I/O操作。</li>
</ol>
<h3 id="输入输出控制方式："><a href="#输入输出控制方式：" class="headerlink" title="输入输出控制方式："></a>输入输出控制方式：</h3><p>输入输出控制方式就是指CPU如何控制外设的数据传送的，I/O控制方式的分类：<br>1.程序控制方式<br>2.中断控制方式<br>3.直接存储器访问(DMA)方式</p>
<h3 id="程序控制方式："><a href="#程序控制方式：" class="headerlink" title="程序控制方式："></a>程序控制方式：</h3><p>1.无条件控制方式 </p>
<pre><code>1.适用于简单外设 总是假设外设已经准备好了
2.CPU直接使用指令和外设传送数据
3.不查询外设的工作状态
</code></pre>
<p>2.程序查询传送方式：</p>
<pre><code>CPU通过执行一段程序，不断查询外设的工作状态，在确定外设已经准备就绪的时候才传输数据
</code></pre>
<h3 id="程序查询传送方式流程："><a href="#程序查询传送方式流程：" class="headerlink" title="程序查询传送方式流程："></a>程序查询传送方式流程：</h3><p>1.CPU执行指令，将控制字写入接口的控制寄存器，从而设置接口的工作模式。<br>2.CPU执行指令，将数据写入接口的“输出缓冲寄存器”<br>3.接口将数据发到“并行数据输出”信号线上，并将“输出准备好”信号置为有效（亦可以由CPU写控制字将该信号置为有效）<br>4.外设发现“输出准备好”信号有效后，从“并行数据输出”信号线上接受数据，并将“输出回答”信号置为有效<br>5.接口发现“输出回答”信号置为有效以后就会从状态寄存器中的状态位“输出缓冲空”置为有效<br>6.在这个过程中，CPU反复执行指令从“状态寄存器”中读出状态字，直到“输出缓冲空”，然后开始下一个输出过程，继续输出新数据。</p>
<p>输入过程就是（状态字等待识别“输入缓冲满”）（同时是外设发送输入准备好信号，接口返回输入准备好信号）</p>
<h3 id="程序控制方式的优缺点："><a href="#程序控制方式的优缺点：" class="headerlink" title="程序控制方式的优缺点："></a>程序控制方式的优缺点：</h3><ol>
<li>无条件传送方式</li>
</ol>
<ul>
<li>优点： 控制程序简单</li>
<li>缺点：只适用于简单外设的操作</li>
</ul>
<ol start="2">
<li>程序查询传送方式</li>
</ol>
<ul>
<li>优点：比无条件传送方式更加准确和可靠 ，</li>
<li>缺点：查询外设状态占用了大量时间，降低了CPU运行效率<br>共同优缺点：<br>优点：对外设的要求比较低，操作流程清晰<br>缺点：要靠CPU进行数据的传送操作，占用了宝贵的运算资源，外设和存储器之间的数据交换任然由CPU承担，使用数据传送指令 占用了宝贵的CPU运算资源，而且数据传输过程还是要先存储到CPU的通用寄存器中中转，过程冗长。</li>
</ul>
<h3 id="中断控制方式："><a href="#中断控制方式：" class="headerlink" title="中断控制方式："></a>中断控制方式：</h3><ol>
<li>系统初始化时，CPU执行指令，将控制字写入接口的控制寄存器里，设置接口的工作模式。</li>
<li>外设将数据发送到并行数据输入信号，并将数据输入准备好信号置为有效</li>
<li>接口发现输入准备好信号有效后，从并行数据输入信号接收数据，放入输入缓冲寄存器，并将输入回答信号置为有效，组织外设进一步输入新数据。</li>
<li>接口通过中断控制逻辑像CPU发出中断请求信号，并将状态寄存器中的状态位”输入缓冲满“置为有效（因为中断后CPU不知道外设为啥中断，所以要设置状态寄存器的信息）</li>
<li>CPU收到中断请求后，进入中断服务程序，执行指令从状态寄存器中读出状态字，发现输入缓冲满，因此执行指令，从输入缓冲寄存器中读入数据</li>
<li>接口将输入回答信号置为无效，等待外设输入新数据</li>
</ol>
<h3 id="中断控制方式的特点："><a href="#中断控制方式的特点：" class="headerlink" title="中断控制方式的特点："></a>中断控制方式的特点：</h3><ul>
<li>优点：</li>
</ul>
<ol>
<li>CPU 可以和外设并行工作，提高了工作效率    </li>
<li>外围设备具有申请服务的主动权    </li>
<li>一定程度上满足了I/O处理的实时性要求    </li>
</ol>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>外设和存储器之间的数据交换任然由CPU承担</li>
<li>使用数据传送指令 占用了宝贵的CPU运算资源</li>
<li>而且数据传输过程还是要先存储到CPU的通用寄存器中中转，过程冗长。</li>
<li>进入和退出中断需要额外的指令，增加了一些开销。</li>
</ol>
<h3 id="中断控制方式和程序查询方式比较："><a href="#中断控制方式和程序查询方式比较：" class="headerlink" title="中断控制方式和程序查询方式比较："></a>中断控制方式和程序查询方式比较：</h3><p>虽然大部分时间中断控制方式都有明显的系统性能提升的优势，但是关键时刻还得用程序查询方式，比如数据很重要和响应数据速度要求很高的时候，这时候中断就比较慢了。</p>
<h2 id="外部中断："><a href="#外部中断：" class="headerlink" title="外部中断："></a>外部中断：</h2><p>外部中断也称为硬件中断 ：由CPU外部设备中断请求信号启动的中断<br>X86提供了两个引脚  NMI非可屏蔽中断  INTR 可屏蔽中断 </p>
<p>非屏蔽中断不受中断允许标志IF的影响<br>CPU的可屏蔽中断通过一个中断控制器连接进cpu不同的外设连接到这个中断控制器上，可屏蔽中断的类型码由中断控制器提供，中断允许标志IF用于屏蔽此类中断</p>
<p>可编程中断控制器PIC，中断控制器的接口也是有限的， 所以要更多输入输出设备接口就得串一些PIC，组成层级的中断控制器。现在的PC已经把大部分I/O接口集成到了南桥中，所以南桥内实现一个叫APIC的高级可编程中断控制器，用于发送中断控制信号，南桥外部的I/O接口的中断请求信号也要通过他来实现。CPU中也有APIC，因为现在的多核体系，不但要接受CPU也需要发出中断请求用来和其他CPU来交互。</p>
<h3 id="中断嵌套："><a href="#中断嵌套：" class="headerlink" title="中断嵌套："></a>中断嵌套：</h3><ol>
<li>当CPU正在执行中断服务程序，发生优先级更高的中断请求</li>
<li>CPU响应优先级更高的中断请求，而将正在处理的中断暂时挂起</li>
<li>CPU完成优先级更高的中断服务后，返回此前优先级较低的终端服务程序继续执行。</li>
</ol>
<h3 id="为什么需要中断来进行I-O操作："><a href="#为什么需要中断来进行I-O操作：" class="headerlink" title="为什么需要中断来进行I/O操作："></a>为什么需要中断来进行I/O操作：</h3><p>依托CPU来完成I/O输入输出的信号是不现实的，因为这中间不断地查询输入输出完成的信号中产生的等待的漫长时间会巨大的拖累CPU的性能。简单的来说就是不能让CPU一直这么干等着。</p>
<h3 id="DMA方式："><a href="#DMA方式：" class="headerlink" title="DMA方式："></a>DMA方式：</h3><p>因为现代计算机连接的外设越来越多，而且比如显示器、网络等不但传输数据量大，而且对速率要求也很高，这些数据如果都是通过CPU搬运到寄存器在搬运到对应内存就是非常浪费时间的一种方式，所以就需要一个DMA方式。DMA direct memory access（DMA）直接存储器访问，这部分工作是由专门硬件电路控制，进行外设与存储器直接数据传送。也设置了专门硬件控制电路DMA控制器简称DMAC。DMAC既有MASTER接口也有Slave接口。</p>
<h3 id="DMAC的基本工作步骤："><a href="#DMAC的基本工作步骤：" class="headerlink" title="DMAC的基本工作步骤："></a>DMAC的基本工作步骤：</h3><ol>
<li>CPU设置DMAC内部配置寄存器：源地址的初始值以及传送时地址增减 以及目的地址的初始值和传送时的地址增减方式、以及传送数据的长度（可以不设置）</li>
<li>DMAC处于空闲等待状态</li>
<li>I/O接口会通过一个信号线向DMAC发出DMA传送申请</li>
<li>DMAC收到响应以后会通过另一根线响应I/O的申请</li>
<li>DMAC向I/O接口发起总线读传输</li>
<li>DMAC向存储器发起总线写传输 然后写到存储器中</li>
<li>重复5-6直到本次DMA传送完成</li>
<li>然后返回第2步等待下一次DMA传送申请</li>
</ol>
<h3 id="自带DMAC的I-O接口-："><a href="#自带DMAC的I-O接口-：" class="headerlink" title="自带DMAC的I/O接口 ："></a>自带DMAC的I/O接口 ：</h3><p>显卡、网卡都有自带，只为这个I/O服务，可以更好地根据数据的特点来定制，更好的完成数据传输</p>
<h2 id="流水线处理器"><a href="#流水线处理器" class="headerlink" title="流水线处理器"></a>流水线处理器</h2><h3 id="流水线技术定义："><a href="#流水线技术定义：" class="headerlink" title="流水线技术定义："></a>流水线技术定义：</h3><p>流水线技术是一种将每条指令分解为多步，并让各步操作重叠，从而实现几条指令并行处理的技术。程序中的指令仍是一条条顺序执行，但可以预先取若干条指令，并在当前指令尚未执行完时，提前启动后续指令的另一些操作步骤。这样显然可加速一段程序的运行过程。流水线技术是通过增加计算机硬件来实现的。<br>流水线的本质实际上是利用了时间的并行性，让原来应该先后执行的指令在时间上一定程度上并行起来。</p>
<p>划分流水线的时候尽量做到每一级的时间尽量相等。   </p>
<h3 id="超级流水线技术（super-pipelining）："><a href="#超级流水线技术（super-pipelining）：" class="headerlink" title="超级流水线技术（super pipelining）："></a>超级流水线技术（super pipelining）：</h3><p>将五级流水线细分为更多阶段，增加流水线的深度，这样的流水线，就会被称为超级流水线。</p>
<p>超级流水线技术提升了时钟频率，从而提高了指令吞吐率。但是超级流水线也面临着不是级数越多，深度越深越好。流水线的级数越多，单条指令的执行越长，还面临更多冒险的风险。现在的主流处理器平均在15级左右。</p>
<h3 id="超标量流水线："><a href="#超标量流水线：" class="headerlink" title="超标量流水线："></a>超标量流水线：</h3><p>是指在CPU中有一条以上的流水线，并且每时钟周期内可以完成一条以上的指令，这种设计就叫超标量技术。超级标量是指cpu内一般能有多条流水线,这些流水线能够并行处理。在单流水线结构中，指令虽然能够重叠执行，但仍然是顺序的,每个周期只能发射(issue)或退休(retire)一条指令。超级标量结构的cpu支持指令级并行，每个周期可以发射多条指令(2-4条居多)。可以使得cpu的IPC(InstructionPerClock)&gt;，从而提高cpu处理速度。</p>
<h3 id="超标量流水线和CPU："><a href="#超标量流水线和CPU：" class="headerlink" title="超标量流水线和CPU："></a>超标量流水线和CPU：</h3><p>现代多核CPU通常是在CPU的芯片内部中集成了多个超标量处理器核 </p>
<h3 id="超标量技术和超级流水线技术"><a href="#超标量技术和超级流水线技术" class="headerlink" title="超标量技术和超级流水线技术"></a>超标量技术和超级流水线技术</h3><p>并不相关。超级流水线技术是时间换空间，超标量技术是空间换时间。</p>
<h3 id="冒险-风险（hazard）："><a href="#冒险-风险（hazard）：" class="headerlink" title="冒险/风险（hazard）："></a>冒险/风险（hazard）：</h3><p>是指在计算机CPU的结构中，指令流水线乱序执行中的一些问题可能会导致得到不正确的计算结果，或阻止下一条指令在以下各时钟周期开始执行的情况。有3类典型的冒险：<br>结构冒险 、数据冒险、控制冒险。</p>
<p>结构冒险：所需要的的硬件部分正在为之前的指令工作。<br>数据冒险：需要等待之前的指令完成数据的读写。<br>控制冒险：需要根据之前指令的结果决定下一步的行为。  </p>
<h3 id="解决冒险通用方案："><a href="#解决冒险通用方案：" class="headerlink" title="解决冒险通用方案："></a>解决冒险通用方案：</h3><p>是流水线停顿（stall），产生空泡（bubble）。但是这种解决方案使得整个流水线效率降低。</p>
<h3 id="解决结构冒险："><a href="#解决结构冒险：" class="headerlink" title="解决结构冒险："></a>解决结构冒险：</h3><p>解决方案1： 通用方案。<br>解决方案2： 指令和数据不存放在相同的存储器中。在处理器中设定指令高速缓存和数据高速缓存来实现的。只是在cpu中一级高速缓存是采用这种分开存放的，而冯诺依曼机构中内存存储数据和指令的思维不变。<br>解决方案3：对于读寄存器和回写寄存器同时发生的情况：把一个时钟周期分为两个部分，前半部分用来作为寄存器堆的写入，后半部分时间用来作为寄存器堆的读出，并且在寄存器堆上实现独立的读写口。这是因为寄存器堆的读写相对要快很多，一般是ALU等部件的一半延迟。</p>
<h3 id="解决数据冒险：（寄存器类和存储器类）"><a href="#解决数据冒险：（寄存器类和存储器类）" class="headerlink" title="解决数据冒险：（寄存器类和存储器类）"></a>解决数据冒险：（寄存器类和存储器类）</h3><ul>
<li><p>一条指令需要使用之前指令的运算结果，但是结果还没有写回：</p>
<p>  1.软件解决方案： 插入nop指令（就是空指令，但占用指令时间）<br>  2.硬件解决方案： 流水线停顿stall，产生空泡bubble。检查当前需要读的寄存器是否和前面指令要写的寄存器相同，如果有相同就说明有数据冒险，就插入空泡。<br>  3.数据前递（Forwarding）\旁路（Bypass） 我们可以搭建一个旁路，实现数据绕过寄存器堆，直接进入下一条指令的执行阶段</p>
</li>
<li><p>load-use冒险：就是一条指令需要使用之前的访存结果。</p>
<p>  数据前递是无法实现的，所以只能通过流水线停顿，插入bubble来停顿一个时间周期，然后在通过数据前递实现。</p>
</li>
</ul>
<h3 id="控制冒险："><a href="#控制冒险：" class="headerlink" title="控制冒险："></a>控制冒险：</h3><p>转移指令改变指令流向，破坏流水模式。转移指令是非常常见的指令，每隔4-7条指令就会产生一条转移指令，转移指令会带来若干个不需要执行的指令进入流水线。而现代都是超标量深度流水线，比如4发射16级，就是同时有64条指令在处理器中，流水线越深，超标量越多，则带来的影响越大。  </p>
<h3 id="转移开销："><a href="#转移开销：" class="headerlink" title="转移开销："></a>转移开销：</h3><p>当执行了转移指令，并确实发生了转移时，产生如下的开销则称为转移开销：1.将按顺序预取的指令废除（即排空流水线）2.从转移目标地址重新取指令。转移开销有两部分组成，一个是转移条件判定引起的开销，一个是重新计算转移目标地址引起的开销。</p>
<p>转移指令分为无条件转移和有条件转移，而无条件和有条件也分为直接转移指令，就是直接给出了目标转移的地址，和间接转移地址，即目标转移地址不直接给出，而是在指定寄存器中存储。</p>
<h3 id="解决控制冒险："><a href="#解决控制冒险：" class="headerlink" title="解决控制冒险："></a>解决控制冒险：</h3><p>无条件直接转移J指令的转移目标地址可以在取址阶段就获得，流水线可以不停顿。<br>无条件间接转移JR指令的转移目标地址可以在译码阶段获得，流水线停顿了一个周期。<br>有条件直接转移beq指令，可以在寄存器堆的输出端增加一个比较电路，这样在译码阶段就可以得到条件判断的结果，所以流水线停顿了一个周期。</p>
<p>延迟转移技术：就是修改条件转移后的那条指令，那条指令是无论条件判断结果都一定会执行的，这样就可以实现流水线不停顿了。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41832850/article/details/98856042">CPU流水线技术 数据冒险和结构冒险</a></p>
<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>运算发生了溢出，硬件是很容易检测到的，用硬件处理溢出会导致系统设计不灵活，设计出来以后就没法改变电路，从而没有办法改变处理溢出的方式。所以采用软件方式处理异常。从ALU在这里连一条线到PC更新部件，转移目标地址为比如说0到pc计数器，下面就会从指令存储器中取出对应地址的应对中断程序。可以统称为中断，分为内部中断和外部中断，有些地方会吧内部中断叫异常。</p>
<p>pc计数器中指令序列从一个指令地址切到给出下一个控制地址的过程，叫做控制转移，control transfer,这样控制转移序列叫做控制流 control flow。</p>
<h3 id="异常控制流ECF："><a href="#异常控制流ECF：" class="headerlink" title="异常控制流ECF："></a>异常控制流ECF：</h3><p>现代系统通过控制流的突变来对系统状态做出反应。程序计数器在通常情况下会依次加载这些相邻的指令交给CPU执行，但是在某些情况下可能会发生突变，从而打破cpu本应该顺序执行这些指令序列的预期行为，这种突变就叫做控制流的异常，简称为ECF（Exception Control Flow）</p>
<h3 id="异常："><a href="#异常：" class="headerlink" title="异常："></a>异常：</h3><p>异常是指在程序运行过程中发生的异常事件，就是控制流的突变，用来响应处理器状态中某些部分发生的变化。</p>
<h3 id="存储器中保留两个专用区域，一个是中断向量表区。一个是初始化程序区。初始化指向向量表区，向量表区发出对应终端应用程序地址。"><a href="#存储器中保留两个专用区域，一个是中断向量表区。一个是初始化程序区。初始化指向向量表区，向量表区发出对应终端应用程序地址。" class="headerlink" title="存储器中保留两个专用区域，一个是中断向量表区。一个是初始化程序区。初始化指向向量表区，向量表区发出对应终端应用程序地址。"></a>存储器中保留两个专用区域，一个是中断向量表区。一个是初始化程序区。初始化指向向量表区，向量表区发出对应终端应用程序地址。</h3><h3 id="中断向量表："><a href="#中断向量表：" class="headerlink" title="中断向量表："></a>中断向量表：</h3><p>存放的是中断服务程序的入口地址，也称为中断向量，每个入口地址占4个字节。前两个字节单元存放中断服务程序入口的偏移量IP（指令指针寄存器），低字节在前高字节在后，而后两个字节单元存放中断服务程序入口地址的段基址(cs)也是低字节在前，高字节在后。<br>具体不同系统芯片设计向量表不同，8086是256个中断向量，5个专用中断，27个保留中断，224个供用户自定义的中断。</p>
<p>系统响应中断先会发出一个转移指令，INT 1（INT+数字的形式）指向对应几号中断向量，然后中断向量发出段地址和偏移地址运算器计算地址并取出对应中断服务程序。</p>
<p>每次开机启动的时候，bios芯片初始化各个部件的时候，有一项工作就是去主存0地址的地方去构建中断向量表。</p>
<h3 id="中断处理过程："><a href="#中断处理过程：" class="headerlink" title="中断处理过程："></a>中断处理过程：</h3><ul>
<li>1.关闭中断：CPU关闭中断响应以后，就不再接受其他外部中断请求</li>
<li>2.保存断点：把原来将要执行的指令地址压入堆栈，以使中断处理完成后能正确地返回。</li>
<li>3.识别中断源：CPU识别中断的来源，确定中断类型号，从而找到对应的中断服务程序的入口地址。</li>
<li>4.保存现场：将发生中断处有关的寄存器以及标志寄存器的内容压入栈中。</li>
<li>5.执行中断服务程序：转到中断服务程序入口开始执行，可以适当时刻开放中断，以允许响应较高优先级的外部中断。标志寄存器FLAGS中IF标志位，来在中断中优先处理更高级中断。标志寄存器属于控制标志，就是软件设置值，硬件实现改变电路。</li>
<li>6.恢复现场并返回：把保护现场时压入栈中的信息弹回原寄存器（cs\ip\psw），然后执行中断返回指令，从而返回主程序继续运行。<br>前三步由应将实现，后三部分由软件实现。<br>CPU执行某条指令</li>
</ul>
<p>发生中断，CPU内部产生中断信号，CPU内部判断中断来源，产生中断类型码N（对应前者3）<br>，当前CS/IP/PSW压栈（对应前者2、4），清除IF和TF（对应前者1），取CS/IP新值，转入中断服务程序（对应前者5），开放中断（可选），IRET指令使旧的CS/IP/PSW弹出堆栈（对应前者6）其实1,2,3,是硬件一起实现的，所以具体顺序无伤大雅。</p>
<h3 id="中断标志IF："><a href="#中断标志IF：" class="headerlink" title="中断标志IF："></a>中断标志IF：</h3><p>控制可屏蔽中断的响应。如果IF 为1，则允许CPU响应可屏蔽中断请求，反之则不允许。指令STI 把IF置1，CLI把IF清零。IF对非屏蔽中断和内部中断不起作用。</p>
<h3 id="单步中断："><a href="#单步中断：" class="headerlink" title="单步中断："></a>单步中断：</h3><p>常用于系统调试的，把标志寄存器TF置为1后，cpu便处于单步工作方式。在单步工作方式下，CPU没执行完一条指令，就会自动产生一个类型1的中断，进入类型1中断服务程序。<br>类型1中断服务程序通常显示CPU内部个寄存器的内容和一些其他信息，以便调试和检查错误  </p>
<h3 id="断点中断："><a href="#断点中断：" class="headerlink" title="断点中断："></a>断点中断：</h3><p>与单步中断类似，也是调试程序的一种手段，并且常常与单步中断结合使用，对于一个大程序，通常通过设置断点，确定程序在哪个大的一段里在慢慢切分找到问题缩在，这样比单步中断更有效率。</p>
<h3 id="内部中断特点："><a href="#内部中断特点：" class="headerlink" title="内部中断特点："></a>内部中断特点：</h3><p>内部中断的类型号由CPU内部产生，外部中断则需要从外部设备读取中断类型号。<br>除此以外，除了单步中断外，所有内部中断都不可以用软件方法来屏蔽和禁止。单步中断可以通过软件，将TF标志标志置为1，或者清0来允许。<br>除了单步中断外，优先级也是内部中断优先级比外部中断高</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://andrekuu.github.io/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" data-id="cknsdthda0002igvea98iexqa" data-title="计算机基础" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/04/22/LeetCode-%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          LeetCode 周赛总结
        
      </div>
    </a>
  
  
    <a href="/2021/04/22/%E7%AE%97%E6%B3%95%E7%BB%8F%E9%AA%8C/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">算法经验</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/22/Linux/">Linux</a>
          </li>
        
          <li>
            <a href="/2021/04/22/Mysql%E5%9F%BA%E7%A1%80/">Mysql基础</a>
          </li>
        
          <li>
            <a href="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%86%E8%8A%82/">计算机网络细节</a>
          </li>
        
          <li>
            <a href="/2021/04/22/LeetCode-%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93/">LeetCode 周赛总结</a>
          </li>
        
          <li>
            <a href="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 AndreKuu<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>